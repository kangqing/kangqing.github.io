<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx学习笔记</title>
    <url>/article/f5398568.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.什么是Nginx？<br>Nginx是一个高性能的HTTP反向代理服务器，特点是占用内存小，并发能力强。Nginx是专为性能优化而开发的，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，有报告表明能支持高达50000个并发连接数。<br><strong>详细介绍见</strong> <a href="https://lnmp.org/nginx.html" target="_blank" rel="noopener external nofollow noreferrer">https://lnmp.org/nginx.html</a></p>
<p>2.什么是反向代理？</p>
<a id="more"></a>

<p>（1）正向代理：<br>在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问。<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-1.png" alt=""><br>（2）反向代理：<br>客户端不需要做任何配置，只需要把请求发送到反向代理服务器，反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器在客户端眼里就是一个服务器，暴露的是代理服务器的地址，隐藏了真实服务器的IP地址。<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-2.png" alt=""></p>
<p>3.负载均衡<br>例如双11当天，并发量相当庞大，达到一个顶级的配置的服务器也承担不了的并发量，这样就增加服务器的数量，然后将请求分发到各个服务器上，将负载分发到不同的服务器就是负载均衡。<br><strong>如下图，反向代理服务器通过负载均衡把15个请求平均分担到3个服务器。</strong><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-3.png" alt=""></p>
<p>4.动静分离<br>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低单个服务器的压力。<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-4.png" alt=""></p>
<p>#Nginx的常用命令<br>1.使用nginx命令的前提条件是进入到nginx的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br></pre></td></tr></table></figure>
<p>2.查看nginx的版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -v</span><br></pre></td></tr></table></figure>
<p>3.启动nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure>
<p>4.关闭nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure>
<p>5.重新加载nginx<br>修改nginx配置文件之后，不必重启nginx,重新加载nginx就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>
<p>#Nginx配置文件<br>1.位置在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<p>2.nginx配置文件组成<br>(1) 三部分组成</p>
<ul>
<li><p>第一部分：全局块<br>从开始到events块之间的部分内容，主要设置一些影响nginx服务器整体运行的配置指令，例如 worker_processes   1  值越大，可以支持的并发数量也越多。</p>
</li>
<li><p>第二部分：events块<br>events块设计的指令主要影响nginx服务器与用户的网络连接，例如worker_connections  1024 支持的最大连接数，对nginx的性能影响较大，应该灵活配置。</p>
</li>
<li><p>第三部分：http块<br>①http全局块<br>http全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。<br>②server块<br>最核心需要配置的部分。</p>
</li>
</ul>
<p>#Nginx配置实例-反向代理<br>1.实现效果<br>（1）打开浏览器访问<a href="http://www.123.com,跳转到Linux系统tomcat的主页面。" target="_blank" rel="noopener external nofollow noreferrer">www.123.com,跳转到Linux系统tomcat的主页面。</a></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-5.png" alt=""></p>
<p>2.准备工作<br>（1）Linux安装nginx<br>（2）Linux安装Tomcat</p>
<p>3.访问过程分析<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-6.png" alt=""></p>
<p>4.具体配置<br>（1）首先修改hosts文件，最后一行加上这个。因为浏览器解析域名会先到hosts文件中找对应的ip地址，没找到才会去网络中根据DNS解析。这样<a href="http://www.123.com就会被解析到ip为192.168.186.128的Linux服务器上了。" target="_blank" rel="noopener external nofollow noreferrer">www.123.com就会被解析到ip为192.168.186.128的Linux服务器上了。</a><br><img src="https://upload-images.jianshu.io/upload_images/8020666-cbe8dbe8969f5304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>（2）在nginx配置文件中进行配置反向代理。<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-7.png" alt=""><br>nginx的配置文件中这样配置到，如红线画的部分，当访问192.168.186.128的80端口的时候，请求会被转发到<a href="http://127.0.0.1:8080上。" rel="external nofollow noreferrer">http://127.0.0.1:8080上。</a><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-8.png" alt=""></p>
<p>#Nginx反向代理实例2<br>1.实现效果<br>使用nginx监听9001端口，反向代理根据不同的访问路径跳转到不同端口的服务中。</p>
<p>访问<a href="http://192.168.186.128:9001/edu/" target="_blank" rel="noopener external nofollow noreferrer">http://192.168.186.128:9001/edu/</a> 直接跳转127.0.0.1:8080<br>访问<a href="http://192.168.186.128:9001/vod/" target="_blank" rel="noopener external nofollow noreferrer">http://192.168.186.128:9001/vod/</a> 直接跳转127.0.0.1:8081</p>
<p>2.准备工作<br>（1）准备两个Tomcat服务器，一个8080端口，一个8081端口<br>（2）创建文件夹和测试页面分别在两个tomcat的webapps文件中创建edu文件夹和vod文件夹，里面分别放入相应的测试页面文件。<br><strong>这块遇到了一个大坑，就是一台centos7的机器同时开两个Tomcat的问题，网上试了很多教程都不行。</strong></p>
<h1 id="begin-一台CentOS7同时启动两个Tomcat教程"><a href="#begin-一台CentOS7同时启动两个Tomcat教程" class="headerlink" title="begin 一台CentOS7同时启动两个Tomcat教程"></a><strong><strong><em>begin 一台CentOS7同时启动两个Tomcat教程</em></strong></strong></h1><ul>
<li>首先我用的tomcat9版本，解压缩重命名分别放在了以下两个位置，解压后重命名为了tomcat和tomcat1<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">和</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;tomcat1</span><br></pre></td></tr></table></figure></li>
<li>其次，修改/etc/profile文件，注意看tomcat部分<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_221-amd64</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export MAVEN_HOME&#x3D;&#x2F;root&#x2F;installFile&#x2F;apache-maven-3.6.2</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$MAVEN_HOME&#x2F;bin</span><br><span class="line">########## tomcat ###########</span><br><span class="line">export CATALINA_BASE&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">export CATALINA_BASE&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">export TOMCAT_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">########## tomcat ############</span><br><span class="line">########## tomcat1 ###########</span><br><span class="line">export CATALINA_BASE2&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat1</span><br><span class="line">export CATALINA_BASE2&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat1</span><br><span class="line">export TOMCAT_HOME2&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat1</span><br><span class="line">##########tomcat1#############</span><br></pre></td></tr></table></figure></li>
<li>修改tomcat的配置<br>第一个tomcat不用做修改，修改第二个tomcat，如果有多个，则第一个不用修改，其余都要。<br>修改这个文件 vim /usr/local/tomcat1/bin/catalina.sh<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># OS specific support. $var must be set to either true or false.</span><br></pre></td></tr></table></figure>
注释和内容之间的上面这句话后面添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CATALINA_BASE&#x3D;$CATALINA_BASE2</span><br><span class="line">export CATALINA_HOME&#x3D;$CATALINA_HOME2</span><br></pre></td></tr></table></figure></li>
<li>修改/usr/local/tomcat1/conf/server.xml文件，把端口号改成8081，第一个tomcat不用改，其余的都要改。<br>我更改的3个地方，可以改成其他端口，自己决定<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Server port&#x3D;&quot;8005&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt; #8005修改成8015</span><br><span class="line"></span><br><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; #8080修改成8081</span><br><span class="line">connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">redirectPort&#x3D;&quot;8443&quot;  URIEncoding&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line"> #添加URIEncoding&#x3D;&quot;UTF-8&quot; 防止乱码</span><br><span class="line"></span><br><span class="line">&lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot;&#x2F;&gt;    #8009修改成8019</span><br></pre></td></tr></table></figure></li>
<li>设置开机自启（注意此部分取自网络，未经亲测）<br>原文链接：<a href="https://blog.csdn.net/zhizhenjie/article/details/82662980" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/zhizhenjie/article/details/82662980</a><br>1、因为启动tomcat会调用tomcat安装文件中的startup.sh，而它调用了catalina.sh,然后catalina.sh则调用了setclasspath.sh。所以需要在setclaspath.sh中添加JAVA_HOME和JRE_HOME两个环境变量<br>分别编辑两个tomcat中的setclasspath.sh文件：<br>vi /usr/local/tomcat8/bin/setclasspath.sh</li>
</ul>
<p>在 # Set JAVA_HOME or JRE_HOME…下边添加javahome：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # -----------------------------------------------------------------------------</span><br><span class="line"> #  Set JAVA_HOME or JRE_HOME if not already set, ensure any provided settings</span><br><span class="line"> #  are valid and consistent with the selected start-up options and set up the</span><br><span class="line"> #  endorsed directory.</span><br><span class="line"> # -----------------------------------------------------------------------------</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_181</span><br><span class="line">export JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_181&#x2F;jre</span><br></pre></td></tr></table></figure>
<p>2、在/usr/lib/systemd/system目录下增加tomcat.service文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;tomcat</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;oneshot</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat8&#x2F;bin&#x2F;startup.sh</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat8.1&#x2F;bin&#x2F;startup.sh</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat8&#x2F;bin&#x2F;shutdown.sh</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat8.1&#x2F;bin&#x2F;shutdown.sh</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPID</span><br><span class="line">RemainAfterExit&#x3D;yes</span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<p>将两个tomcat的启动程序都添加进去，</p>
<p>然后执行systemctl enable tomcat 使生效；开机启动就设置好了。</p>
<h1 id="stop-一台CentOS7同时启动两个Tomcat教程"><a href="#stop-一台CentOS7同时启动两个Tomcat教程" class="headerlink" title="stop  一台CentOS7同时启动两个Tomcat教程"></a><strong><strong><em>stop  一台CentOS7同时启动两个Tomcat教程</em></strong></strong></h1><p>3.具体配置<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-9.png" alt=""><br>记得开放对外访问端口9001和8080和8081</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8081&#x2F;tcp --permanent   &#x2F;&#x2F;开启8081端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;9001&#x2F;tcp --permanent   &#x2F;&#x2F;开启9001端口</span><br><span class="line">systemctl restart firewalld.service &#x2F;&#x2F;重启防火墙</span><br><span class="line">firewall-cmd --reload &#x2F;&#x2F;重新载入防火墙配置</span><br></pre></td></tr></table></figure>
<p>4.亲测效果<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-10.png" alt=""><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-11.png" alt=""></p>
<p>5.location指令具体说明<br>  该指令用于匹配 URL。<br>  语法如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~ ] uri &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求。<br>  2、<del>：用于表示 uri 包含正则表达式，并且区分大小写。<br>  3、</del><em>：用于表示 uri 包含正则表达式，并且不区分大小写。<br>  4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字 符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。<br>  注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~</em> 标识。 </p>
<p>#Nginx配置实例-负载均衡<br><strong>1.实现效果</strong><br>浏览器输入<a href="http://192.168.186.128:8080/edu/index.html经过nginx负载均衡，平均分配到8080和8081端口中。" target="_blank" rel="noopener external nofollow noreferrer">http://192.168.186.128:8080/edu/index.html经过nginx负载均衡，平均分配到8080和8081端口中。</a><br><strong>2.准备工作</strong></p>
<ul>
<li>准备两台tomcat一台8080，一台8081,上面已经准备好了。</li>
<li>在两台tomcat的webapps的文件夹下都创建edu文件夹，里面都创建index.html文件。</li>
</ul>
<p><strong>3.在nginx中配置负载均衡</strong><br>①如下图，在http里面加上<br>upstream myserver {<br>  //这里面是负载均衡服务器的列表；<br>}<br>②然后把server里的server_name改成域名或者ip，相当于访问这个域名的这个端口，就负载均衡平均分配给上面配置的负载均衡服务器列表。<br>③把location里加上 proxy_pass=<a href="http://myserver" target="_blank" rel="noopener external nofollow noreferrer">http://myserver</a>;</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-12.png" alt=""></p>
<p><strong>4.亲测结果</strong></p>
<ul>
<li>最好用Edge测试，用google可能缓存原因吧，一直不变。</li>
<li>我这里做了host映射，所以可以直接访问<a href="http://www.123.com相当于访问192.168.186.128" target="_blank" rel="noopener external nofollow noreferrer">www.123.com相当于访问192.168.186.128</a></li>
<li>地址不变，刷新，发现8080一次，8081一次，以此类推，负载均衡成功！！！<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-13.png" alt="image.png"><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-14.png" alt="image.png"></li>
</ul>
<p><strong>5.nginx分配服务器的策略</strong><br>①轮询（默认策略）<br>每个请求按照时间顺序注意分配到后端服务器，如果后端服务器down掉，能够自动剔除。<br>②weight 权重策略<br>weight权重默认为1 权重越高，分配的客户端请求越多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">        server    192.168.186.128:8080    weight&#x3D;5;</span><br><span class="line">        server    192.168.186.128:8081    weight&#x3D;10;  #权重高于上面8080的，所以分配的请求也多一倍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③ip_hash<br>每个请求按照用户的ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session共享问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server    192.168.186.128:8080;</span><br><span class="line">        server    192.168.186.128:8081; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④fair  (第三方方式)<br>按照后端服务器的响应时间分配，响应时间越短，优先分配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">        server    192.168.186.128:8080;</span><br><span class="line">        server    192.168.186.128:8081; </span><br><span class="line">        fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#Nginx配置实例-动静分离<br><strong>1.什么是动静分离？</strong><br>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和 静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种：</p>
<ul>
<li><p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-15.png" alt="捕获.PNG"></p>
</li>
<li><p>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 </p>
</li>
<li><p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使 浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资 源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可， 所以不会产生额外的流量。此种方法非常适合不经常变动的资源。<strong>（如果经常更新的文件， 不建议使用 Expires 来缓存）</strong>，我这里设置 3d，表示在这 3 天之内访问这个 URL，发送 一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 </p>
</li>
</ul>
<p><strong>2.准备工作</strong><br>（1）在Linux系统中创建静态资源，用于进行访问<br>根目录 / 下创建data文件夹，下面创建www文件夹存放a.html，image文件夹存放01.jpg文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;www&#x2F;a.html</span><br><span class="line">&#x2F;data&#x2F;image&#x2F;01.jpg</span><br></pre></td></tr></table></figure>
<p>（2）实现的效果，不使用tomcat，通过nginx配置访问静态资源。<br>（3）nginx的配置<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-16.png" alt="image.png"></p>
<p><strong>3.亲测效果</strong></p>
<ul>
<li><p>如下图所示：访问192.168.186.128/image把下面的目录都列出来了就是这句配置起的作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoindex    on;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-17.png" alt="image.png"></p>
</li>
<li><p>访问192.168.186.128/image/01.jpg<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-18.png" alt="image.png"></p>
</li>
<li><p>访问192.168.186.128/www/a.html<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-19.png" alt="image.png"></p>
</li>
<li><p>如果加expires 参数也是加在location里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location  &#x2F;image&#x2F; &#123;</span><br><span class="line">        root   &#x2F;data&#x2F;;</span><br><span class="line">        autoindex    on;</span><br><span class="line">        expires     3d; &#x2F;&#x2F;3天缓存过期时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#Nginx配置实例-高可用</p>
</li>
</ul>
<p><strong>1.什么是高可用？</strong></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-20.png" alt="image.png"><br>（1）需要两台nginx服务器（<strong>我这里两台服务器的ip是192.168.8.128和192.168.8.129</strong>）<br>（2）需要keepalived相当于路由检测nginx服务器是否可以正常工作。<br>（3）需要虚拟ip绑定主从两台nginx服务器，用户访问的是虚拟ip。</p>
<p><strong>2.准备工作</strong><br>（1）需要两台服务器<br>（2）在两台服务器安装nginx</p>
<p>（3）在两台服务器安装keepalived<br><strong>3.两台服务器都安装keepalived</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y keepalived</span><br></pre></td></tr></table></figure>
<ul>
<li>yum安装keepalived的默认安装目录是<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4.完成高可用的主从配置</strong><br>（1）两台服务器都修改/etc/keepalived/keepalived.conf配置文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#*******************************标记的是主从配置可能不同的地方</span><br><span class="line">global_defs &#123;   #全局定义</span><br><span class="line">  notification_email &#123;</span><br><span class="line">    acassen@firewall.loc</span><br><span class="line">    failover@firewall.loc</span><br><span class="line">    sysadmin@firewall.loc</span><br><span class="line">  &#125;    </span><br><span class="line">  notification_email_from Alexandre.Cassen@firewall.loc    </span><br><span class="line">  smtp_server 192.168.8.128  #******************************************</span><br><span class="line">  smtp_connect_timeout 30    </span><br><span class="line">  router_id LVS_DEVEL</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;      </span><br><span class="line">  script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;      </span><br><span class="line">  interval 2      #（检测脚本执行的间隔）      </span><br><span class="line">  weight 2</span><br><span class="line">&#125;   </span><br><span class="line">vrrp_instance VI_1 &#123;     </span><br><span class="line">  state MASTER   # 主服务器为 MASTER 从服务器为 BACKUP       *******************************</span><br><span class="line">  interface ens33  #网卡     ipconfig查看    *********************************************</span><br><span class="line">  virtual_router_id 51   # 主、备机的 virtual_router_id 必须相同     </span><br><span class="line">  priority 100     # 主、从机取不同的优先级，主机值较大，备份机值较小     ************************</span><br><span class="line">  advert_int 1     </span><br><span class="line">  authentication &#123;         </span><br><span class="line">    auth_type PASS         </span><br><span class="line">    auth_pass 1111     </span><br><span class="line">  &#125;     </span><br><span class="line">  virtual_ipaddress &#123;         </span><br><span class="line">    192.168.17.50 # VRRP H 虚拟地址     </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）两台服务器都在/usr/local/src中添加一个脚本文件nginx_check.sh内容如下<br>这个脚本就是检查nginx是否正常运行的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx �Cno-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>（3）把两台服务器的nginx和keepalived都启动起来。<br>keepalived的启动命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start keepalived.service</span><br></pre></td></tr></table></figure>
<p><strong>5.亲测效果</strong><br>（1）在浏览器中输入设置的虚拟ip看是否能访问，我这里设置的是192.168.8.50<br>发现可以访问到nginx的欢迎页面，通过ip a这个命令可以看到如下图，已经绑定了这个虚拟ip.<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-21.png" alt="image.png"><br>访问这个虚拟ip192.168.8.50进入nginx主页<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-22.png" alt="image.png"><br>（2）把主服务器192.168.8.128的nginx和keepalived停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop keepalived.service  &#x2F;&#x2F;停止keepalived</span><br><span class="line">.&#x2F;nginx -s stop   &#x2F;&#x2F;停止nginx必须在nginx的sbin目录下执行</span><br><span class="line">ps -ef | grep nginx &#x2F;&#x2F;查看是否停掉了</span><br><span class="line">ps -ef | grep keepalived</span><br><span class="line"></span><br><span class="line">kill -9 PID &#x2F;&#x2F;如果没停掉则用进程号停掉</span><br></pre></td></tr></table></figure>
<p>（3）停掉主服务器后会自动切换到从服务器的nginx<br>继续访问192.168.8.50还是能访问到nginx主页<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-23.png" alt="image.png"></p>
<p><strong>配置文件详解</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局定义</span><br><span class="line">global_defs &#123;   </span><br><span class="line">  notification_email &#123;</span><br><span class="line">    acassen@firewall.loc</span><br><span class="line">    failover@firewall.loc</span><br><span class="line">    sysadmin@firewall.loc</span><br><span class="line">  &#125;    </span><br><span class="line">  notification_email_from Alexandre.Cassen@firewall.loc    </span><br><span class="line">  smtp_server 192.168.8.128  </span><br><span class="line">  smtp_connect_timeout 30    </span><br><span class="line">  router_id LVS_DEVEL    #最重要是这个LVS_DEVEL能访问到主机，</span><br><span class="line">                                          #因为在hosts文件中配置了127.0.0.1   LVS_DEVEL</span><br><span class="line">&#125;   </span><br><span class="line">#脚本文件</span><br><span class="line">vrrp_script chk_http_port &#123;      </span><br><span class="line">  script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;      </span><br><span class="line">  interval 2      #（检测脚本执行的间隔）      </span><br><span class="line">  weight -20   #设置当前服务器的权重，当主服务器挂掉权重降低20，也就是自动切换到从服务器</span><br><span class="line">&#125;   </span><br><span class="line">#虚拟ip设置</span><br><span class="line">vrrp_instance VI_1 &#123;     </span><br><span class="line">  state MASTER   # 主服务器为 MASTER 从服务器为 BACKUP       </span><br><span class="line">  interface ens33  #网卡     </span><br><span class="line">  virtual_router_id 51   # 主、备机的 virtual_router_id 必须相同     </span><br><span class="line">  priority 100     # 主、从机取不同的优先级，主机值较大，备份机值较小     </span><br><span class="line">  advert_int 1     #每隔一秒发送心跳，判断主机是否活着</span><br><span class="line">  authentication &#123;      #校验方式   </span><br><span class="line">    auth_type PASS         </span><br><span class="line">    auth_pass 1111     </span><br><span class="line">  &#125;     </span><br><span class="line">  virtual_ipaddress &#123;         </span><br><span class="line">    192.168.17.50 # VRRP H 虚拟地址     可以绑定多个</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#Nginx的基本原理<br><strong>1.master和worker</strong><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-24.png" alt="image.png"></p>
<ul>
<li>可以通过查看进程ps -ef | grep nginx看到如下图所示：<br>matser相当于领导：分配任务<br>worker相当于工人：执行领导分配的任务<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-25.png" alt="image.png"></li>
</ul>
<p><strong>2.worker如何进行工作的</strong><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/03-nginx-26.png" alt="image.png"></p>
<ul>
<li>当master有任务了，由多个worker的争抢机制来得到任务。</li>
</ul>
<p><strong>3.一个master多个worker这种机制的好处</strong><br>（1）可以使用./nginx -s reload 热部署，不用停止nginx更新配置，当worker抢到任务继续执行，执行完才更新配置，其他没有任务的收到./nginx -s reload命令直接更新配置。<br>（2）每个worker都是一个独立的进程，所以不需要加锁，省掉了加锁带来的开销。一个worker挂掉了，其他的worker会正常工作，继续进行争抢，降低了服务中断的风险。</p>
<p><strong>4.设置多少个worker合适？</strong></p>
<p>Nginx和redis类似都采用了io多路复用机制，每个worker都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式处理请求，即使上千万个请求也不在话下，每个worker的线程可以把CPU的性能发挥到极致。所以worker数量和CPU核心数相等时最为适宜的，设置少了浪费CPU，设置多了会造成CPU频繁切换上下文造成损耗。</p>
<ul>
<li>因为windows中没有了io多路复用机制，所以功能虽然能实现，但是性能不能发挥极致，所以一般nginx和redis都是安装到Linux中。</li>
</ul>
<p><strong>5.连接数worker_connection</strong><br>（1）发送一个请求占用worker几个连接数？</p>
<ul>
<li>两个或四个。</li>
<li>因为如果只访问静态资源就两个连接（往返），如果是动态资源worker还需要访问tomcat，又一个往返。</li>
</ul>
<p>（2）nginx中有1个master,4个worker,每个worker支持最大连接数1024，所以问支持的最大并发数是多少？</p>
<ul>
<li>普通的静态访问最大并发数是： worker_connections * worker_processes /2，</li>
<li>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections *  worker_processes/4。</li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>git&amp;github</title>
    <url>/article/76b8d906.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">git --version</span><br><span class="line"><span class="comment"># 配置用户名和邮箱</span></span><br><span class="line">git config --global user.name <span class="string">"你的用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"你的邮箱"</span></span><br><span class="line"><span class="comment"># 查看配置完的信息</span></span><br><span class="line">git config --global --list</span><br><span class="line"><span class="comment"># 添加远程仓库关联,建议使用ssh连接，这样后期不用一直填写用户名密码</span></span><br><span class="line">git remote add origin git@github.com.....</span><br><span class="line"><span class="comment"># 验证是否配置远程成功</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="comment"># 删除远程仓库的关联</span></span><br><span class="line">git remote rm origin</span><br><span class="line"><span class="comment"># 配置公钥，生成之后把公钥填到github中</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"邮箱地址"</span></span><br><span class="line"><span class="comment"># 测试本地仓库是否已经能够与远程仓库建立连接, ----------yes----可以查看成功通过认证</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="comment"># 我在公司用ssh方式不行，可能被公司限制了，但是https可以。</span></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker结合jenkins完成快捷打包部署</title>
    <url>/article/bf74aa2b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><p>我这里选择的是docker方式安装，根据官方建议使用的额镜像是<code>jenkinsci/blueocean</code></p>
<blockquote>
<p>建议使用的Docker映像是<a href="https://hub.docker.com/r/jenkinsci/blueocean/" target="_blank" rel="noopener external nofollow noreferrer"><code>jenkinsci/blueocean</code> image</a>(来自 the <a href="https://hub.docker.com/" target="_blank" rel="noopener external nofollow noreferrer">Docker Hub repository</a>)。 该镜像包含当前的<a href="https://www.jenkins.io/download" target="_blank" rel="noopener external nofollow noreferrer">长期支持 (LTS) 的Jenkins版本</a> （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件。</p>
</blockquote>
<p>拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>运行镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins \</span><br><span class="line">-p 8010:8080 -p 8011:8081 -p 50000:50000 \</span><br><span class="line">-v /home/docker/jenkins/data:/var/jenkins_home \</span><br><span class="line">--privileged=<span class="literal">true</span> --restart=always \</span><br><span class="line">jenkinsci/blueocean:latest</span><br></pre></td></tr></table></figure>

<p>此时<code>docker ps</code>查看容器运行状况发现一直在重启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jenkinsci/blueocean   <span class="string">"/sbin/tini -- /usr/…"</span>   20 minutes ago      Restarting (1) 17 seconds ago</span><br></pre></td></tr></table></figure>

<p>查看日志<code>docker logs jenkins</code> 得到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch: cannot touch <span class="string">'/var/jenkins_home/copy_reference_file.log'</span>: Permission denied</span><br><span class="line">Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?</span><br></pre></td></tr></table></figure>

<p>需要修改下目录权限, 因为当映射本地数据卷时，/home/docker/jenkins/data目录的拥有者为root用户，而容器中jenkins user的uid为1000 执行如下命令即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R 1000:1000 /home/docker/jenkins/data</span><br><span class="line"><span class="comment"># 重启jenkins容器</span></span><br><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure>



<h3 id="启动成功之后的配置"><a href="#启动成功之后的配置" class="headerlink" title="启动成功之后的配置"></a>启动成功之后的配置</h3><ul>
<li>访问192.168.16.128:8010，即你的ip + 你docker启动时候映射的端口</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-01.png" alt="图1"></p>
<ul>
<li><p>docker安装的密码去哪里找呢？</p>
</li>
<li><p>答案是去日志里是最快速的，当然也可以去容器内部<code>docker exec -it 容器id /bin/bash</code> 按照提示地址获取</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">docker logs jenkins</span><br><span class="line"><span class="comment"># 得到的日志中的密码</span></span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line"></span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">8c4bdd47724b4c1b82e726c7bfb62fae</span><br><span class="line"></span><br><span class="line">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br></pre></td></tr></table></figure>

<ul>
<li>安装推荐的插件</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-02.png" alt="图2"></p>
<ul>
<li>如果需要重启则执行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-03.png" alt="图3"></p>
<h3 id="配置java和maven"><a href="#配置java和maven" class="headerlink" title="配置java和maven"></a>配置java和maven</h3><ul>
<li>如下图所示：进入到jenkins容器内部查看，已经安装了jdk1.8，所以我们直接找到jdk1.8的地址配置上就行</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-JENKINS-05.png" alt="图5"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入jenkins容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it jenkins /bin/bash</span><br><span class="line"><span class="comment"># 查看jdk版本</span></span><br><span class="line">java -version</span><br><span class="line"><span class="comment"># 查看jdk地址</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-06.png" alt="图6"></p>
<ul>
<li>jdk配置jenkins内部的，maven自动安装，3.6.3即可，之后保存。</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-07.png" alt="图7"></p>
<ul>
<li>安装这个maven插件</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-08.png" alt="图8"></p>
<ul>
<li>新建一个maven项目</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-09.png" alt="图9"></p>
<ul>
<li>配置git地址</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-10.png" alt="图10"></p>
<ul>
<li>添加构建命令</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-11.png" alt="图11"></p>
<ul>
<li>这块建议跳过测试阶段，如下配置</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-17.png" alt="image-20201001132149508"></p>
<ul>
<li>如下脚本：前四个怎么填写，先构建一次，查看控制台输出，时间可能比较久，可以配置一下maven的设置，在全局设置中如下配置：</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-12.png" alt="image-20201001063900205"></p>
<ul>
<li>注意这里配置的settings.xml就是平时我们配置了阿里镜像源的配置，这里我配置到了容器内的/var/jenkins_home目录中,命令如下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it jenkins /bin/bash</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/jenkins_home</span><br><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">vi settings.xml</span><br><span class="line"><span class="comment"># 把配置好阿里镜像源的settings.xml中的内容复制进去</span></span><br><span class="line"><span class="comment"># :wq保存退出</span></span><br></pre></td></tr></table></figure>



<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-15.png" alt="image-20201001121827492"></p>
<ul>
<li>这块配置如下脚本</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-16.png" alt="image-20201001122308202"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line">SERVER_NAME=jenkins_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源jar名称，mvn打包之后，target目录下的jar包名称</span></span><br><span class="line">JAR_NAME=jenkins_test-0.0.1-SNAPSHOT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源jar路径，打包之后的生成的jar的路径</span></span><br><span class="line">JAR_PATH=/var/jenkins_home/workspace/jenkins_test/target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包完成之后，把jar包移动到运行jar包的目录</span></span><br><span class="line">JAR_WORK_PATH=/var/jenkins_home/workspace/jenkins_test/target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"查询进程id --&gt;<span class="variable">$SERVER_NAME</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取查询结果以空格为界的第一个字段，即PID端口号</span></span><br><span class="line">PID=`ps -ef | grep <span class="string">"<span class="variable">$SERVER_NAME</span>"</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"得到进程id:<span class="variable">$PID</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"结束进程ing..."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span> <span class="variable">$PID</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">kill</span> -9 <span class="variable">$id</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"killed <span class="variable">$id</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待三秒</span></span><br><span class="line"><span class="built_in">echo</span> sleep 3s</span><br><span class="line">sleep 1</span><br><span class="line"><span class="built_in">echo</span> sleep 2s</span><br><span class="line">sleep 1</span><br><span class="line"><span class="built_in">echo</span> sleep 1s</span><br><span class="line">sleep 1</span><br><span class="line">        </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"结束进程完成"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制jar包到执行目录</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"复制jar包到执行目录: cp <span class="variable">$JAR_PATH</span>/<span class="variable">$JAR_NAME</span>.jar <span class="variable">$JAR_WORK_PATH</span>"</span></span><br><span class="line"></span><br><span class="line">cp <span class="variable">$JAR_PATH</span>/<span class="variable">$JAR_NAME</span>.jar <span class="variable">$JAR_WORK_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"复制jar包完成"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$JAR_WORK_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件权限</span></span><br><span class="line">chmod 755 <span class="variable">$JAR_NAME</span>.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">BUILD_ID=dontKillMe nohup java -jar <span class="variable">$JAR_NAME</span>.jar &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后立即构建，即可成功</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/30-jenkins-13.png" alt="image-20201001100206259"></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解MySQL事务的隔离级别</title>
    <url>/article/32904982.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何理解MySQL事务的隔离级别"><a href="#如何理解MySQL事务的隔离级别" class="headerlink" title="如何理解MySQL事务的隔离级别"></a>如何理解MySQL事务的隔离级别</h2><ol>
<li>读未提交（READ UNCOMMITTED）</li>
<li>读已提交（READ COMMITTED）</li>
<li>可重复读（REPEATABLE READ）</li>
<li>可串行化（SERIALIZABLE）</li>
</ol>
<ul>
<li>MySQL的默认事务的隔离级别是<strong><code>可重复读</code></strong></li>
</ul>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 登录mysql的root账户，-p待输入密码，-h mysql服务器地址 -P 端口号（注意大写）</span><br><span class="line">➜ mysql -u root -p -h localhost -P 3307</span><br><span class="line">Enter password: ****</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 284</span><br><span class="line">Server version: 5.7.28 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2019, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br><span class="line">-- 查看当前事务的隔离级别</span><br><span class="line">mysql&gt; show variables like &#39;transaction_isolation&#39;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line"></span><br><span class="line">-- 或者如此查看事务的隔离级别</span><br><span class="line">mysql&gt; SELECT @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line"></span><br><span class="line">-- 可以看到MySQL的默认事务隔离级别是可重复读</span><br></pre></td></tr></table></figure>



<h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>会产生所有的问题（脏读、不可重复读、幻读）</p>
<h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>在此事务隔离级别下，事务B只能在事务A修改并且已提交后才能读取到事务A修改的数据。</p>
<p>避免了脏读</p>
<p>但还是会产生（不可重复读、幻读）</p>
<h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>在此事务隔离级别下，事务B只能在事务A修改数据并提交后，自己也提交事务后，才能读取到事务A修改的数据。</p>
<p>避免了脏读和不可重复读</p>
<p>但还是会产生幻读问题</p>
<h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><p>此种事务隔离级别别最高，不会发生任何以下问题（脏读、可重复读、幻读），通过加锁实现</p>
<p>读锁和写锁，只在读读不阻塞，读写、写读、写写都会阻塞。</p>
<h3 id="解读一下并发造成的问题（脏读、不可重复读、幻读）"><a href="#解读一下并发造成的问题（脏读、不可重复读、幻读）" class="headerlink" title="解读一下并发造成的问题（脏读、不可重复读、幻读）"></a>解读一下并发造成的问题（脏读、不可重复读、幻读）</h3><p>数据库表<code>t_user</code>我的表字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show columns from t_user;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(11)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(50) | NO   |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 可以看到mysql默认开启自动提交模式</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;autocommit&#39;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">-- 可以设置是否自动提交</span><br><span class="line">-- 值为 0 和值为 OFF：关闭事务自动提交。</span><br><span class="line">-- 值为 1 和值为 ON：开启事务自动提交。</span><br><span class="line">-- 如下可设置的4种值</span><br><span class="line">-- SET autocommit &#x3D; 0|1|ON|OFF;</span><br></pre></td></tr></table></figure>



<ul>
<li><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3></li>
</ul>
<p><code>事务A</code> 读取到了 <code>事务B</code> 修改但是未提交的脏数据</p>
<p><strong>开始之前一定调整事务的隔离级别为读未提交，不然不可能产生脏读现象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| READ-UNCOMMITTED        |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure>

<p>首先查看一下<code>t_user</code>表的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 达摩   |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>

<p>然后进行如下测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- session1 事务A 开始</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">-- session2 事务B 开始</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">-- session2 事务B 修改name &#x3D; 吕布  （注意这里并未提交）</span><br><span class="line">mysql&gt; update t_user set name &#x3D; &#39;吕布&#39; where id &#x3D; 1;</span><br><span class="line">-- session1 事务A 读取id &#x3D; 1的数据 （注意，读到了未提交的脏数据 name &#x3D; 吕布）</span><br><span class="line">mysql&gt; select * from t_user where id &#x3D; 1;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 吕布   |</span><br><span class="line">+----+--------+</span><br><span class="line">-- session1 事务A 对读到的脏数据进行提交(事务A结束)</span><br><span class="line">mysql&gt; commit;</span><br><span class="line">-- session2 事务B 对刚才的修改进行回滚（事务B结束）</span><br><span class="line">mysql&gt; rollback;</span><br><span class="line"></span><br><span class="line">-- 最终数据库中的name并没有改变，但是事务A读到了脏数据，这就是脏读</span><br><span class="line">-- 此事务隔离级别（读未提交）也会造成不可重复读和幻读，这里不做演示，看下面的隔离级别中演示</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3></li>
</ul>
<p><code>事务A</code> 读取表的名字为达摩（并未提交），之后<code>事务B</code>修改了名字为曹操（修改完提交了），此时<code>事务A</code>在未提交的情况下又读取了name却变成了曹操，这就是不可重复读</p>
<p><strong>设置事务的隔离级别为读已提交，也可以为读未提交，因为读未提交也会产生不可重复读现象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 设置事务的隔离级别为读已提交</span><br><span class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">-- 查看修改结果，已经为读已提交</span><br><span class="line">mysql&gt; SELECT @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| READ-COMMITTED          |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure>

<p>首先查看一下<code>t_user</code>表的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 达摩   |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>

<p>然后进行如下测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- session1 事务A开始事务</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">-- session1 事务A 读取表中数据（注意此时未提交事务）</span><br><span class="line">mysql&gt; select * from t_user where id &#x3D; 1;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 达摩   |</span><br><span class="line">+----+--------+</span><br><span class="line">-- session2 事务B直接修改并提交事务</span><br><span class="line">mysql&gt; update t_user set name &#x3D; &#39;曹操&#39; where id &#x3D; 1;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line">-- session1 事务A 再次读取表中数据，发现同一个事务中得到了不一样的结果，这就是不可重复读</span><br><span class="line">mysql&gt; select * from t_user where id &#x3D; 1;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 曹操   |</span><br><span class="line">+----+--------+</span><br><span class="line">-- 只要是事务A一直不提交，其他事务修改提交之后，事务A再次查询都能查到最新修改的结果</span><br><span class="line">-- 此事务隔离级别也会造成幻读，但是避免了脏读</span><br><span class="line">-- 测试是否避免脏读，事务A此时未提交</span><br><span class="line">-- session2 事务B开始</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">-- session2 事务B修改name &#x3D; 伽罗 （注意此时未提交）</span><br><span class="line">mysql&gt; update t_user set name &#x3D; &#39;伽罗&#39; where id &#x3D; 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">-- session1 事务A进行读取，看到并没有读取到脏数据</span><br><span class="line">mysql&gt; select * from t_user where id &#x3D; 1;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 曹操   |</span><br><span class="line">+----+--------+</span><br><span class="line">-- session2 事务B回滚</span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">-- session1 事务A提交</span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>知识点：为什么加了写锁，别的事务还可以进行读操作？</p>
</li>
<li><p>因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。</p>
</li>
</ul>
<ul>
<li><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3></li>
</ul>
<p><code>事务A</code>读取表中数据为一条(这时候未提交)， <code>事务B</code>向表中添加了一条记录（提交），此时<code>事务A</code>再次查询表中数据，结果是两条，好像产生了幻觉，这就是幻读</p>
<p><strong>设置事务的隔离级别为可重复读，也可以为读未提交，也可以为读已提交，因为这三种事务隔离级别都会产生幻读现象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 设置事务的隔离级别为可重复读</span><br><span class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">-- 查看修改结果，已经为可重复读</span><br><span class="line">mysql&gt; SELECT @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure>

<p>首先查看一下<code>t_user</code>表的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 曹操   |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>

<p>之后进行的测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- session1 事务A开启</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">-- session1 事务A查询（注意未提交）</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | name   |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 曹操   |</span><br><span class="line">+----+--------+</span><br><span class="line">-- session2 事务B添加数据（提交）</span><br><span class="line">mysql&gt; insert into t_user(name) values(&#39;马可波罗&#39;);</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">-- session1 事务A再次查询（一个事务中两次查询多出了数据，幻读）</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | name         |</span><br><span class="line">+----+--------------+</span><br><span class="line">|  1 | 曹操         |</span><br><span class="line">|  2 | 马可波罗      |</span><br><span class="line">+----+--------------+</span><br><span class="line">-- 测试此事务隔离级别能避免不可重复读现象（此时事务A还是未提交）</span><br><span class="line">-- session2 事务B修改id&#x3D; 1的数据名字为狄仁杰（提交）</span><br><span class="line">mysql&gt; update t_user set  name &#x3D; &#39;狄仁杰&#39; where id &#x3D; 1;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">-- 此时session1 事务A再次读取数据（可以看到跟上一次一样，证明避免了不可重复读现象）</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | name         |</span><br><span class="line">+----+--------------+</span><br><span class="line">|  1 | 曹操         |</span><br><span class="line">|  2 | 马可波罗      |</span><br><span class="line">+----+--------------+</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/27-tran-01.png" alt="image-20200927155439699"></p>
<p>以上讲的都是并发操作可能造成的<strong>读的问题</strong></p>
<p>关于乐观锁和悲观锁解决并发写操作可能造成的丢失更新的问题请访问我的<a href="https://mp.weixin.qq.com/s/cBtS_N0TO33r47H5WpfisQ" target="_blank" rel="noopener external nofollow noreferrer">这篇文章</a></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Swagger2自动生成API接口文档</title>
    <url>/article/e985a034.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#一、为什么使用Swagger2<br>当下很多公司都采取前后端分离的开发模式，前端和后端的工作由不同的工程师完成。在这种开发模式下，维持一份及时更新且完整的 Rest API 文档将会极大的提高我们的工作效率。传统意义上的文档都是后端开发人员手动编写的，相信大家也都知道这种方式很难保证文档的及时性，这种文档久而久之也就会失去其参考意义，反而还会加大我们的沟通成本。而 Swagger 给我们提供了一个全新的维护 API 文档的方式，下面我们就来了解一下它的优点：</p>
<a id="more"></a>

<p>1、代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。</p>
<p>2、跨语言性，支持 40 多种语言。</p>
<p>3、Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</p>
<p>4、还可以将文档规范导入相关的工具（例如 Postman、SoapUI）, 这些工具将会为我们自动地创建自动化测试。</p>
<p>#二、配置使用Swagger2</p>
<p>##1、在pom.xml加入swagger2相关依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--swagger2的依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>


<p>##2、新建Swagger2Config配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line">import springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line">import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line">import springfox.documentation.service.*;</span><br><span class="line">import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spi.service.contexts.SecurityContext;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author yunqing</span><br><span class="line"> * @date 2019&#x2F;12&#x2F;17 10:23</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                &#x2F;&#x2F;为当前包下controller生成API文档</span><br><span class="line">&#x2F;&#x2F;                .apis(RequestHandlerSelectors.basePackage(&quot;com.troila&quot;))</span><br><span class="line">                &#x2F;&#x2F;为有@Api注解的Controller生成API文档</span><br><span class="line">&#x2F;&#x2F;                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br><span class="line">                &#x2F;&#x2F;为有@ApiOperation注解的方法生成API文档</span><br><span class="line">&#x2F;&#x2F;                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                &#x2F;&#x2F;为任何接口生成API文档</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">                &#x2F;&#x2F;添加登录认证</span><br><span class="line">                &#x2F;*.securitySchemes(securitySchemes())</span><br><span class="line">                .securityContexts(securityContexts());*&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        Contact contact &#x3D; new Contact(&quot;yunqing&quot;, &quot;&quot;, &quot;yunqing****@gmail.com&quot;);</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;SwaggerUI演示&quot;)</span><br><span class="line">                .description(&quot;接口文档，描述词省略200字&quot;)</span><br><span class="line">                .contact(contact)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置swagger2的静态资源路径</span><br><span class="line">     * @param registry</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F; 解决静态资源无法访问</span><br><span class="line">        registry.addResourceHandler(&quot;&#x2F;**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:&#x2F;static&#x2F;&quot;);</span><br><span class="line">        &#x2F;&#x2F; 解决swagger无法访问</span><br><span class="line">        registry.addResourceHandler(&quot;&#x2F;swagger-ui.html&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;);</span><br><span class="line">        &#x2F;&#x2F; 解决swagger的js文件无法访问</span><br><span class="line">        registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 给API文档接口添加安全认证</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;*private List&lt;ApiKey&gt; securitySchemes() &#123;</span><br><span class="line">        List&lt;ApiKey&gt; apiKeys &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        apiKeys.add(new ApiKey(&quot;Authorization&quot;, &quot;Authorization&quot;, &quot;header&quot;));</span><br><span class="line">        return apiKeys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityContext&gt; securityContexts() &#123;</span><br><span class="line">        List&lt;SecurityContext&gt; securityContexts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        securityContexts.add(SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.regex(&quot;^(?!auth).*$&quot;)).build());</span><br><span class="line">        return securityContexts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityReference&gt; defaultAuth() &#123;</span><br><span class="line">        AuthorizationScope authorizationScope &#x3D; new AuthorizationScope(&quot;global&quot;, &quot;accessEverything&quot;);</span><br><span class="line">        AuthorizationScope[] authorizationScopes &#x3D; new AuthorizationScope[1];</span><br><span class="line">        authorizationScopes[0] &#x3D; authorizationScope;</span><br><span class="line">        List&lt;SecurityReference&gt; securityReferences &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        securityReferences.add(new SecurityReference(&quot;Authorization&quot;, authorizationScopes));</span><br><span class="line">        return securityReferences;</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##3、在shiro配置类中放行swagger2相关资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;swagger2免拦截</span><br><span class="line">filterChainDefinitionMap.put(&quot;&#x2F;swagger-ui.html**&quot;, &quot;anon&quot;);</span><br><span class="line">filterChainDefinitionMap.put(&quot;&#x2F;v2&#x2F;api-docs&quot;, &quot;anon&quot;);</span><br><span class="line">filterChainDefinitionMap.put(&quot;&#x2F;swagger-resources&#x2F;**&quot;, &quot;anon&quot;);</span><br><span class="line">filterChainDefinitionMap.put(&quot;&#x2F;webjars&#x2F;**&quot;, &quot;anon&quot;);</span><br></pre></td></tr></table></figure>


<p>##4、配置为哪部分接口生成API文档</p>
<blockquote>
<p>主要是在Swagger2Config配置类中进行createRestApi()方法中进行配置，下面提供四种配置：</p>
</blockquote>
<p>①为任何接口生成API文档，这种方式不必在接口方法上加任何注解，方便的同时也会因为没有添加任何注解所以生成的API文档也没有注释，可读性不高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public Docket createRestApi()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                &#x2F;&#x2F;为任何接口生成API文档</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>②为当前配置的包下controller生成API文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.troila&quot;))</span><br></pre></td></tr></table></figure>
<p>③为有@Api注解的Controller生成API文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br></pre></td></tr></table></figure>
<p>④为有@ApiOperation注解的方法生成API文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br></pre></td></tr></table></figure>
<p>#三、Swagger2注解详解<br>##1、@Api ：请求类的说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api：放在请求的类上，与 @Controller 并列，说明类的作用，如用户模块，订单类等。</span><br><span class="line">	tags&#x3D;&quot;说明该类的作用&quot;</span><br><span class="line">	value&#x3D;&quot;该参数没什么意义，所以不需要配置&quot;</span><br></pre></td></tr></table></figure>
<p>###举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api(tags &#x3D; &quot;账户相关模块&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;api&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line">	&#x2F;&#x2F;TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##2、@ApiOperation：方法的说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation：&quot;用在请求的方法上，说明方法的作用&quot;</span><br><span class="line">	value&#x3D;&quot;说明方法的作用&quot;</span><br><span class="line">	notes&#x3D;&quot;方法的备注说明&quot;</span><br></pre></td></tr></table></figure>
<p>###举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation(value &#x3D; &quot;修改密码&quot;, notes &#x3D; &quot;方法的备注说明，如果有可以写在这里&quot;)</span><br><span class="line">@PostMapping(&quot;&#x2F;changepass&quot;)</span><br><span class="line">public AjaxResult changePassword(@AutosetParam SessionInfo sessionInfo,</span><br><span class="line">        @RequestBody @Valid PasswordModel passwordModel) &#123;</span><br><span class="line">	&#x2F;&#x2F;TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##3、@ApiImplicitParams、@ApiImplicitParam：方法参数的说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiImplicitParams：用在请求的方法上，包含一组参数说明</span><br><span class="line">	@ApiImplicitParam：对单个参数的说明	    </span><br><span class="line">	    name：参数名</span><br><span class="line">	    value：参数的汉字说明、解释</span><br><span class="line">	    required：参数是否必须传</span><br><span class="line">	    paramType：参数放在哪个地方</span><br><span class="line">	        · header --&gt; 请求参数的获取：@RequestHeader</span><br><span class="line">	        · query --&gt; 请求参数的获取：@RequestParam</span><br><span class="line">	        · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable</span><br><span class="line">	        · body（请求体）--&gt;  @RequestBody User user</span><br><span class="line">	        · form（普通表单提交）	   </span><br><span class="line">	    dataType：参数类型，默认String，其它值dataType&#x3D;&quot;int&quot;	   </span><br><span class="line">	    defaultValue：参数的默认值</span><br></pre></td></tr></table></figure>
<p>###举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation(value&#x3D;&quot;用户登录&quot;,notes&#x3D;&quot;随边说点啥&quot;)</span><br><span class="line">@ApiImplicitParams(&#123;</span><br><span class="line">        @ApiImplicitParam(name&#x3D;&quot;mobile&quot;,value&#x3D;&quot;手机号&quot;,required&#x3D;true,paramType&#x3D;&quot;form&quot;),</span><br><span class="line">        @ApiImplicitParam(name&#x3D;&quot;password&quot;,value&#x3D;&quot;密码&quot;,required&#x3D;true,paramType&#x3D;&quot;form&quot;),</span><br><span class="line">        @ApiImplicitParam(name&#x3D;&quot;age&quot;,value&#x3D;&quot;年龄&quot;,required&#x3D;true,paramType&#x3D;&quot;form&quot;,dataType&#x3D;&quot;Integer&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">@PostMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">public AjaxResult login(@RequestParam String mobile, @RequestParam String password,</span><br><span class="line">                        @RequestParam Integer age)&#123;</span><br><span class="line">    &#x2F;&#x2F;TODO</span><br><span class="line">    return AjaxResult.OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###单个参数举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;根据部门Id删除&quot;)</span><br><span class="line">@ApiImplicitParam(name&#x3D;&quot;depId&quot;,value&#x3D;&quot;部门id&quot;,required&#x3D;true,paramType&#x3D;&quot;query&quot;)</span><br><span class="line">@GetMapping(&quot;&#x2F;delete&quot;)</span><br><span class="line">public AjaxResult delete(String depId) &#123;</span><br><span class="line">	&#x2F;&#x2F;TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-swagger-01.png" alt="image.png"><br>##4、@ApiResponses、@ApiResponse：方法返回值的说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiResponses：方法返回对象的说明</span><br><span class="line">	@ApiResponse：每个参数的说明</span><br><span class="line">	    code：数字，例如400</span><br><span class="line">	    message：信息，例如&quot;请求参数没填好&quot;</span><br><span class="line">	    response：抛出异常的类</span><br></pre></td></tr></table></figure>
<p>###举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation(value &#x3D; &quot;修改密码&quot;, notes &#x3D; &quot;方法的备注说明，如果有可以写在这里&quot;)</span><br><span class="line">@ApiResponses(&#123;</span><br><span class="line">        @ApiResponse(code &#x3D; 400, message &#x3D; &quot;请求参数没填好&quot;),</span><br><span class="line">        @ApiResponse(code &#x3D; 404, message &#x3D; &quot;请求路径找不到&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">@PostMapping(&quot;&#x2F;changepass&quot;)</span><br><span class="line">public AjaxResult changePassword(@AutosetParam SessionInfo sessionInfo,</span><br><span class="line">        @RequestBody @Valid PasswordModel passwordModel) &#123;</span><br><span class="line">	&#x2F;&#x2F;TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##5、@ApiModel：用于JavaBean上面，表示一个JavaBean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiModel：用于JavaBean的类上面，表示此 JavaBean 整体的信息</span><br><span class="line">	（这种一般用在post创建的时候，使用 @RequestBody 这样的场景，请求参数无法使用 @ApiImplicitParam 注解进行描述的时候 ）</span><br></pre></td></tr></table></figure>
<p>##6. @ApiModelProperty：用在JavaBean的属性上面，说明属性的含义<br>###@ApiModel和 @ApiModelProperty举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;修改密码所需参数封装类&quot;)</span><br><span class="line">public class PasswordModel</span><br><span class="line">&#123;</span><br><span class="line">    @ApiModelProperty(&quot;账户Id&quot;)</span><br><span class="line">    private String accountId;</span><br><span class="line">&#x2F;&#x2F;TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>##总结：API文档浏览地址</p>
<blockquote>
<p>配置好Swagger2并适当添加注解后，启动SpringBoot应用，</p>
</blockquote>
<blockquote>
<p>访问<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener external nofollow noreferrer">http://localhost:8080/swagger-ui.html</a> 即可浏览API文档。</p>
</blockquote>
<blockquote>
<p>另外，我们需要为了API文档的可读性，适当的使用以上几种注解就可以。</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-swagger-02.png" alt="image.png"></p>
<p>#四、把Swagger2的API接口导入Postman<br>1、访问<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener external nofollow noreferrer">http://localhost:8080/swagger-ui.html</a> 文档的首页，复制下面这个地址<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-swagger-03.png" alt="image.png"></p>
<p>2.打开postman–&gt;import–&gt;import Form Link</p>
<p> <img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-swagger-04.png" alt="image.png"><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-swagger-05.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>POI导出到Excel文档</title>
    <url>/article/4b6abea5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String fileName &#x3D; ExcelUtil</span><br><span class="line">                .encodeFilename( &quot;questionManage&quot; + CommonUtils.dateFormat(new Date(), &quot;yyyyMMdd&quot;) + &quot;.xlsx&quot;, request);</span><br><span class="line">        response.setContentType(&quot;application&#x2F;octet-stream;charset&#x3D;iso-8859-1&quot;);</span><br><span class="line">        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename&#x3D;&quot; + fileName);</span><br><span class="line">        &#x2F;&#x2F; 客户端不缓存</span><br><span class="line">        response.addHeader(&quot;Pargam&quot;, &quot;no-cache&quot;);</span><br><span class="line">        response.addHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>##1.设置导出的建议文件名</p>
<p>String fileName = ‘导出的Excel文档.xlsx’;</p>
<p>##2.在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。</p>
<blockquote>
<p>//这里设置成二进制流数据（如常见的文件下载）<br>response.setContentType(“application/octet-stream;charset=iso-8859-1”);</p>
</blockquote>
<blockquote>
<p>//Content-Disposition参数是为了在客户端另存文件时提供一个建议的文件名<br>response.setHeader(“Content-Disposition”, “attachment;filename=” + fileName);</p>
</blockquote>
<blockquote>
<p>//为了指示浏览器（客户端）不要缓存页面，通常下面两行合用<br>response.addHeader(“Pargam”, “no-cache”);<br>response.addHeader(“Cache-Control”, “no-cache”);<br>##3.加载类路径下Excel模板文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassPathResource classPathResource &#x3D; new ClassPathResource(&quot;templates&#x2F;myExcel.xlsx&quot;);</span><br></pre></td></tr></table></figure>
<p>##4.定义Excel文档对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取文件输入流</span><br><span class="line">InputStream fis &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;获取Excel文档对象</span><br><span class="line">Workbook wb &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;获取Execl的sheet页</span><br><span class="line">Sheet sheet &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;行</span><br><span class="line">Row row;</span><br><span class="line">&#x2F;&#x2F;列</span><br><span class="line">Cell cell;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取文件输入流</span><br><span class="line">fis &#x3D; classPathResource.getInputStream();</span><br><span class="line">&#x2F;&#x2F;根据输入流创建表格文件</span><br><span class="line">wb &#x3D; WorkbookFactory.create(fis);</span><br><span class="line">&#x2F;&#x2F;获取report的sheet页</span><br><span class="line">sheet &#x3D; wb.getSheet(&quot;report&quot;);</span><br></pre></td></tr></table></figure>
<p>##5.填充数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F; 获取首行，设置标题</span><br><span class="line">titleRow &#x3D; sheet.getRow(0);</span><br><span class="line">&#x2F;&#x2F; 获取第一行第一列的表格</span><br><span class="line">cell &#x3D; titleRow .getCell(0);</span><br><span class="line">&#x2F;&#x2F;给第一行第一列填充信息</span><br><span class="line">cell.setCellValue(cell.getStringCellValue() + projInfo.getProjName());</span><br><span class="line">&#x2F;&#x2F; 获取第二行</span><br><span class="line">row &#x3D; sheet.getRow(1);</span><br><span class="line">&#x2F;&#x2F;第二行第九列的表格</span><br><span class="line">cell &#x3D; row.getCell(8);</span><br><span class="line">&#x2F;&#x2F;第二行第九列的表格填充信息</span><br><span class="line">cell.setCellValue(reportVo.getReporterName());</span><br><span class="line">&#x2F;&#x2F;第二行地十三列表格填充信息</span><br><span class="line">cell &#x3D; row.getCell(12);</span><br><span class="line">cell.setCellValue(startDate + &quot;至&quot; + endDate);</span><br></pre></td></tr></table></figure>
<p>##6.写出文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重设sheet页名字</span><br><span class="line">wb.setSheetName(1, startDate + &quot;至&quot; + endDate);</span><br><span class="line">&#x2F;&#x2F;写出execl文档到response</span><br><span class="line">wb.write(response.getOutputStream());</span><br><span class="line">&#x2F;&#x2F;关闭输出流</span><br><span class="line">response.getOutputStream().flush();</span><br><span class="line">response.getOutputStream().close();</span><br></pre></td></tr></table></figure>
<p>##7.设置边线框和自动换行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置加边框线</span><br><span class="line">CellStyle cellStyle &#x3D; wb.createCellStyle();</span><br><span class="line">cellStyle.setBorderTop(BorderStyle.THIN);</span><br><span class="line">cellStyle.setBorderRight(BorderStyle.THIN);</span><br><span class="line">cellStyle.setBorderBottom(BorderStyle.THIN);</span><br><span class="line">cellStyle.setBorderLeft(BorderStyle.THIN);</span><br><span class="line">&#x2F;&#x2F; 自动换行</span><br><span class="line">cellStyle.setWrapText(true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记得在每一行的每一列设置样式</span><br><span class="line">cell.setCellStyle(cellStyle);</span><br></pre></td></tr></table></figure>
<p>##8.如果模板有想要填充的行和列则获取get</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassPathResource classPathResource &#x3D; new ClassPathResource(&quot;templates&#x2F;exportfile&#x2F;question.xlsx&quot;);</span><br><span class="line">fis &#x3D; classPathResource.getInputStream();</span><br><span class="line">&#x2F;&#x2F;根据输入流创建表格文件</span><br><span class="line">wb &#x3D; WorkbookFactory.create(fis);</span><br><span class="line">&#x2F;&#x2F;获取第一个sheet页</span><br><span class="line">sheet &#x3D; wb.getSheetAt(0);</span><br><span class="line">&#x2F;&#x2F;获取第一行</span><br><span class="line">row &#x3D; sheet.getRow(0);</span><br><span class="line">&#x2F;&#x2F;获取第一列</span><br><span class="line">cell &#x3D; row.getCell(0);</span><br></pre></td></tr></table></figure>
<p>##9.如果模板没有要填充的行和列则创建create</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassPathResource classPathResource &#x3D; new ClassPathResource(&quot;templates&#x2F;exportfile&#x2F;question.xlsx&quot;);</span><br><span class="line">fis &#x3D; classPathResource.getInputStream();</span><br><span class="line">&#x2F;&#x2F;根据输入流创建表格文件</span><br><span class="line">wb &#x3D; WorkbookFactory.create(fis);</span><br><span class="line">&#x2F;&#x2F;获取第一个sheet页</span><br><span class="line">sheet &#x3D; wb.getSheetAt(0);</span><br><span class="line">&#x2F;&#x2F;创建第一行</span><br><span class="line">row &#x3D; sheet.createRow(0);</span><br><span class="line">&#x2F;&#x2F;创建第一列</span><br><span class="line">cell &#x3D; row.createCell(0);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>POI导出</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux能ping通windows，windows不能ping通linux</title>
    <url>/article/98271ffd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="主要是解决Linux能ping通windows，windows不能ping通linux，这种情况下使用ssh-root-ip连接linux报错22端口超时。"><a href="#主要是解决Linux能ping通windows，windows不能ping通linux，这种情况下使用ssh-root-ip连接linux报错22端口超时。" class="headerlink" title="主要是解决Linux能ping通windows，windows不能ping通linux，这种情况下使用ssh root@ip连接linux报错22端口超时。"></a>主要是解决Linux能ping通windows，windows不能ping通linux，这种情况下使用ssh root@ip连接linux报错22端口超时。</h3><ul>
<li>虚拟机设置的网络适配器选择NAT模式<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/22-linux-01.png" alt="image.png"></li>
</ul>
<a id="more"></a>

<ul>
<li>linux查看ip地址ip a s<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/22-linux-02.png" alt="image.png"></li>
<li>设置windows的网络连接找到这个VMnet8(前提是VMware虚拟机)<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/22-linux-03.png" alt="image.png"></li>
<li>设置ip和虚拟机的ip到同一个网段，如我即可<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/22-linux-04.png" alt="image.png"></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 配置国内阿里yum源、docker配置阿里加速镜像</title>
    <url>/article/9b813418.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#yum配置阿里镜像源</p>
<ul>
<li>访问这个阿里镜像站，点击centos<br><a href="https://developer.aliyun.com/mirror" target="_blank" rel="noopener external nofollow noreferrer">https://developer.aliyun.com/mirror</a><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-yum-01.png" alt="image.png"></li>
</ul>
<a id="more"></a>

<ul>
<li>直接按照下图中的3步操作即可<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-yum-02.png" alt="image.png"><h1 id="配置阿里docker镜像加速"><a href="#配置阿里docker镜像加速" class="headerlink" title="配置阿里docker镜像加速"></a>配置阿里docker镜像加速</h1></li>
<li>访问阿里云这个地址<br><a href="https://promotion.aliyun.com/ntms/act/kubernetes.html" target="_blank" rel="noopener external nofollow noreferrer">https://promotion.aliyun.com/ntms/act/kubernetes.html</a></li>
<li>镜像搜索docker<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-yum-03.png" alt="image.png"></li>
<li>直接执行这4条指令即可<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-yum-04.png" alt="image.png"></li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装jdk、Tomcat、maven、nginx、mysql、git、redis</title>
    <url>/article/3e12f736.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>##Linux版本:阿里云镜像仓库的CentOS7<br><a href="https://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1908.iso" target="_blank" rel="noopener external nofollow noreferrer">CentOS-7-x86_64-DVD-1908.iso</a><br>###安装配置jdk<br>首先检查是否安装过jdk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br></pre></td></tr></table></figure>
<p>如果有则删除,XXX为上面命令查到的结果，按个删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove XXX</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>然后去Oracle官网下载jdk,我下载的是1.8的 jdk-8u221-linux-x64.rpm<br>赋予权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 jdk-8u221-linux-x64.rpm</span><br></pre></td></tr></table></figure>
<p>解释：777代表用户、用户组、其他都是7的权限，7代表什么呢？7代表的是读、写、执行三种权限</p>
<ul>
<li><p>读4</p>
</li>
<li><p>写2</p>
</li>
<li><p>执行1<br>加起来正好是7<br>接下来安装jdk的命令是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh jdk-8u221-linux-x64.rpm</span><br></pre></td></tr></table></figure></li>
<li><p>注意：jdk会被默认安装到 <strong>/usr/java</strong> 的路径下</p>
</li>
<li><p>编辑/etc/profile文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>按Insert或者I键，切换成编辑模式。<br>找到内容末尾，输入下面一段话。<br>在unset i的前面输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_221-amd64</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>###（！！！注意：JAVA_HOME的路径是你实际安装的JDK的路径或者tar解压包的路径我这里是/usr/java/jdk1.8.0_221-amd64，千万别写错了）</p>
</li>
<li><p>###然后按Esc       输入:wq保存退出</p>
</li>
</ul>
<p>生效环境变量<br>对于/etc/profile编写完成之后是不够的，还需要最后一个步骤，就是让刚刚我们修改的文件变成有效起来，所以我们再输入一个命令，让修改生效。<br>生效命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>验证安装是否成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p>#安装Tomcat<br>1 安装tomcat之前必须安装配置好jdk，因为Tomcat启动需要jdk支持<br>2 下载Tomcat 我是在官网下载的Tomcat9的tar.gz压缩包上传到linux的<br>3 解压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.24.tar.gz</span><br></pre></td></tr></table></figure>
<p>cd 进入解压后的目录pwd获取当前目录路径得到/root/installFile/apache-tomcat-9.0.24</p>
<p>4 配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p><strong>按i进入编辑模式</strong><br>接着jdk配置后面加上下面这句话，注意=后面是刚才pwd得到的tomcat解压缩得到的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CATALINA_HOME&#x3D;&#x2F;root&#x2F;installFile&#x2F;apache-tomcat-9.0.24</span><br></pre></td></tr></table></figure>
<p>5 按Esc 输入:wq  保存退出<br>6 使配置生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>7 配置UTF-8字符集<br>进入tomcat下的conf文件下编辑server.xml文件<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-linux-01.png" alt="image.png"><br>找到这块加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URIEncoding&#x3D;&quot;UTF-8&quot;</span><br></pre></td></tr></table></figure>
<p>:wq保存退出<br>8 进tomcat的bin目录下执行./start.sh启动tomcat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;start.sh</span><br></pre></td></tr></table></figure>
<p>Tomcat启动成功<br>之后在windows浏览器输入ip:8080就可以得到如下页面了<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-linux-02.png" alt="image.png"></p>
<ul>
<li><strong>注意如果访问不到很大可能是防火墙没开放8080端口</strong><br>###注意：：：centos7的防火墙改成了firewall不再是iptables<br>执行如下操作：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state  &#x2F;&#x2F;看防火墙的状态</span><br><span class="line">systemctl start firewalld.service  &#x2F;&#x2F;如果是关闭状态则启动防火墙，否则跳过此步骤</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent   &#x2F;&#x2F;开启8080端口</span><br><span class="line">systemctl restart firewalld.service &#x2F;&#x2F;重启防火墙</span><br><span class="line">firewall-cmd --reload &#x2F;&#x2F;重新载入防火墙配置</span><br><span class="line">firewall-cmd --list-all &#x2F;&#x2F;查看防火墙开启的端口列表</span><br></pre></td></tr></table></figure>
上面开启8080端口的解释</li>
<li>-zone=public：表示作用域为公共的；</li>
<li>-add-port=8080/tcp：添加tcp协议的端口8080；</li>
<li>-permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；</li>
</ul>
<p>9 关闭tomcat执行./shutdown.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;shutdown.sh</span><br></pre></td></tr></table></figure>

<p>#安装maven<br>1 确保安装了jdk<br>2 到apache maven官网下载maven我这里最新的是3.6.2版本<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-linux-03.png" alt="image.png"><br>3 使用xftp上传到linux<br>4 解压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.6.2-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>5 配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>按i进入编辑模式<br>加入下面一段话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export MAVEN_HOME&#x3D;&#x2F;root&#x2F;installFile&#x2F;apache-maven-3.6.2</span><br></pre></td></tr></table></figure>
<p>然后把maven_home加到path路径后面:$MAVEN_HOME/bin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注意把这句话放到最后面不然配置不成功，可能是因为顺序读取没读到Maven_home的定义呢</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$MAVEN_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>:wq保存退出<br>使配置生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>测试是否配置成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure>
<h3 id="在-bashrc里面加一句source-etc-profile-防止每次重启都要执行source-etc-profile"><a href="#在-bashrc里面加一句source-etc-profile-防止每次重启都要执行source-etc-profile" class="headerlink" title="在~/.bashrc里面加一句source /etc/profile     防止每次重启都要执行source /etc/profile"></a>在~/.bashrc里面加一句source /etc/profile     防止每次重启都要执行source /etc/profile</h3><p>#安装nginx<br>1 安装各种依赖的库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">yum install pcre pcre-devel</span><br><span class="line"></span><br><span class="line">yum install zlib zlib-devel</span><br><span class="line"></span><br><span class="line">yum install openssl openssl-devel</span><br></pre></td></tr></table></figure>
<p>2 下载nginx,我下载的是最新的稳定版<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-linux-04.png" alt="image.png"><br>3 解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>4 进入解压后的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nginx-1.16.1</span><br></pre></td></tr></table></figure>
<p>5 执行三个命令进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>6 安装完毕后找到默认的安装路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>
<p>7 进入上面查出来的安装路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx</span><br></pre></td></tr></table></figure>
<p>8 进入sbin目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd sbin</span><br></pre></td></tr></table></figure>
<p>9 启动nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure>
<p>10 查看nginx进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>
<p><strong>一般来说如果防火墙开启了80端口直接在浏览器输入linux的ip地址就能访问到nginx的页面了。</strong><br>开启防火墙80端口的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent &#x2F;&#x2F;具体意思见上面tomcat那节的解释</span><br><span class="line">systemctl restart firewalld.service &#x2F;&#x2F;重启防火墙</span><br><span class="line">firewall-cmd --reload &#x2F;&#x2F;重新载入防火墙配置</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-linux-05.png" alt="image.png"></p>
<p>#安装mysql<br>1 centos7默认使用的是mariadb为什么看这里<a href="https://blog.csdn.net/H12KJGJ/article/details/79616761" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/H12KJGJ/article/details/79616761</a><br>但是我要讲的是安装mysql，所以首先卸载mariadb<br>2 查看mariadb是否存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mariadb</span><br></pre></td></tr></table></figure>
<p>3 删除mariadb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e mariadb-libs --nodeps</span><br></pre></td></tr></table></figure>
<p>4 解压遇到问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这样解压失败</span><br><span class="line">tar -zxvf mysql-8.0.17-1.el7.x86_64.rpm-bundle.tar</span><br><span class="line">提示：</span><br><span class="line">gzip: stdin: not in gzip format</span><br><span class="line">tar: Child returned status 1</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br></pre></td></tr></table></figure>
<p>然后解决办法就是去掉z如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf mysql-8.0.17-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure>
<p>解压出好几个rpm文件<br>5 执行安装命令，安装这几个rpm文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum localinstall -y  mysql-community-&#123;server,client,common,embedded,libs&#125;-*</span><br></pre></td></tr></table></figure>
<p>6 安装完后再次查询是否有了mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>
<p>可以看到这几个都安装了<br>mysql-community-common-8.0.17-1.el7.x86_64<br>mysql-community-client-8.0.17-1.el7.x86_64<br>mysql-community-server-8.0.17-1.el7.x86_64<br>mysql-community-embedded-compat-8.0.17-1.el7.x86_64<br>mysql-community-libs-8.0.17-1.el7.x86_64<br>mysql-community-libs-compat-8.0.17-1.el7.x86_64</p>
<p>7 下面的命令把/var/lib/mysql的拥有者改为当前用户：root</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R root:root &#x2F;var&#x2F;lib&#x2F;mysql</span><br></pre></td></tr></table></figure>
<p>然后重启mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>
<p><strong>注意：：：</strong>mysql的重启、开始、停止命令分别是<br>systemctl restart mysqld.service<br>systemctl start mysqld.service<br>systemctl stop mysqld.service</p>
<p>8 生成临时密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure>
<p>返回2019-09-20T00:33:37.151972Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: XXX我是临时密码XXX<br>9 登录mysql 执行下面命令然后提示输入上一步的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>10 登录成功第一件事修改密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED BY &quot;888888&quot;;</span><br></pre></td></tr></table></figure>
<p>如果密码过于简单会提示<br>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements<br>但是复杂的密码我是真的记不住啊，所以必须改。<br>我的解决方法是：mysql下执行<br>设置验证密码验证策略为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password.policy&#x3D;0;</span><br></pre></td></tr></table></figure>
<p>设置密码验证长度为4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password.length&#x3D;4;</span><br></pre></td></tr></table></figure>
<p>设置简单密码：1234</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED BY &quot;1234&quot;;</span><br><span class="line">flush privileges; &#x2F;&#x2F;刷新mysql权限</span><br></pre></td></tr></table></figure>
<p>成功！<br>11 远程登录<br>可能是你的账号不允许从远程登录，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后更改‘mysql’数据库里的‘user’表里的‘host’项，从‘localhost’改成‘%’就都可以访问了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set host &#x3D; &#39;%&#39; where user &#x3D; &#39;root&#39;;</span><br><span class="line">flush privileges; &#x2F;&#x2F;刷新mysql权限</span><br></pre></td></tr></table></figure>
<p>12 首先退出mysql，使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit;</span><br></pre></td></tr></table></figure>
<p>开启防火墙的3306端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp --permanent   &#x2F;&#x2F;开启3306端口</span><br><span class="line">systemctl restart firewalld.service &#x2F;&#x2F;重启防火墙</span><br></pre></td></tr></table></figure>

<p>13 设置mysql 开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>14 设置永久表的默认存储引擎和设置字符集<br>找到mysql的配置文件位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name my.cnf</span><br></pre></td></tr></table></figure>
<p>打开配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;my.cnf</span><br></pre></td></tr></table></figure>
<p>按 i 进入编辑模式在最后加入下面两句话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line">character-set-server&#x3D;utf8</span><br></pre></td></tr></table></figure>
<p>按Esc键 输入 :wq 保存退出<br>重启mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>
<p>#安装Git<br>1.安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker</span><br></pre></td></tr></table></figure>
<p>2.删除已有git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove git</span><br></pre></td></tr></table></figure>
<p>3.下载git安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.edge.kernel.org&#x2F;pub&#x2F;software&#x2F;scm&#x2F;git&#x2F;git-2.23.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>4.解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf git-2.23.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>5.进入解压后的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd git-2.23.0</span><br></pre></td></tr></table></figure>
<p>6.配置git的安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git all</span><br></pre></td></tr></table></figure>
<p>7.安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;git install</span><br></pre></td></tr></table></figure>
<p>8.添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin&quot; &gt;&gt; &#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure>
<p>9.使环境变量生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure>
<p>10.查看git版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure>
<p>11.版本回退</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先查看提交的版本</span><br><span class="line">git log</span><br><span class="line">再选择回退的版本</span><br><span class="line">git reset --hard HEAD 版本号</span><br><span class="line">或者这样回退上一个版本，^几个这个回退几个版本</span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<p>#安装redis<br>1.redis官网查看最新版本</p>
<blockquote>
<p><a href="https://redis.io/download" target="_blank" rel="noopener external nofollow noreferrer">https://redis.io/download</a></p>
</blockquote>
<p>2.下载redis</p>
<blockquote>
<p>wget <a href="http://download.redis.io/releases/redis-5.0.5.tar.gz" target="_blank" rel="noopener external nofollow noreferrer">http://download.redis.io/releases/redis-5.0.5.tar.gz</a></p>
</blockquote>
<p>3.解压</p>
<blockquote>
<p>tar xzf redis-5.0.5.tar.gz</p>
</blockquote>
<p>4.解压后，在/usr/local目录下创建redis目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>
<p>5.将redis-5.0.5移动到/usr/local/redis目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv redis-5.0.5 &#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>
<p>6.进入/usr/local/redis目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure>
<p>7.创建两个文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir etc</span><br><span class="line">mkdir bin</span><br></pre></td></tr></table></figure>
<p>8.进入解压后的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis-5.0.5</span><br></pre></td></tr></table></figure>
<p>9.编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>编译完成之后，可以看到解压文件redis-5.0.5 中会有对应的src文件夹</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-linux-06.png" alt="image"></p>
<p>10.编译成功后，进入src文件夹，执行make install进行Redis安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd src</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>11.为了方便管理，将Redis文件中的conf配置文件和常用命令移动到统一文件中<br>回到redis-5.0.5目录，找到redis.conf，将其复制移动到 /usr/local/redis/ect 下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..&#x2F;</span><br><span class="line"></span><br><span class="line">mv redis.conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;</span><br></pre></td></tr></table></figure>
<p>12.进入src目录，移动mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-server到/usr/local/redis/bin/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd src</span><br><span class="line"></span><br><span class="line">mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure>
<p>13.设置后台启动redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc</span><br><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure>
<p>14修改如下几条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize yes #表名需要在后台运行</span><br><span class="line">protected-mode no</span><br><span class="line">bind 0.0.0.0 #开启所有访问，不只是本地</span><br><span class="line">requirepass 123456 #设置密码</span><br></pre></td></tr></table></figure>
<p>其中requirepass不好找直接/requirepass搜索</p>
<p>15.启动redis服务，并指定启动服务配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin</span><br><span class="line">.&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<p>16.最坑的还是阿里云，怎么也连接不上，访问不到阿里云上安装启动好的redis，防火墙端口什么的都弄好了，就是访问不了。原来要在策略组加上6379。。。。。。。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centos7 防火墙添加开放端口：【单个】</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;6379&#x2F;tcp --permanent</span><br><span class="line">【重新载入防火墙配置】</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-linux-07.png" alt="image.png"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-linux-08.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>你了解类的加载机制吗？</title>
    <url>/article/744a60f8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>定义：当程序主动使用某个类时，如果该类还没被加载到内存中，那么系统会通过加载、连接、初始化这三个步骤对该类进行初始化，JVM通常将会连续完成这三个步骤，所以一般情况下这三个步骤统称为类的加载。</p>
<p>实际上类的加载就是将类的class文件读进内存，并为之创建一个java.lang.Class对象。</p>
<h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><p>当类被加载之后，系统会生成一个对应的Class文件，接着进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。之后进入类的初始化阶段，初始化阶段JVM负责对类进行初始化，主要是对类变量进行初始化，两种方式对类变量进行初始化①声明类变量时指定初始化值②是用静态代码块指定初始化值。</p>
<p>类的初始化包含以下几个步骤：</p>
<a id="more"></a>

<p>①如果类还没被加载和连接，先进行加载、连接</p>
<p>②如果类的直接父类还没被初始化则先初始化直接父类，类推到Object类，所以Object类永远是最先被初始化的类</p>
<p>③系统会依次执行初始化语句。（即前边的初始化值有可能在后面被覆盖）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 男人类继承自人类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Man extends Person&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        b &#x3D; 100;</span><br><span class="line">    &#125;</span><br><span class="line">    private static int b &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    private static int c &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    private static int d &#x3D; 4;</span><br><span class="line"></span><br><span class="line">    private static int e;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        d &#x3D; 200;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;a &#x3D; &quot; + Person.a);</span><br><span class="line">        System.out.println(&quot;b &#x3D; &quot; + Man.b);</span><br><span class="line">        System.out.println(&quot;c &#x3D; &quot; + Man.c);</span><br><span class="line">        System.out.println(&quot;d &#x3D; &quot; + Man.d);</span><br><span class="line">        System.out.println(&quot;e &#x3D; &quot; + Man.e);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 人类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Person &#123;</span><br><span class="line"></span><br><span class="line">    static int a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#输出</span><br><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br><span class="line">c &#x3D; 3</span><br><span class="line">d &#x3D; 200</span><br><span class="line">e &#x3D; 0</span><br></pre></td></tr></table></figure>
<h3 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h3><p>当Java程序首次通过下面6个方式使用某个类或接口的时候，会初始化此类或接口。</p>
<p>①创建类的实例。包括new一个实例，反射创建实例，反序列化创建实例。</p>
<p>②调用某个类的静态方法（类方法）</p>
<p>③访问类或者接口的类变量，或者为类变量赋值</p>
<p>④使用反射强制创建某个类或接口的Class对象，例如Class.for(“Person”)若系统还没初始化Person类，这行代码会初始化Person类，并返回Person类对应的Class对象。</p>
<p>⑤初始化某个类的子类，该子类的所有父类都会被初始化。</p>
<p>⑥直接使用java.exe运行某个主类。</p>
<p>注意：当类变量被final修饰的时候，如果类变量的值在编译时候能确定，在使用该类变量的时候不会初始化该类，因为相当于使用了一个常量。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">public class finalTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Dog.b);</span><br><span class="line">        System.out.println(Cat.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat&#123;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;初始化Cat类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编译时候确定了a的值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final static String a &#x3D; &quot;1000&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;初始化Dog类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编译时并没有确定b的值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final static String b &#x3D; LocalDateTime.now().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#输出</span><br><span class="line">初始化Dog类</span><br><span class="line">2019-11-02T11:22:18.823</span><br><span class="line">1000</span><br></pre></td></tr></table></figure>
<p>另一注意点：当使用ClassLoader类的loadClass()来加载某个类时候，并不会初始化该类，使用Class的forName()静态初始化方法才会强制初始化该类。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类的加载由类加载器完成，类加载器通常由JVM提供，JVM提供的类加载器是系统类加载器，其次，开发者可以通过集成ClassLoader类来创建自己的类加载器。</p>
<p>当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构：</p>
<p>①Bootstrap ClassLoader: 根类加载器</p>
<p>②Extension ClassLoader: 扩展类加载器</p>
<p>③System ClassLoader: 系统类加载器</p>
<h3 id="JVM的类加载机制主要有以下三种："><a href="#JVM的类加载机制主要有以下三种：" class="headerlink" title="JVM的类加载机制主要有以下三种："></a>JVM的类加载机制主要有以下三种：</h3><p>①全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也将由该类加载器负责载入。</p>
<p>②父类委托：先由父类加载器试图加载该Class,只有当父类加载器无法加载该类时，才会从自己的类路径中加载该类。</p>
<p>③缓存机制：保证所有的加载过的Class都会被缓存，当程序需要使用某个Class时，类加载器先从缓存区中查找，只有在缓存区不存在该Class对象时，系统才会读取该类对应的二进制文件，转换成Class对象，存入缓存区。</p>
<h3 id="类加载器加载Class大致要经过以下几个步骤："><a href="#类加载器加载Class大致要经过以下几个步骤：" class="headerlink" title="类加载器加载Class大致要经过以下几个步骤："></a>类加载器加载Class大致要经过以下几个步骤：</h3><p>①在缓存区检查该Class是否载入过，如果有则直接第⑧步，否则执行第②步。</p>
<p>②如果父类加载器不存在（如果父类加载器不存在，则parent一定是根加载器，或者本身就是根加载器，因为根加载器不是java实现的，所以返回null）直接跳第④步，如果父类加载器存在，则执行第③步。</p>
<p>③请求使用父类加载器去载入目标类，如果成功载入则跳第⑧步，否则执行第⑤步</p>
<p>④请求使用根类加载器载入目标类，如果成功载入则跳第⑧步，否则跳第⑦步</p>
<p>⑤当前类加载器尝试寻找Class文件（从与此加载器相关的类路径中寻找）如果找到执行第⑥步，找不到执行第⑦步</p>
<p>⑥从文件中载入Class,成功载入跳第⑧步</p>
<p>⑦抛出ClassNotFoundException异常</p>
<p>⑧返回对应的java.lang.Class对象</p>
]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Callable和Future</title>
    <url>/article/a7c279ec.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前的<a href="http://mp.weixin.qq.com/s?__biz=MzAxODkwMTM2Mg==&mid=2247483733&idx=2&sn=9944140574c0e6a65e7214bdcf12bd05&chksm=9bce7148acb9f85ee0e6adf6294113ebc8f83a34ea7bfac41a6563009e87c23b13059cbefad1&scene=21#wechat_redirect" target="_blank" rel="noopener external nofollow noreferrer">这篇文章</a>我讲了Runable来定义线程中执行的任务，但是有个缺点，不能带返回值，今天就讲如何执行带返回值的线程中任务。</p>
<p><strong>Callable</strong></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/23-callable-01.png" alt="image"></p>
<a id="more"></a>

<p>可以看到，一个函数式接口，只有一个call()方法，此方法用于包含线程执行的代码。</p>
<p>同样的Callable创建的可返回值得任务也需要交给executorService线程执行，submit进行提交，注意：只能用submit进行提交，因为带返回值，Runnable其实还可以用executor提交。但是我们并不知道返回的结果何时使用，所以他返回一种特殊的Future类型，Future类型可以在需要使用的时候获取任务的结果。话不多说，开干！！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class CallbackTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; callable &#x3D; () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;callback任务&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            return &quot;200&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;执行任务放进future---&quot;);</span><br><span class="line">        Future&lt;String&gt; future &#x3D; executorService.submit(callable);</span><br><span class="line">        System.out.println(&quot;执行其他任务&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;获取future的结果&quot;);</span><br><span class="line">        String result &#x3D; future.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#输出</span><br><span class="line">执行任务放进future---</span><br><span class="line">执行其他任务</span><br><span class="line">获取future的结果</span><br><span class="line">callback任务</span><br><span class="line">200</span><br></pre></td></tr></table></figure>
<p>由上面的输出结果可以看出，提交任务之后会立即得到future，这时候可以执行其他任务，然后使用future.get()方法来检索未来的结果注意：这里的get()方法会阻塞一直到任务执行结束，我们可以使用isDone()来检查任务是否完成，get()方法时候处于阻塞状态。</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CallbackTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; callable &#x3D; () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;callback任务&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            return &quot;200&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;执行任务放进future---&quot;);</span><br><span class="line">        Future&lt;String&gt; future &#x3D; executorService.submit(callable);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;执行其他任务&quot;);</span><br><span class="line">        </span><br><span class="line">        while (!future.isDone())&#123;</span><br><span class="line">            System.out.println(&quot;阻塞状态&quot;);</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;获取future的结果&quot;);</span><br><span class="line">        String result &#x3D; future.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#输出</span><br><span class="line">执行任务放进future---</span><br><span class="line">执行其他任务</span><br><span class="line">阻塞状态</span><br><span class="line">callback任务</span><br><span class="line">阻塞状态</span><br><span class="line">阻塞状态</span><br><span class="line">阻塞状态</span><br><span class="line">阻塞状态</span><br><span class="line">获取future的结果</span><br><span class="line">200</span><br></pre></td></tr></table></figure>
<p>由这段输出可以看出，提交callable任务之后就立即获取到future，然后就可以执行其他任务，同时可以利用future.isDone()判断当前任务是否执行完毕，如果没执行完毕，get（）方法会阻塞一直到执行完毕在获取结果。</p>
<p>接下来介绍Future.cancel(mayInterruptIfRunning)方法，mayInterruptIfRunning传入一个boolean类型参数，不管mayInterruptIfRunning的值是true还是false，如果任务还没有开始执行，那么就会停止掉。如果任务已经执行了。那么下次任务就不会执行了。</p>
<p>但是如果任务里面有用到while (!Thread.interrupted())，那么本次任务会一直执行，只有mayInterruptIfRunning=true马上中断线程才能停止任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CallbackTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService &#x3D; new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue(10));</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; callable &#x3D; () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;callback任务&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            return &quot;200&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;执行任务放进future---&quot;);</span><br><span class="line">        Future&lt;String&gt; future &#x3D; executorService.submit(callable);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;执行其他任务&quot;);</span><br><span class="line"></span><br><span class="line">        while (!future.isDone())&#123;</span><br><span class="line">            System.out.println(&quot;阻塞状态&quot;);</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">            count++;</span><br><span class="line">            if (count &gt; 2)</span><br><span class="line">                future.cancel(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;获取future的结果&quot;);</span><br><span class="line">        String result &#x3D; future.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#输出</span><br><span class="line">执行任务放进future---</span><br><span class="line">执行其他任务</span><br><span class="line">阻塞状态</span><br><span class="line">callback任务</span><br><span class="line">阻塞状态</span><br><span class="line">阻塞状态</span><br><span class="line">获取future的结果</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.CancellationException</span><br><span class="line">  at java.util.concurrent.FutureTask.report(FutureTask.java:121)</span><br><span class="line">  at java.util.concurrent.FutureTask.get(FutureTask.java:192)</span><br></pre></td></tr></table></figure>
<p>如上面的代码抛出异常，这是因为任务没有执行完毕，就被取消了，所以future.get()会抛出异常，可以如下解决，在获取future.get()的时候做一个判断，判断是否取消了任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;获取future的结果&quot;);</span><br><span class="line">    if(!future.isCancelled()) &#123;</span><br><span class="line">        String result &#x3D; future.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        System.out.println(&quot;任务已取消----&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>添加超时</p>
<p>future.get()方法将阻止并等待任务完成。如果您在可调用任务中从远程服务调用API，并且远程服务已关闭，则future.get()它将永远阻塞，这将使应用程序无响应。</p>
<p>为了避免这种情况，您可以在get()方法中添加超时</p>
<p>future.get(1, TimeUnit.SECONDS);<br>如果任务未在指定时间内完成，则该future.get()方法将抛出TimeoutException。<br><strong>invokeAll</strong></p>
<p>我们可以通过invokeAll()提交多个任务，等待所有任务完成。将一组Callables传递给invokeAll()方法来执行多个任务。在invokeAll()返回的Future列表。future.get()在所有任务都完成之前，对的任何调用将被阻止。如下面的代码，对future.get()语句的首次调用会阻塞，直到所有任务完成。即结果将在6秒钟后打印出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class InvokeAllTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService &#x3D; new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10));</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; task1 &#x3D; () -&gt; &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            return &quot;任务1耗时2秒&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; task2 &#x3D; () -&gt; &#123;</span><br><span class="line">            Thread.sleep(4000);</span><br><span class="line">            return &quot;任务2耗时4秒&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; task3 &#x3D; () -&gt; &#123;</span><br><span class="line">            Thread.sleep(6000);</span><br><span class="line">            return &quot;任务3耗时6秒&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futures &#x3D; executorService.invokeAll(Arrays.asList(task1, task2, task3));</span><br><span class="line"></span><br><span class="line">        for (Future&lt;String&gt; future : futures) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>invokeAny</strong></p>
<p>提交多个任务，等待其中任何一个完成.该invokeAny()方法接受的集合Callables并返回最快的Callable的结果。请注意，它不会返回Future。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class InvokeAnyTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10));</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; task1 &#x3D; () -&gt; &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            return &quot;任务1执行3秒&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        Callable&lt;String&gt; task2 &#x3D; () -&gt; &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            return &quot;任务2执行1秒&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        Callable&lt;String&gt; task3 &#x3D; () -&gt; &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">            return &quot;任务3执行2秒&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        String result &#x3D; executorService.invokeAny(Arrays.asList(task1, task2, task3));</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#输出</span><br><span class="line">任务2执行1秒</span><br></pre></td></tr></table></figure>


<p>可以看到我已经不用Executors创建线程池了，因为阿里巴巴开发手册明确禁止使用Executors创建线程池，那这究竟是为什么呢？请看我的公众号的<a href="https://mp.weixin.qq.com/s?__biz=MzAxODkwMTM2Mg==&mid=2247483755&idx=2&sn=3f6e0e5be619ec33f79392200057f0f9&chksm=9bce7176acb9f860410276413dc88c2789b09bd0defd62ff9167ec5f88f4cf4e6f88d22393dc&token=1258980573&lang=zh_CN#rd" target="_blank" rel="noopener external nofollow noreferrer">这篇文章</a></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security密码认证源码级讲解</title>
    <url>/article/96adc5df.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><blockquote>
<p>本文根据我的项目进行Security密码认证的源码级别讲解，我们将通过localhost:9090访问来开始进行Debug说明，我已经在源码中打了很多个端点，基本能讲到Security用户名密码认证的全部流程，主要是给自己加深印象，其次分享给大家，如果讲解过程中有什么错误，也请大家不吝指正，谢谢！代码基于springboot2.2.1、security5、jdk8、mysql8.0、maven构建。</p>
</blockquote>
<a id="more"></a>

<h1 id="二、debug启动springboot应用"><a href="#二、debug启动springboot应用" class="headerlink" title="二、debug启动springboot应用"></a>二、debug启动springboot应用</h1><h2 id="1、由于我们在MvcConfig配置文件中进行如下配置，所以访问localhost-9090会跳转home-html"><a href="#1、由于我们在MvcConfig配置文件中进行如下配置，所以访问localhost-9090会跳转home-html" class="headerlink" title="1、由于我们在MvcConfig配置文件中进行如下配置，所以访问localhost:9090会跳转home.html"></a>1、由于我们在MvcConfig配置文件中进行如下配置，所以访问localhost:9090会跳转home.html</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author yunqing</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class MvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">		registry.addViewController(&quot;&#x2F;home&quot;).setViewName(&quot;home&quot;);</span><br><span class="line">        &#x2F;&#x2F;注意：这里配置了 &#x2F; 跳转home.html页面</span><br><span class="line">		registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;home&quot;);</span><br><span class="line">		registry.addViewController(&quot;&#x2F;hello&quot;).setViewName(&quot;hello&quot;);</span><br><span class="line">		registry.addViewController(&quot;&#x2F;login&quot;).setViewName(&quot;login&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1、application-yml中配置了端口为9090"><a href="#1-1、application-yml中配置了端口为9090" class="headerlink" title="1.1、application.yml中配置了端口为9090"></a>1.1、application.yml中配置了端口为9090</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9090</span><br></pre></td></tr></table></figure>
<h3 id="1-2、我在WebSecurityConfig中配置了不需要认证就可以访问的页面，其中包含-和-home"><a href="#1-2、我在WebSecurityConfig中配置了不需要认证就可以访问的页面，其中包含-和-home" class="headerlink" title="1.2、我在WebSecurityConfig中配置了不需要认证就可以访问的页面，其中包含 / 和/home"></a>1.2、我在WebSecurityConfig中配置了不需要认证就可以访问的页面，其中包含 / 和/home</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                &#x2F;&#x2F; 所有用户均可访问的资源</span><br><span class="line">                .antMatchers(&quot;&#x2F;css&#x2F;**&quot;, &quot;&#x2F;js&#x2F;**&quot;,&quot;&#x2F;images&#x2F;**&quot;, &quot;&#x2F;webjars&#x2F;**&quot;, &quot;**&#x2F;favicon.ico&quot;, &quot;&#x2F;index&quot;).permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.POST, &quot;&#x2F;user&#x2F;registration&quot;).permitAll()</span><br><span class="line">                .antMatchers(&quot;&#x2F;&quot;, &quot;&#x2F;home&quot;,&quot;&#x2F;user&#x2F;registration&quot;,&quot;&#x2F;hello&quot;).permitAll()</span><br><span class="line">                &#x2F;&#x2F;剩下的任何请求都需要进行认证</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                &#x2F;&#x2F;表单登录</span><br><span class="line">                .formLogin()</span><br><span class="line">                &#x2F;&#x2F;登录请求页面</span><br><span class="line">                .loginPage(&quot;&#x2F;login&quot;)</span><br><span class="line">                &#x2F;&#x2F;自定义登录成功和失败处理器</span><br><span class="line">                .successHandler(ajaxAuthSuccessHandler)</span><br><span class="line">                .failureHandler(ajaxAuthFailHandler)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .permitAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、看完上面的基本介绍，接下来我们进入了第一个断点"><a href="#2、看完上面的基本介绍，接下来我们进入了第一个断点" class="headerlink" title="2、看完上面的基本介绍，接下来我们进入了第一个断点"></a>2、看完上面的基本介绍，接下来我们进入了第一个断点</h2><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-01.png" alt="image.png"></p>
<blockquote>
<p>可以看到进了断点停在了抽象类AbstractAuthenticationToken,并且权限信息传入ROLE_ANONYMOUS参数，匿名角色，按下一步发现进入了如下AnonymousAuthenticationToken类，可以发现是anonymousUser匿名用户封装了一个匿名认证的Token，通过this.setAuthenticated(true0)设置认证通过。</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-02.png" alt="image.png"></p>
<blockquote>
<p>所以得出结论：WebSecurityConfig中我们设置不需认证的资源或者路径，实际上Security使用匿名用户进行认证访问。</p>
</blockquote>
<h3 id="2-1、这里扩展一下spring-security过滤器链"><a href="#2-1、这里扩展一下spring-security过滤器链" class="headerlink" title="2.1、这里扩展一下spring security过滤器链"></a>2.1、这里扩展一下spring security过滤器链</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-03.png" alt="image.png"></p>
<blockquote>
<p>如上图所示：SecurityContextPersistenceFilter过滤器位于过滤器链的最前端，请求先进这个过滤器，当请求进入，检查session中是否有securityContext,如果有则拿出来放到线程中，请求响应回来最后一个也经过此过滤器，检查线程中是否有SecurityContext，如果有则拿出来存到Session中。这样就可以完成认证结果在多个请求之间共享。</p>
</blockquote>
<h3 id="2-2、通过获取共享在多个请求之间的用户信息"><a href="#2-2、通过获取共享在多个请求之间的用户信息" class="headerlink" title="2.2、通过获取共享在多个请求之间的用户信息"></a>2.2、通过获取共享在多个请求之间的用户信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author yunqing</span><br><span class="line"> * @Date 2019&#x2F;12&#x2F;15 16:44</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;api&#x2F;account&quot;)</span><br><span class="line">public class SecurityController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;me&quot;)</span><br><span class="line">    public Object getAuthentication() &#123;</span><br><span class="line">        return SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记得在SecurityConfig中设置/api/account/me不需要认证，即匿名登录。</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-04.png" alt="image.png"></p>
<h3 id="2-3、获取当前认证用户信息"><a href="#2-3、获取当前认证用户信息" class="headerlink" title="2.3、获取当前认证用户信息"></a>2.3、获取当前认证用户信息</h3><blockquote>
<p>直接跳过断点localhost:9090访问到 home.html页</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-05.png" alt="image.png"></p>
<blockquote>
<p>访问localhost:9090/api/account/me获取当前认证用户信息，可以看到当前确实是匿名用户</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#返回结果，证明当前认证成功的是匿名用户</span><br><span class="line"></span><br><span class="line">&#123;&quot;authorities&quot;:[&#123;&quot;authority&quot;:&quot;ROLE_ANONYMOUS&quot;&#125;],&quot;details&quot;:</span><br><span class="line">&#123;&quot;remoteAddress&quot;:&quot;0:0:0:0:0:0:0:1&quot;,&quot;sessionId&quot;:&quot;45C0AA46462B773A0606D24C91D70722&quot;&#125;,</span><br><span class="line">&quot;authenticated&quot;:true,&quot;principal&quot;:&quot;anonymousUser&quot;,&quot;keyHash&quot;:431445726,&quot;credentials&quot;:&quot;&quot;,</span><br><span class="line">&quot;name&quot;:&quot;anonymousUser&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、正式开始讲解数据库中的用户认证"><a href="#3、正式开始讲解数据库中的用户认证" class="headerlink" title="3、正式开始讲解数据库中的用户认证"></a>3、正式开始讲解数据库中的用户认证</h2><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-06.png" alt="image.png"></p>
<h3 id="3-1、点击Sign-In登录跳转到第一个断点UsernamePasswordAuthenticationFilter"><a href="#3-1、点击Sign-In登录跳转到第一个断点UsernamePasswordAuthenticationFilter" class="headerlink" title="3.1、点击Sign In登录跳转到第一个断点UsernamePasswordAuthenticationFilter"></a>3.1、点击Sign In登录跳转到第一个断点UsernamePasswordAuthenticationFilter</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-07.png" alt="image.png"></p>
<blockquote>
<p>断点停到UsernamePasswordAuthenticationFilter，判断当前请求是否是POST请求→获取表单提交的用户密码→根据用户名密码构造一个UsernamePasswordAuthenticationToken→进入我们发现两个构造函数如下图</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-08.png" alt="image.png"></p>
<blockquote>
<p>可以发现走的第一个两个参数的构造函数，因为并没有传入authorities角色信息，通过this.setAuthenticated(false)设置未经过认证→返回未认证的token到UsernamePasswordAuthenticationFilter</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-09.png" alt="image.png"></p>
<blockquote>
<p>通过this.setDetails(request,authRequest);设置ip、sessionId等信息到UsernamePasswordAuthenticationToken中，如下图所示：</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-10.png" alt="image.png"></p>
<blockquote>
<p>返回UsernamePasswordAuthenticationToken到this.getAuthenticationManager().authenticate()进行处理,如下图所示：</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-11.png" alt="image.png"></p>
<blockquote>
<p>之后进入ProviderManager中的断点，介绍一下，ProviderManager实现了AuthenticationManager接口，可以看到如下图，var8是一个Providers集合，循环遍历这个集合，找到适合处理UsernamePassword的Provider进行处理用户名密码认证，可以看到当前是处理匿名用户的AnonymousAuthenticationProvider，继续下一步</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-12.png" alt="image.png"></p>
<blockquote>
<p>循环直到当前Provider是DaoAuthenticationProvider这个是专门处理用户名密码认证的Provider,然后执行到result = provider.authenticate(authentication)；这个断点的时候，会进入到AbstractUserDetailsAuthenticationProvider 抽象类，它实现了 AuthenticationProvider接口，而DaoAuthenticationProvider又继承了这个抽象类。</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-13.png" alt="image.png"></p>
<blockquote>
<p>接下来重点讲解DaoAuthenticationProvider和AbstractUserDetailsAuthenticationProvider 这两个类，主要的认证方法写在了这个抽象类中，如下图断点中this.retrieveUser()方法获取到了一个UserDetails实例，这个this.retrieveUser()方法也是一个抽象方法，他的实现写在了DaoAuthenticationProvider中。</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-14.png" alt="image.png"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-15.png" alt="image.png"></p>
<blockquote>
<p>接下来看this.retrieveUser()方法的实现，终于在实现中看到了调用loadUserByUsername()方法。<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-17.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p>可以看到确实进入了我们自定义的MyUserDetailsService类，这个类就不多解释了，从数据库里取数据验证而已</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-16.png" alt="image.png"></p>
<blockquote>
<p>回到AbstractUserDetailsAuthenticationProvider可以看到三个检查，三个检查的实现就在本类中，可以进行查看</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-18.png" alt="image.png"></p>
<blockquote>
<p>preAuthenticationCheck检查</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-19.png" alt="image.png"></p>
<blockquote>
<p>this.additionalAuthenticationChecks密码检查，实现类在DaoAuthenticationProvider中</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-20.png" alt="image.png"></p>
<blockquote>
<p>this.postAuthenticationChecks()还是对UserDetails接口中剩下的一个布尔值进行检查</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-21.png" alt="image.png"></p>
<blockquote>
<p>所有检查通过之后，认为认证成功，拿着认证成功的这些信息进入this.createSuccessAuthentication()</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-22.png" alt="image.png"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-23.png" alt="image.png"></p>
<blockquote>
<p>可以看到走的确实是三个参数的构造函数，如下图，通过super.setAuthenticated(true)设置认证状态为成功</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-24.png" alt="image.png"></p>
<blockquote>
<p>然后DaoAuthenticationProvider返回一个认证成功的Authentication，经过认证的Authentication会沿着认证的流程返回去，一直返回到UsernamepasswordAuthenticationFilter.</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-25.png" alt="image.png"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-26.png" alt="image.png"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-27.png" alt="image.png"></p>
<blockquote>
<p>接下来就调用认证成功处理器进行处理，认证信息设置到线程中，用与session共享认证结果</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-28.png" alt="image.png"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-29.png" alt="image.png"></p>
<blockquote>
<p>登陆成功</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/21-security-30.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>spring security</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux vim注释高亮显示</title>
    <url>/article/e05daab5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>首先解决没有vim命令：<br>把yum切换成清华大学的yum源 <a href="https://mirrors.cnnic.cn/help/centos/" target="_blank" rel="noopener external nofollow noreferrer">https://mirrors.cnnic.cn/help/centos/</a><br>然后执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep vim</span><br><span class="line">yum install -y vim*</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>这样就有了vim命令了。<br>这样易于区分注释和不是注释的内容<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/22-vim-01.png" alt="图1"></p>
</li>
<li><p>首先vi命令是不支持高亮显示注释的</p>
</li>
<li><p>其次vim 打开文件的时候显示没有找到命令</p>
</li>
<li><p>rpm -qa | grep vim发现存在vim的rpm包<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/22-vim-02.png" alt="图2"></p>
</li>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install vim-enhanced</span><br></pre></td></tr></table></figure></li>
<li><p>之后进入~目录下新建.vimrc文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure>
<p>编辑如下内容进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hi Comment ctermfg &#x3D;blue</span><br></pre></td></tr></table></figure></li>
<li><p>完毕！再次用vim 命令打开文件就能高亮显示注释了</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 yum 出现could not retrieve mirrorlist解决方案</title>
    <url>/article/22212fda.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Centos7-yum-出现could-not-retrieve-mirrorlist-最终解决方案"><a href="#Centos7-yum-出现could-not-retrieve-mirrorlist-最终解决方案" class="headerlink" title="Centos7 yum 出现could not retrieve mirrorlist 最终解决方案"></a>Centos7 yum 出现could not retrieve mirrorlist 最终解决方案</h3><p>首先遇到这个问题是因为安装centos7之后想看ip,用到命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>返回没有这个命令<br>然后想安装net-tools以得到ifconfig命令执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install net-tools</span><br></pre></td></tr></table></figure>
<p>然后安装不成功报错could not retrieve mirrorlist ….</p>
<a id="more"></a>

<p> 在尝试过很多方法不管用之后，下面是终极解决方案，需要root用户或者不是root用户则sudo执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts  #进入这个目录，找到下面这个文件</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/22-yum-01.png" alt="图1"></p>
<ul>
<li><p>注意这个文件名字可能跟我这个不一样，打开这个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ifcfg-eth0</span><br></pre></td></tr></table></figure>
</li>
<li><p>将ONBOOT改为yes，wq!保存退出</p>
</li>
</ul>
<p>重新启动网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>
<p>解决这个问题之后再返回去执行安装net-tools之后就可以ifconfig了</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7防火墙端口设置</title>
    <url>/article/1be30850.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#centos7 防火墙添加开放端口：【单个】</span></span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br><span class="line"><span class="comment">#centos7 防火墙添加开放端口：【范围】</span></span><br><span class="line">firewall-cmd --zone=public --add-port=20000-30000/tcp --permanent</span><br><span class="line"><span class="comment">#【重新载入防火墙配置】</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment">#【查看】</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="comment">#【删除】</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br><span class="line"><span class="comment">#【重启防火墙】</span></span><br><span class="line">systemctl restart firewalld.service </span><br><span class="line"><span class="comment">#【解释】</span></span><br><span class="line">--zone=public：表示作用域为公共的；</span><br><span class="line">--add-port=8080/tcp：添加tcp协议的端口8080；</span><br><span class="line">--permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Hutool的Money类处理业务中的金钱</title>
    <url>/article/4b82ae0a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>货币类中封装了货币金额和币种。目前金额在内部是long类型表示， 单位是所属币种的最小货币单位（对人民币是分）。</strong></p>
</blockquote>
<blockquote>
<p>目前，货币实现了以下主要功能：</p>
<ul>
<li>支持货币对象与double(float)/long(int)/String/BigDecimal之间相互转换。</li>
<li>货币类在运算中提供与JDK中的BigDecimal类似的运算接口， BigDecimal的运算接口支持任意指定精度的运算功能，能够支持各种 可能的财务规则。</li>
<li>货币类在运算中也提供一组简单运算接口，使用这组运算接口，则在 精度处理上使用缺省的处理规则。</li>
<li>推荐使用Money，不建议直接使用BigDecimal的原因之一在于， 使用BigDecimal，同样金额和币种的货币使用BigDecimal存在多种可能 的表示，例如：new BigDecimal(“10.5”)与new BigDecimal(“10.50”) 不相等，因为scale不等。使得Money类，同样金额和币种的货币只有 一种表示方式，new Money(“10.5”)和new Money(“10.50”)应该是相等的。</li>
<li>不推荐直接使用BigDecimal的另一原因在于， BigDecimal是Immutable， 一旦创建就不可更改，对BigDecimal进行任意运算都会生成一个新的 BigDecimal对象，因此对于大批量统计的性能不够满意。Money类是 mutable的，对大批量统计提供较好的支持。</li>
<li>提供基本的格式化功能。</li>
<li>Money类中不包含与业务相关的统计功能和格式化功能。业务相关的功能 建议使用utility类来实现。</li>
<li>Money类实现了Serializable接口，支持作为远程调用的参数和返回值。</li>
<li>Money类实现了equals和hashCode方法。</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="使用步骤与前提"><a href="#使用步骤与前提" class="headerlink" title="使用步骤与前提"></a>使用步骤与前提</h3><p>1.推荐数据库使用bigint(20)类型存储金额</p>
<p>2.实体类使用Money类型</p>
<p>3.引入Hutool依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.这里主要针对mybatis plus使用进行讲解</p>
<h3 id="分析mybatis-的BaseTypeHandler类"><a href="#分析mybatis-的BaseTypeHandler类" class="headerlink" title="分析mybatis 的BaseTypeHandler类"></a>分析mybatis 的BaseTypeHandler类</h3><p>BaseTypeHandler是类型处理器的基类。</p>
<p>MyBatis 中的 TypeHandler 类型处理器用于 JavaType 与 JdbcType 之间的转换，用于 PreparedStatement 设置参数值和从 ResultSet 或 CallableStatement 中取出一个值。</p>
<p>jdbc中bigint对应java的是long，所以需要做一层long到Money的转换，这时候就需要使用mybatis提供的BaseTypeHandler了。我们需要实现一个MoneyTypeHandler继承自BaseTypeHandler完成这个转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/9/17 21:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoneyTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">Money</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, Money money, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ps.setLong(i, money.getCent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String s)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(rs.getString(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(rs.getString(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Money(cs.getString(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结合mybatis-plus的字段类型处理器"><a href="#结合mybatis-plus的字段类型处理器" class="headerlink" title="结合mybatis plus的字段类型处理器"></a>结合mybatis plus的字段类型处理器</h3><p>类型处理器，用于 JavaType 与 JdbcType 之间的转换，用于 PreparedStatement 设置参数值和从 ResultSet 或 CallableStatement 中取出一个值，主要用于 <code>mybaits-plus</code> 内置常用类型处理器如何通过<code>TableField</code>注解快速注入到 <code>mybatis</code> 容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意我这这里开启了映射注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableName</span>(value = <span class="string">"mmall_product"</span>, autoResultMap = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(value=<span class="string">"Product对象"</span>, description=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Model</span>&lt;<span class="title">Product</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须开启映射注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@TableName</span>(autoResultMap = true)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField</span>(typeHandler = MoneyTypeHandler<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ApiModelProperty</span>(<span class="title">value</span> </span>= <span class="string">"价格,单位-元"</span>)</span><br><span class="line">    <span class="keyword">private</span> Money price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>返回结果金额包括，金额分表示、金额元表示、货币币种（CNY代表人民币）、货币币种的元/分换算比率</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/18-money-01.png" alt="图1"></p>
<h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><p>毕竟跟钱相关，以上代码并未经系统测试，所以慎用，有任何指正欢迎提出。</p>
]]></content>
      <tags>
        <tag>mybatis plus</tag>
        <tag>hutool</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建私有gitlab仓库</title>
    <url>/article/56db5bfb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="docker在centos安装教程："><a href="#docker在centos安装教程：" class="headerlink" title="docker在centos安装教程："></a>docker在centos安装教程：</h2><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener external nofollow noreferrer">官方教程：https://docs.docker.com/install/linux/docker-ce/centos/</a><br>1.查询是否安装过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list installed | grep docker</span><br></pre></td></tr></table></figure>
<p>2.卸载旧版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum -y remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>3.安装所需软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum -y install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
<p>4.设置稳定的存储库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>5.安装最新版本的Docker Engine-Community和containerd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<p>6.启动docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>7.通过运行hello-world 映像来验证是否正确安装了Docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<ul>
<li>此命令下载测试图像并在容器中运行。容器运行时，它会打印参考消息并退出<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-1.png" alt="图1"></li>
</ul>
<p>#下面就开始搭建gitlab仓库<br>1.拉取gitlab镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull gitlab&#x2F;gitlab-ce</span><br></pre></td></tr></table></figure>
<p>2.下载速度太慢，设置国内的阿里镜像加速<br><a href="https://promotion.aliyun.com/ntms/act/kubernetes.html" target="_blank" rel="noopener external nofollow noreferrer">docker阿里镜像地址，具体使用参考下面链接</a></p>
<p>参考地址 <a href="https://blog.csdn.net/Funny_Ma/article/details/96478395" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/Funny_Ma/article/details/96478395</a></p>
<p>3.启动gitlab</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname gitlab.example.com \</span><br><span class="line">  --publish 10443:443 --publish 1080:80 --publish 1022:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume /usr/local/docker/gitlab/config:/etc/gitlab \</span><br><span class="line">  --volume /usr/local/docker/gitlab/logs:/var/log/gitlab \</span><br><span class="line">  --volume /usr/local/docker/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>解释一下上面的一条长命令<blockquote>
<p>–hostname gitlab.example.com \   # 设置主机名或域名<br>–publish 10443:443 –publish 1080:80 –publish 1022:22 \ #本地端口的映射<br>–name gitlab \     # gitlab-ce 的镜像运行成功的容器命名为gitlab<br>–restart always \  # 设置重启方式，always 代表一直开启，即开机自启<br>–volume 分别将 gitlab 的配置文件、日志文件、数据文件目录映射到 /usr/local/docker/gitlab的相应目录中</p>
</blockquote>
</li>
</ul>
<p>4.通过命令查看所有容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-2.png" alt="图2"><br>5.因为我们把gitlab映射到1080端口，所以防火墙开启1080端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启1080端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=1080/tcp --permanent </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙才能生效</span></span><br><span class="line">systemctl restart firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已经开放的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>
<p>5.访问<a href="http://192.168.8.128:1080" target="_blank" rel="noopener external nofollow noreferrer">http://192.168.8.128:1080</a></p>
<ul>
<li>注意改成你服务器的ip</li>
<li>第一次访问让你设置密码，默认账户是root</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-3.png" alt="图3"></p>
<ul>
<li>设置好密码，root账户名登录即可<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-4.png" alt="图4"></li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-5.png" alt="图5"></p>
<ul>
<li>接下来怎么使用，就不是本文要讲的范围了哦</li>
</ul>
<ol start="6">
<li>新建一个项目，clone的时候发现地址<a href="http://gitlab.example.com/root/test.git" target="_blank" rel="noopener external nofollow noreferrer">http://gitlab.example.com/root/test.git</a><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-6.png" alt="图6"></li>
</ol>
<blockquote>
<p>上面设置的时候设置主机名或者域名的时候设置了gitlab.example.com,这时候怎么解决？</p>
</blockquote>
<ul>
<li><p>去上面那条长命令找到配置文件地址，我的是这个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;docker&#x2F;gitlab&#x2F;config</span><br></pre></td></tr></table></figure></li>
<li><p>vim打开进入这个文件<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-7.png" alt="图7"></p>
</li>
<li><p>搜索这行# external_url ‘GENERATED_EXTERNAL_URL’</p>
</li>
<li><p>去掉注释并改成你的ip或域名，保存退出。<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-8.png" alt="图8"></p>
</li>
<li><p>使配置生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec gitlab gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li>
<li><p>重启gitlab</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-9.png" alt="图9"></p>
</li>
<li><p>启动gitlab较慢，遇到502多等一会。</p>
</li>
<li><p>启动成功，看到clone的url已经修改成了ip<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-gitlab-10.png" alt="图10"></p>
</li>
</ul>
<h2 id="windows上用docker搭建gitlab私库"><a href="#windows上用docker搭建gitlab私库" class="headerlink" title="windows上用docker搭建gitlab私库"></a>windows上用docker搭建gitlab私库</h2><ul>
<li>注意更改gitlab的config/logs/data的目录到windows的指定目录<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname localhost -p 10080:80 -p 10443:443 --name gitlab --restart always -v D:\java\docker\gitlab\config:/etc/gitlab -v D:\java\docker\gitlab\logs:/var/log/gitlab -v D:\java\docker\gitlab\data:/var/data/gitlab gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure></li>
<li>上面的命令执行完后可执行下面命令查看gitlab容器的状态<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li>
<li>如果状态一直是health: starting 而不变成healthy,则打开配置文件夹，如上面长命令中设置的配置文件夹为D:\java\docker\gitlab\config，则打开这个文件夹下的gitlab.rb文件。修改其中配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">external_url 'http://你的ipv4地址'</span><br><span class="line">gitlab_rails['gitlab_shell_ssh_port'] = 10022</span><br></pre></td></tr></table></figure>
<ul>
<li>再次执行docker ps -a发现状态变成healthy就可以访问了，没变可以重启gitlab容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>

<ul>
<li>成功启动后访问localhost:10080就可以设置密码了。默认账户名root</li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用gogs搭建git服务</title>
    <url>/article/70f8610.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://gogs.io/" target="_blank" rel="noopener external nofollow noreferrer"><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/16-gogs-01.png" alt="图1"></a></p>
<a id="more"></a>

<ul>
<li>之前写过一篇docker结合gitlab搭建git服务的文章，最近换成了gogs，对比两者说下有什么区别吧。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>gitlab</th>
<th>gogs</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>比较吃机器性能</td>
<td>轻量级，配置低速度也快</td>
</tr>
<tr>
<td>搭建</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>功能</td>
<td>多</td>
<td>相比gitlab少</td>
</tr>
</tbody></table>
<ul>
<li>gogs优点：Gogs（<code>/gɑgz/</code>）项目旨在打造一个以最简便的方式搭建简单、稳定和可扩展的自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 <strong>所有平台</strong>，包括 Linux、macOS、Windows 以及 ARM 平台。开源：<a href="https://github.com/gogs/gogs" target="_blank" rel="noopener external nofollow noreferrer">github地址</a></li>
</ul>
<h3 id="搭建gogs的git服务过程"><a href="#搭建gogs的git服务过程" class="headerlink" title="搭建gogs的git服务过程"></a>搭建gogs的git服务过程</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取gogs镜像</span></span><br><span class="line">docker pull gogs/gogs</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> --name gogs -p 10022:22 -p 10080:3000 \</span></span><br><span class="line"><span class="bash">-v /usr/<span class="built_in">local</span>/docker/gogs/data:/data \</span></span><br><span class="line"><span class="bash">-d gogs/gogs</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动容器之后访问ip:10080我这里是192.168.16.128:10080第一次启动要求配置的页面</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/16-gogs-02.png" alt="图2"></p>
<ul>
<li>关于docker启动mysql可以参考我的文章 <a href="http://yunqing.xyz/article/b0daabb.html" target="_blank" rel="noopener external nofollow noreferrer">Docker安装mysql</a></li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/16-gogs-03.png" alt="图3"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/16-gogs-04.png" alt="图4"></p>
<ul>
<li>完成设置之后，我设置的管理员账户叫做gogs_admin登录后的效果</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/16-gogs-05.png" alt="图5"></p>
<ul>
<li>创建一个新的仓库</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/16-gogs-06.png" alt="图6"></p>
<ul>
<li>最终效果如下：其他功能大家自己研究吧，这里就不做赘述了</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/16-gogs-07.png" alt="图7"></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询性能优化</title>
    <url>/article/42812f47.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-为什么查询速度会慢？"><a href="#1-为什么查询速度会慢？" class="headerlink" title="1.为什么查询速度会慢？"></a>1.为什么查询速度会慢？</h3><p>​        首先对一个查询的生命周期简化分析，大致可以按照顺序分为：从客户端、到服务器、然后在服务器进行解析、生成执行计划、执行、并返回结果给客户端。其中的<code>执行</code>可以被认为是查询的生命周期中最重要的部分，执行主要包括了大量为了检索数据到存储引擎的调用以及调用后数据的排序、分组等处理。</p>
<p>​        在完成生命周期的这些任务的时候，查询需要在不用的地方消耗时间，包括网络、CPU计算、生成执行计划、锁等待等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用操作需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间，根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用小号的时间。所有的这些任务消耗的时间共同构成了响应时间，在每一个消耗大量时间的查询操作中，我们都能看到一些不必要的额外操作，某些操作被额外的重复了很多次，某些操作执行太慢等，优化查询的目的就是减少和消除这些额外操作所花费的时间。</p>
<a id="more"></a>

<h3 id="2-慢查询基础：优化数据访问"><a href="#2-慢查询基础：优化数据访问" class="headerlink" title="2.慢查询基础：优化数据访问"></a>2.慢查询基础：优化数据访问</h3><p>​        查询性能低下的最根本原因就是访问的数据太多。虽然某些查询可能不可避免的需要筛选大量的数据，但这并不常见。大部分性能低下的查询都可以通过减少访问数据量的方式进行优化。可以通过以下两步进行分析：</p>
<p>​        1.确认是否存在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是因为访问了太多的列。</p>
<p>​        2.确认MySQL服务器层是否存在分析大量超过需要的数据行。</p>
<h4 id="2-1是否向数据库请求了不需要的数据？"><a href="#2-1是否向数据库请求了不需要的数据？" class="headerlink" title="2.1是否向数据库请求了不需要的数据？"></a>2.1是否向数据库请求了不需要的数据？</h4><ul>
<li>查询不需要的记录</li>
<li>多表关联时返回全部的列</li>
<li>总是取出全部列</li>
</ul>
<p>针对以上三点我这里试举几个典型案例：</p>
<p>​        1.查询不需要的记录</p>
<p>​        前端分页就是经典例子，查询实际需求显示第一页10条， 却返回100万条数据，性能低下显而易见，建议后端分页 <code>LIMIT 0, 10</code></p>
<p>​        2.多表关联时返回全部的列</p>
<p>​        假如你想查询所在电影<code>大话西游</code>中出现的演员，千万不能按照如下的方式查询，这将返回这三个表全部的列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM actor</span><br><span class="line">	INNER JOIN film_actor USING(actor_id)</span><br><span class="line">	INNER JOIN film USING(film_id)</span><br><span class="line">	WHERE film.title &#x3D; &#39;大话西游&#39;;</span><br></pre></td></tr></table></figure>

<p>​        正确的做法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 规定只查询 actor 表的列</span><br><span class="line">SELECT actor.* from actor ...</span><br></pre></td></tr></table></figure>

<p>​        3.总是取出全部的列</p>
<p>​        每次看到 <code>SELECT *</code> 的时候都要用怀疑的眼光审视，是不是真的需要返回全部的列？很可能是不必须的，取出全部列，会让优化器无法完成索引扫描这类优化，还会为服务器带来额外的 I/O、内存和CPU消耗。</p>
<h4 id="2-2-MySQL是否在扫描额外的记录？"><a href="#2-2-MySQL是否在扫描额外的记录？" class="headerlink" title="2.2 MySQL是否在扫描额外的记录？"></a>2.2 MySQL是否在扫描额外的记录？</h4><p>​        在确定查询只返回需要的数据后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL而言，最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p>​        没有哪个指标能够完美的衡量查询的开销，但是他们大致反映了MySQL内部执行查询时候需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。</p>
<p><strong>下面通过一个例子来查看一下慢日志：</strong></p>
<ul>
<li>存在一个部门表<code>t_dept</code>，包括100万条部门记录，现在查询部门名称为<code>事询部</code>的所有部门</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 没建立索引的情况下，100万条数据中查询大概0.8秒</span><br><span class="line">SELECT t.id, t.department</span><br><span class="line">	FROM t_dept t</span><br><span class="line">	WHERE t.department &#x3D; &#39;事询部&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先我将慢日志记录时间设置为0.5秒，然后指定了慢日志位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将慢日志时间设置为0.5</span><br><span class="line">set long_query_time&#x3D;0.5;</span><br><span class="line"></span><br><span class="line">-- 设置慢日志位置</span><br><span class="line">set global slow_query_log_file&#x3D;&#39;E:\mysql_slow_query.log&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行上面的查询操作，之后查看慢日志</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-1.png" alt="图1"></p>
<ul>
<li><p>从慢日志中可以看到上面说到的主要指标：查询事件、返回行数、扫描行数</p>
</li>
<li><p>问题来了，返回行数899行，却扫描了整个表100万条数据，当然效率低下了，明显用到了全表扫描，EXPLAIN执行计划中的type列说明了访问类型。执行看一下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 执行查询计划</span><br><span class="line">EXPLAIN SELECT t.id, t.department</span><br><span class="line">	FROM t_dept t</span><br><span class="line">	WHERE t.department &#x3D; &#39;事询部&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-2.png" alt="图2"></p>
<p>​        可以看到type访问类型ALL全表扫描，预估访问97万行数据，<code>Using Where</code>代表MySQL将通过<code>WHERE</code>条件来筛选存储引擎返回的记录。</p>
<ul>
<li><p>一般MySQL通过如下三种方式应用WHERE条件，从好到坏依次是：</p>
<p>1.在索引中使用WHERE条件来过滤不匹配的记录，这是在存储引擎层完成的</p>
<p>2.使用索引覆盖扫描（在Extra中出现Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中结果，这是在MySQL服务器层完成的。</p>
<p>3.从表中返回数据，然后过滤不满足条件的记录（在Extra中显示Using Where）再试在MySQL服务器层完成，MySQL需要先从数据表读出数据然后过滤。</p>
</li>
</ul>
<h4 id="2-3-加一个索引试试"><a href="#2-3-加一个索引试试" class="headerlink" title="2.3 加一个索引试试"></a>2.3 加一个索引试试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给部门表的部门名添加一条索引</span><br><span class="line">ALTER TABLE t_dept ADD INDEX index_department(department);</span><br><span class="line">-- 将慢sql记录时间调整成0秒</span><br><span class="line">set long_query_time&#x3D;0</span><br><span class="line">-- 再次执行前面的查询</span><br><span class="line">SELECT t.id, t.department</span><br><span class="line">	FROM t_dept t</span><br><span class="line">	WHERE t.department &#x3D; &#39;事询部&#39;;</span><br><span class="line">-- 查看执行计划</span><br><span class="line">EXPLAIN SELECT t.id, t.department</span><br><span class="line">	FROM t_dept t</span><br><span class="line">	WHERE t.department &#x3D; &#39;事询部&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-3.png" alt="图3"></p>
<ul>
<li>可以看到访问类型已经从全表扫描ALL变成了非唯一性索引扫描ref,预计访问行数由97万行变成了899行，Extra显示了WHERE条件使用了索引覆盖扫描。</li>
<li>下面看一下慢日志，注意要将慢日志记录时限改成0秒，不然记录不下来：</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-4.png" alt="图4"></p>
<ul>
<li>由原来的的0.8秒变成了0.000562秒，正确合适的使用索引优化速度显而易见。</li>
</ul>
<blockquote>
<p>总结：</p>
<p>如果发现查询需要扫描大量的数据行，而只返回其中少量的数据行，这样就可以尝试这样优化：</p>
<p>1.使用索引覆盖扫描，把所有需要用的列放到索引中，这样存储引擎无需会标获取对应的行就可以返回结果</p>
<p>2.改变表结构，例如使用单独的汇总表</p>
<p>3.重写这个复杂查询，让MySQL优化器能够以更优化的方式执行这个查询</p>
</blockquote>
<h3 id="3-重构查询的方式"><a href="#3-重构查询的方式" class="headerlink" title="3.重构查询的方式"></a>3.重构查询的方式</h3><h4 id="3-1-一个复杂查询还是多个简单查询？"><a href="#3-1-一个复杂查询还是多个简单查询？" class="headerlink" title="3.1 一个复杂查询还是多个简单查询？"></a>3.1 一个复杂查询还是多个简单查询？</h4><p>​        在传统的实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。但是MySQL从设计上让连接和断开都很轻量级，现代网络和速度比以前快很多，所以无论是带宽还是延迟，都支持MySQL在必要时可以将一个大的复杂查询转换成多个小的查询。</p>
<p>​        虽然在其他条件都相同的情况下，使用尽可能少的查询当然是更好的，但是有时候，将一个大的查询分解成多个小的查询是很有必要的。</p>
<h4 id="3-2-切分查询"><a href="#3-2-切分查询" class="headerlink" title="3.2 切分查询"></a>3.2 切分查询</h4><p>​        有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，没个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p>
<p>例如：</p>
<p>​        删除旧的数据就是一个很好的例子，定期的清除大量数据的时候，如果一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的重要的查询。因此切分成很多小的查询多次完成，则可以尽可能小的影响MySQL的性能，同时还可以减少MySQL复制的延迟。例如：我们需要每个月运行一次下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 从messages表中删除3个月之前创建的数据</span><br><span class="line">DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>

<p>​        我们可以将这个查询分成每次删除10000条数据，然后暂停一会再做下次删除，这样可以将服务器上原本一次性的压力分散到一个很长的时间段中，可以降低对服务器的影响，减少删除时锁的持有时间。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 分成多次执行</span><br><span class="line">DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000;</span><br></pre></td></tr></table></figure>



<h4 id="3-3分解关联查询"><a href="#3-3分解关联查询" class="headerlink" title="3.3分解关联查询"></a>3.3分解关联查询</h4><p>​        很多高性能应用都会对关联查询进行分解。简单来说，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，例如下面这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	t_user t1</span><br><span class="line">	JOIN t_dept t2 USING ( id )</span><br><span class="line">	JOIN t_address t3 USING ( id ) </span><br><span class="line">WHERE</span><br><span class="line">	t1.fname &#x3D; &#39;6Yn&#39;</span><br><span class="line"></span><br><span class="line">-- 可以分解成下面这些查询来代替：</span><br><span class="line">SELECT * FROM t_user t WHERE t.fname &#x3D; &#39;6YN&#39;;</span><br><span class="line">SELECT * FROM t_dept t WHERE t.id &#x3D; 23456;</span><br><span class="line">SELECT * FROM t_address t WHERE t.id in (12, 234, 23456, 100000);</span><br></pre></td></tr></table></figure>

<p>这么做的优势是什么呢？</p>
<ul>
<li><p>1.让缓存更高效。许多应用程序可以方便的缓存单表查询对应的结果对象。例如，上面的查询中<code>fname</code>已经被缓存了，那么应用程序就可以跳过第一个查询。再例如，应用中已经缓存了ID为12， 34的内容，那么第三个查询的<code>IN()</code>中就可以少几个ID。</p>
</li>
<li><p>2.将查询分解后，执行单个查询可以减少锁的竞争。</p>
</li>
<li><p>3.在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</p>
</li>
<li><p>4.查询本身效率也可能会有所提升。</p>
</li>
<li><p>5.可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复的访问一部分数据。从这点看，这样的重构还可能会减少网络和内存消耗。</p>
</li>
<li><p>6.这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。</p>
</li>
</ul>
<h3 id="4-查询执行的基础"><a href="#4-查询执行的基础" class="headerlink" title="4.查询执行的基础"></a>4.查询执行的基础</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-5.png" alt="图5"></p>
<h4 id="4-1查询缓存"><a href="#4-1查询缓存" class="headerlink" title="4.1查询缓存"></a>4.1查询缓存</h4><ul>
<li>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。</li>
<li>这个检查是通过一个对大小写敏感的哈希查找的。查询和缓存中的查询即使只有一个不同，也不会匹配缓存结果。</li>
<li>如果命中缓存，那么在返回结果前MySQL会检查一次用户权限，有权限则跳过其他步骤直接返回数据。</li>
</ul>
<p>缓存何时失效？</p>
<p>​        在表的结构或数据发生改变时，查询缓存中的数据不再有效。有这些INSERT、UPDATE、 DELETE、TRUNCATE、ALTER TABLE、DROP TABLE或DROP DATABASE会导致缓存数据失效。所以查询缓存适合有大量相同查询的应用，不适合有大量数据更新的应用。</p>
<p>如何清理查询缓存？</p>
<ul>
<li>FLUSH QUERY CACHE;  // 清理查询缓存内存碎片。</li>
<li>RESET QUERY CACHE;  // 从查询缓存中移出所有查询。</li>
<li>FLUSH TABLES;  //关闭所有打开的表，同时该操作将会清空查询缓存中的内容。</li>
</ul>
<h4 id="4-2-查询优化器"><a href="#4-2-查询优化器" class="headerlink" title="4.2 查询优化器"></a>4.2 查询优化器</h4><p>​        MySQL的查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划。下面是一些MySQL能够处理的优化类型：</p>
<ul>
<li>重新定义关联表的顺序</li>
<li>将外连接转化成内连接</li>
<li>使用等价变换规则</li>
<li>优化COUNT()、MIN()和MAX()</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询</li>
<li>等值查询</li>
<li>列表IN()的比较</li>
</ul>
<p>上面列举的并不是MySQL优化器的全部，MySQL还会做大量其他的优化，列举这些主要是让大家明白优化器的复杂性和智能型。如果说从上面这也例子中我们应该学到些什么，那就是不要自认为比优化器更聪明，你可能会占点便宜，但是更有可能会使查询变得更加复杂而难以维护，而最终受益为零。作为开发人员而不是DBA来说，让优化器按照他的方式工作就可以了。</p>
<h4 id="4-3-排序优化"><a href="#4-3-排序优化" class="headerlink" title="4.3 排序优化"></a>4.3 排序优化</h4><p>​        无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序。但是通常情况下，排序是不可避免的，所以就要考虑如何优化排序了。</p>
<p>​        这里给出的建议是通过索引进行排序。</p>
<p>​        当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中，数据量大则需要使用磁盘，不管是内存还是磁盘中进行排序都统称为文件排序（filesort）。MySQL文件排序的时候需要使用临时存储空间可能会比想象的大得多。原因是：在MySQL进行排序的时候，对于每一个排序记录都会分配一个足够长的定长空间来存放，这个定长空间必须足够长以容纳其中最长的字符串，例如，如果是VARCHAR列则需要分配其完整长度；如果使用UTF-8字符集，那么MySQL将会为每个字符预留三个字节。</p>
<h3 id="5-关于MySQL层面优化的一些建议"><a href="#5-关于MySQL层面优化的一些建议" class="headerlink" title="5.关于MySQL层面优化的一些建议"></a>5.关于MySQL层面优化的一些建议</h3><p><strong>总结到 SQL 优化中，就如下三点：</strong></p>
<ul>
<li>最大化利用索引。</li>
<li>尽可能避免全表扫描。</li>
<li>减少无效数据的查询。</li>
</ul>
<p>理解 SQL 优化原理 ，首先要搞清楚 SQL 执行顺序。</p>
<h4 id="5-1-MySQL的执行顺序"><a href="#5-1-MySQL的执行顺序" class="headerlink" title="5.1 MySQL的执行顺序"></a>5.1 MySQL的执行顺序</h4><p>MySQL的语法顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">DISTINCT &lt;select_list&gt;</span><br><span class="line">FROM &lt;left_table&gt;</span><br><span class="line">&lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line">WHERE &lt;where_condition&gt;</span><br><span class="line">GROUP bY &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line">ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">LIMIT &lt;limit_condition&gt;</span><br></pre></td></tr></table></figure>

<p>MySQL的执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM</span><br><span class="line">&lt;表名&gt; #选取表，将多个表数据通过笛卡尔积变成一个表</span><br><span class="line">ON</span><br><span class="line">&lt;筛选条件&gt; #对笛卡尔积的虚表进行筛选</span><br><span class="line">JOIN #指定join类型</span><br><span class="line">&lt;join表&gt; #用于添加数据到on之后的虚表中</span><br><span class="line">WHERE </span><br><span class="line">&lt;where条件&gt; #对上述虚表进行筛选</span><br><span class="line">GROUP BY</span><br><span class="line">&lt;分组条件&gt; #分组</span><br><span class="line">&lt;SUM()等聚合函数&gt; #用于having进行判断，在书写上这类聚合函数是写在having判断里面的</span><br><span class="line">HAVING</span><br><span class="line">&lt;分组筛选&gt; #对分组后的结果进行聚合筛选</span><br><span class="line">SELECT</span><br><span class="line">&lt;返回数据列表&gt; #返回的单列必须在group by子句中，聚合函数除外</span><br><span class="line">DISTINCT</span><br><span class="line">#数据去重</span><br><span class="line">ORDER BY</span><br><span class="line">&lt;排序条件&gt; #排序</span><br><span class="line">LIMIT</span><br><span class="line">&lt;行数限制&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-优化建议"><a href="#5-2-优化建议" class="headerlink" title="5.2 优化建议"></a>5.2 优化建议</h4><p><strong>注意：以下 SQL 优化策略适用于数据量较大的场景下，如果数据量较小一共几百几千条，属实没有必要考虑。</strong></p>
<h4 id="5-2-1-避免不走索引的场景"><a href="#5-2-1-避免不走索引的场景" class="headerlink" title="5.2.1 避免不走索引的场景"></a>5.2.1 避免不走索引的场景</h4><ul>
<li>尽量避免字段开头的模糊查询，会导致数据库引擎放弃索引进行全表扫描</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看执行计划</span><br><span class="line">EXPLAIN SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	t_user </span><br><span class="line">WHERE</span><br><span class="line">	fname LIKE &#39;%a%&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-6.png" alt="图6"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看执行计划</span><br><span class="line">EXPLAIN SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	t_user </span><br><span class="line">WHERE</span><br><span class="line">	fname LIKE &#39;a%&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-7.png" alt="图7"></p>
<p><strong>如果需求是要在前面使用模糊查询：</strong></p>
<p>1.使用 MySQL 内置函数 INSTR（str，substr）来匹配，作用类似于 Java 中的 indexOf()，查询字符串出现的角标位置。</p>
<p>2.使用 FullText 全文索引，用 match against 检索。</p>
<p>3.数据量较大的情况，建议引用 ElasticSearch 亿级数据量检索速度秒级。</p>
<p>4.当表数据量较少（几千条儿那种），别整花里胡哨的，直接用 like ‘%xx%’。</p>
<ul>
<li>使用 or 必须 全部有索引，否则全表扫描，建议使用 union all 代替</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#前提：fname带索引，lname不带索引</span><br><span class="line">-- 因为lname没有索引，会造成全表扫描</span><br><span class="line">select * from t_user where fname &#x3D; &#39;a&#39; or lname &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">-- 由于id和fname都有索引，所以不会全表扫描</span><br><span class="line">select * from t_user where id &#x3D; 1 or fname &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最佳左前缀原则</p>
<p>例如我给<code>t_user</code> 表创建了联合索引 <code>index_fname_lname_age</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 不走索引，全表扫描</span><br><span class="line">select * from t_user where lname &#x3D; &#39;v&#39;;</span><br><span class="line">select * from t_user where age &#x3D; &#39;3&#39;;</span><br><span class="line">select * from t_user where lname &#x3D; &#39;b&#39; and age &#x3D; 3;</span><br><span class="line">-- 走索引</span><br><span class="line">select * from t_user where fname &#x3D; &#39;v&#39;;</span><br><span class="line">select * from t_user where fname &#x3D; &#39;b&#39; and lname &#x3D; &#39;b&#39; and age &#x3D; 3;</span><br><span class="line">-- 仅fname字段走索引</span><br><span class="line">select * from t_user where fname &#x3D; &#39;b&#39; and age &#x3D; 3;</span><br></pre></td></tr></table></figure>

<p>实际上相当于创建了<code>fname索引</code>、<code>fname_lname索引</code> 、<code>fname_lname_age索引</code></p>
<p>总结：联合索引必须保证有最左索引字段，中间字段不能断，直到最后字段，才能全部用上索引。</p>
<ul>
<li><p>索引值不会包含有NULL值的列</p>
<p>​        只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p>
</li>
<li><p>不要在列上进行运算</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将在每个行上进行运算，导致扫描</span><br><span class="line">select * from t_user where YEAR(create_time) &lt; 2020;</span><br><span class="line">-- 可以改写成</span><br><span class="line">select * from t_user where create_time &lt; &#39;2020-01-01&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不使用<code>not in</code>和 <code>&lt;&gt;</code>操作</p>
<p>​        NOT IN 和 &lt;&gt;都将导致不使用索引而全表扫描。NOT IN可以使用NOT EXISTS代替，id&lt;&gt;3可以使用id&gt;3 or id&lt;3代替</p>
</li>
</ul>
<h4 id="5-2-2-UNION和UNION-ALL的区别"><a href="#5-2-2-UNION和UNION-ALL的区别" class="headerlink" title="5.2.2 UNION和UNION ALL的区别"></a>5.2.2 UNION和UNION ALL的区别</h4><ul>
<li>UNION 对两个结果集进行并集操作，会过滤掉重复的行，并且会进行默认规则的排序；</li>
<li>UNION ALL 对两个结果集进行并集操作，不过滤重复的行，也不排序。</li>
</ul>
<p>如果你想取两个结果集的前20条操作，mysql会把两个结果集都放到临时表中，再取前20条，你可以分别取出两个结果集的前20条进行并集操作，然后再LIMIT 20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 注意，这里没有考虑排序问题，主要讲的是减少临时表中的数据</span><br><span class="line">(select fname, lname</span><br><span class="line">from t_user </span><br><span class="line">limit 20)</span><br><span class="line">union all</span><br><span class="line">(select fname, lname</span><br><span class="line">from t_student</span><br><span class="line">limit 20</span><br><span class="line">) limit 20</span><br></pre></td></tr></table></figure>

<p>​        实际上，MySQL总是使用创建并填充临时表的方式来执行UNION查询，因此很多优化策略在UNION中没法很好的使用，经常需要手工的将where、limit、order by等子句下推到UNION的各个子查询中，以便优化器可以充分的利用这些条件进行优化。</p>
<p>​        除非确实需要服务器消除重复的行，否则一定要使用UNION ALL,这一点很重要，如果没有All关键字，MySQL会给临时表加上distinct，这会导致对真个临时表做唯一数据检查，之后进行排序，这样做的代价非常高。即使有ALL关键字，mysql仍会使用临时表存储结果。</p>
<h4 id="5-2-3-COUNT的使用"><a href="#5-2-3-COUNT的使用" class="headerlink" title="5.2.3 COUNT的使用"></a>5.2.3 COUNT的使用</h4><ul>
<li>例如：业务中需要根据一个或者多个条件查询是否存在记录，不关心有多少条记录的时候，有人会这么写：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 这条sql的确定是，不管有多少条满足，会查出所有的行数，</span><br><span class="line">-- 而前提是我们并不关心行数，只关心是否存在</span><br><span class="line">select count(*) from table where a &#x3D; &quot;param1&quot; and b &#x3D; &quot;param2&quot;;</span><br><span class="line"></span><br><span class="line">-- 优化之后的写法</span><br><span class="line">-- sql不使用count而是使用limit 1限制查到一条就返回，不在继续查找了，业务直接判断是否非空即可</span><br><span class="line">select 1 from table where a &#x3D; param1 and b &#x3D; param2 limit 1;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>COUNT(*) / COUNT(1) / COUNT(列名) / COUNT(DISTINCT 列名)</code> 的区别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 返回表中的记录数（包括所有列），相当于统计行数(不会忽略列值为NULL的记录)</span><br><span class="line">count(*) </span><br><span class="line"></span><br><span class="line">-- 忽略所有列，1表示一个固定值，也可以用count(2)、count(3)代替(不会忽略列值为NULL的记录)</span><br><span class="line">count(1) </span><br><span class="line"></span><br><span class="line">-- 返回列名指定列的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内</span><br><span class="line">count(列名)</span><br><span class="line"></span><br><span class="line">-- 只包括列名指定列，返回指定列的不同值的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内。</span><br><span class="line">count(distinct 列名)</span><br></pre></td></tr></table></figure>

<h4 id="count-amp-count-1-amp-count-列名-执行效率比较："><a href="#count-amp-count-1-amp-count-列名-执行效率比较：" class="headerlink" title="count(*)&amp;count(1)&amp;count(列名)执行效率比较："></a>count(*)&amp;count(1)&amp;count(列名)执行效率比较：</h4><ul>
<li>如果列为主键，count(列名)效率优于count(1)</li>
<li>如果列不为主键，count(1)效率优于count(列名)</li>
<li>如果表中存在主键，count(主键列名)效率最优</li>
<li>如果表中只有一列，则count(*)效率最优</li>
<li>如果表有多列，且不存在主键，则count(1)效率优于count(*)</li>
</ul>
<h4 id="5-2-4-Limit的优化使用"><a href="#5-2-4-Limit的优化使用" class="headerlink" title="5.2.4 Limit的优化使用"></a>5.2.4 Limit的优化使用</h4><p>​        在系统中需要进行分页的时候，通常会使用LIMIT加上偏移量的方式实现，同时加上ORDER BY子句。如果有对应的索引，通常效率会不错，否则，MYSQL需要进行大量的文件排序操作。</p>
<p>​        一个非常典型的问题是，在偏移量非常大的情况下，可能需要 limit 2000000,10 需要查询两百万加20条数据然后丢弃两百万，只返回20条，这样做的代价非常高。</p>
<ul>
<li>优化方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如原本的sql是</span><br><span class="line">select * from t_user order by fname limit 2000000, 20;</span><br><span class="line"></span><br><span class="line">-- 使用延迟关联优化</span><br><span class="line">-- 原理是：通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获取需要的行。这可以减少mysql扫描那些需要丢弃的行。</span><br><span class="line">select * from t_user</span><br><span class="line">inner join (</span><br><span class="line">    select id from t_user order by fname limit 2000000, 20</span><br><span class="line">) as t1 USING (id)</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装redis</title>
    <url>/article/e5086296.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="直接用中间大佬给的那条命令即可"><a href="#直接用中间大佬给的那条命令即可" class="headerlink" title="直接用中间大佬给的那条命令即可"></a>直接用中间大佬给的那条命令即可</h3><ul>
<li><p>拉取redis镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></li>
<li><p>从官网获取 <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener external nofollow noreferrer">redis.conf</a> 配置文件,放到挂载目录/usr/local/docker/redis/redis.conf并修改以下前2项。</p>
</li>
<li><p>注意下面3项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1 #注释掉这部分，因为不注释掉的话限制redis只能本地访问</span><br><span class="line">protected-mode no #改成no, 默认yes开启保护模式，限制为只能本地访问，所以改成no</span><br><span class="line">daemonize no #不修改，就用默认no值，如果改为yes意为以守护进程方式启动，可后台运行，除非kill进程（可选），改为yes会使配置文件方式启动redis失败，所以不修改</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>docker启动redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis -v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">*************大佬给的方法，不用配置redis.config************************</span></span><br><span class="line">docker run -d --privileged=true --restart=always -p 6379:6379 -v /usr/local/docker/redis/data:/data --name redis redis:latest redis-server --appendonly yes</span><br></pre></td></tr></table></figure></li>
<li><p>解释：</p>
<blockquote>
<p>-p 6379:6379 映射本地6379端口 ：容器6379端口<br>–name redis 给容器命名redis<br>-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf 挂载目录，冒号前是本地linux目录，冒号后是容器内目录<br>-d redis 表示后台启动redis<br>redis-server /etc/redis/redis.conf  以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/docker/redis/redis.conf<br>–appendonly yes 开启redis 持久化</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>查看容器运行状况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-redis-1.png" alt="图1"></p>
</li>
<li><p>使用 docker exec -it redis /bin/bash进入redis</p>
</li>
<li><p>使用 redis-cli 可以测试连接<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-redis-2.png" alt="图2"></p>
</li>
</ul>
<p>#记录遇到的错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker ps</span></span><br><span class="line">查看容器状态的时候redis的状态一直是restarting一直重启</span><br><span class="line"><span class="comment">#查看redis的日志</span></span><br><span class="line">docker logs redis</span><br><span class="line"><span class="comment">#发现这么一行Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;，理解的意思是aof文件损坏，想了一下原因，昨晚更新windows了...八成这个原因</span></span><br><span class="line"><span class="comment">#解决办法：直接删除容器，删除镜像，重新下载镜像重启</span></span><br><span class="line">docker stop redis</span><br><span class="line">docker rm redis</span><br><span class="line">docker rmi redis:latest</span><br><span class="line">docker pull redis</span><br><span class="line">docker run -d --privileged=<span class="literal">true</span> --restart=always -p 6379:6379 -v d:\docker\redis\data:/data --name redis redis:latest redis-server --appendonly yes</span><br><span class="line"><span class="comment">#注意要删除d:/docker/redis/data目录下的aof文件，估计只删除这个文件重新run容器就行，但是没再尝试</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建容器的时候报错WARNING: IPv4 forwarding is disabled. Networking will not work.</span></span><br><span class="line"><span class="comment">#这个错导致连接不上redis，但是在容器内部docker exec -it redis bash     redis-cli能够使用</span></span><br><span class="line"><span class="comment">#我启动redis容器的命令</span></span><br><span class="line">docker run -d --privileged=<span class="literal">true</span> --restart=always -p 6379:6379 -v /usr/docker/redis/data:/data --name redis redis:latest redis-server --appendonly yes</span><br><span class="line"><span class="comment">#解决办法</span></span><br><span class="line">vim  /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment">#添加下面这行</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"><span class="comment">#重启network</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="comment">#删除错误的重启重新执行启动redis的命令</span></span><br><span class="line">docker stop redis</span><br><span class="line">docker rm redis</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装mysql</title>
    <url>/article/b0daabb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>去dockerhub 查找mysql的镜像版本<a href="https://hub.docker.com/" target="_blank" rel="noopener external nofollow noreferrer">https://hub.docker.com/</a><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-mysql-1.png" alt="图1"><a id="more"></a><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-mysql-1-1.png" alt="图1.1"></p>
</li>
<li><p>拉取镜像mysql5.7.28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7.28</span><br></pre></td></tr></table></figure>
<h1 id="Linux内使用docker安装一样，就是挂载目录的时候把数据文件挂载到Linux内的目录即可。"><a href="#Linux内使用docker安装一样，就是挂载目录的时候把数据文件挂载到Linux内的目录即可。" class="headerlink" title="Linux内使用docker安装一样，就是挂载目录的时候把数据文件挂载到Linux内的目录即可。"></a>Linux内使用docker安装一样，就是挂载目录的时候把数据文件挂载到Linux内的目录即可。</h1></li>
<li><p>因为我是windows下用docker操作的，所以我这里挂载到了windows的D:\java\docker\mysql\data</p>
</li>
<li><p>启动mysql容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#我的windows上的docker映射mysql数据文件到D盘D:\java\docker\mysql\data</span><br><span class="line">docker run -p 3308:3306 --name mysql -v D:\java\docker\mysql\data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d --privileged&#x3D;true --restart&#x3D;always mysql:5.7.28</span><br><span class="line"></span><br><span class="line">#我的Linux上的docker映射mysql数据data文件到&#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql5.7&#x2F;data</span><br><span class="line">docker run -p 3306:3306 --name mysql5.7 -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql5.7&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d --privileged&#x3D;true --restart&#x3D;always mysql:5.7.28</span><br></pre></td></tr></table></figure></li>
<li><p>解释</p>
<blockquote>
<p>-p 3308:3306 端口映射，因为我本地3306/3307都被我占用了，所以我把这个版本mysql映射到本地3308 ：容器内3306端口<br>–name mysql 容器命名mysql<br>-v D:\java\docker\mysql\data:/var/lib/mysql 挂载本地磁盘路径D:\java\docker\mysql\data：对应容器路径/var/lib/mysql<br>-e MYSQL_ROOT_PASSWORD=123456 设置密码123456<br>-d 后台启动，即开机自启<br>–privileged=true  <code>container</code>内的root拥有真正的root权限,有了root权限则不用再去打开相应端口。<strong>加了此参数可以使容器内的操作拥有root权限</strong><br>mysql:5.7.28 针对此镜像启动容器<br>–restart=always 自动重启</p>
</blockquote>
</li>
<li><p>查看容器运行状况<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-mysql-2.png" alt="图2"></p>
</li>
<li><p>连接<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-mysql-3.png" alt="图3"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴开发手册为什么这么规定？</title>
    <url>/article/e7c4a452.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202008/20200812210827.png" alt="12-e7c4a452-0"></p>
<a id="more"></a>

<ul>
<li>首先我尝试写了一下这段代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForeachAddOrRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> s : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"2"</span>.equals(s)) &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用结果：异常ConcurrentModificationException如下：</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202008/12-e7c4a452-1.png" alt="12-e7c4a452-1"></p>
<ul>
<li>如图所示提示ArrayList.java 1043行抛出异常，我用的JDK11，马上点进去看了源码，正是如下这行抛出的异常，原因是modCount != expectedModCount那么这两个变量什么意思呢？继续读源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>modCount是在抽象类AbstractList中被定义，是集合结构修改的次数，例如添加元素、删除元素等结构调整都会使modCount++,下面列举add()和删除的源码，其他结构化修改也会modCount++，这里不做列举。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    found: &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fastRemove(es, i);<span class="comment">//-----------重点重点重点------------------</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//---------------重点重点重点------------------</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//-------重点重点重点----------</span></span><br><span class="line">        add(e, elementData, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>expectedModCount是在ArrayList的内部类Itr中声明的，Itr实现类迭代器接口，这里做了下精简只保留了变量声明和next()方法、remove()方法，可以看到迭代器的实现里声明了expectedModCount = modCount；这里理解成预期结构化调整次数 = 结构化调整次数，为什么每次迭代next()和remove()之前都要检查是否相等呢？可以理解成如果没有这个校验，某个线程删除了list的一个元素，此时next方法不知道size变更了，依然去取数组里的数据，会导致数据为null或ArrayIndexOutOfBoundsException异常等问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//-------------重点重点重点---------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();<span class="comment">//-------------重点重点重点------------------</span></span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();<span class="comment">//-----------重点重点重点---------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;<span class="comment">//------------重点重点重点-------------------</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)<span class="comment">//-----------重点重点重点---------------------</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里串起来就好理解了，由于增强for循环底层反编译之后是迭代器实现的，所以在iterator初始化的时候（也就是for循环开始处），expectedModCount = modCount之后for循环内部进行remove实际上用的是ArrayList的remove()方法，执行了modCount++，而进行for循环底层进行next()迭代的时候进行了checkForComodification()方法判断，modCount++了next()并不知道，所以造成不相等抛出异常。</li>
<li>那为什么使用迭代器可以进行删除而不抛出异常呢？因为看上面的源码，迭代器内部的remove()方法的实现在调用ArrayList.this.remove()进行删除之后，expectedModCount = modCount;及时同步了这两个变量的值。所以使用迭代器删除不会造成问题，写法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForeachAddOrRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    <span class="comment">/*for (var s : list) &#123;</span></span><br><span class="line"><span class="comment">        if ("2".equals(s)) &#123;</span></span><br><span class="line"><span class="comment">            list.remove(s);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">var</span> iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"2"</span>.equals(str)) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建议：如果是JDK8或者以上版本，推荐使用removeIf进行删除，这也是IDEA推荐写法"><a href="#建议：如果是JDK8或者以上版本，推荐使用removeIf进行删除，这也是IDEA推荐写法" class="headerlink" title="建议：如果是JDK8或者以上版本，推荐使用removeIf进行删除，这也是IDEA推荐写法"></a>建议：如果是JDK8或者以上版本，推荐使用removeIf进行删除，这也是IDEA推荐写法</h4><p>写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForeachAddOrRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    <span class="comment">/*for (var s : list) &#123;</span></span><br><span class="line"><span class="comment">            if ("2".equals(s)) &#123;</span></span><br><span class="line"><span class="comment">                list.remove(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*var iterator = list.iterator();</span></span><br><span class="line"><span class="comment">    while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">        var str = iterator.next();</span></span><br><span class="line"><span class="comment">        if ("2".equals(str)) &#123;</span></span><br><span class="line"><span class="comment">            iterator.remove();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    list.removeIf(<span class="string">"2"</span>::equals);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样可以阅读一下removeIf()的源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeIf(filter, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all elements satisfying the given predicate, from index</span></span><br><span class="line"><span class="comment">     * i (inclusive) to index end (exclusive).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter, <span class="keyword">int</span> i, <span class="keyword">final</span> <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//-----------重点重点重点--------------</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="comment">// Optimize for initial run of survivors</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; end &amp;&amp; !filter.test(elementAt(es, i)); i++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// Tolerate predicates that reentrantly access the collection for</span></span><br><span class="line">    <span class="comment">// read (but writers still get CME), so traverse once to find</span></span><br><span class="line">    <span class="comment">// elements to delete, a second pass to physically expunge.</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; end) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> beg = i;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span>[] deathRow = nBits(end - beg);</span><br><span class="line">        deathRow[<span class="number">0</span>] = <span class="number">1L</span>;   <span class="comment">// set bit 0</span></span><br><span class="line">        <span class="keyword">for</span> (i = beg + <span class="number">1</span>; i &lt; end; i++)</span><br><span class="line">            <span class="keyword">if</span> (filter.test(elementAt(es, i)))</span><br><span class="line">                setBit(deathRow, i - beg);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        modCount++;<span class="comment">//-------------重点重点重点------------</span></span><br><span class="line">        <span class="keyword">int</span> w = beg;</span><br><span class="line">        <span class="keyword">for</span> (i = beg; i &lt; end; i++)</span><br><span class="line">            <span class="keyword">if</span> (isClear(deathRow, i - beg))</span><br><span class="line">                es[w++] = es[i];</span><br><span class="line">        shiftTailOverGap(es, w, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基础</title>
    <url>/article/53471b9a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-创建线程的方式"><a href="#1-创建线程的方式" class="headerlink" title="1.创建线程的方式"></a>1.创建线程的方式</h2><p>从多线程的基础上来讲，创建线程可以继承 <code>Thread</code> 因为java是单继承的，所以还可以实现 <code>Runnable</code>来创建多线程，下面分别举例子：</p>
<h3 id="1-1继承Thread"><a href="#1-1继承Thread" class="headerlink" title="1.1继承Thread"></a>1.1继承Thread</h3><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 继承Thread实现多线程，demo1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/6 23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结论：</span></span><br><span class="line"><span class="comment">     * 多线程中，代码的执行结果与代码的执行顺序或者调用顺序无关。</span></span><br><span class="line"><span class="comment">     * 原因线程是一个子任务，CPU会以一种不确定的方式随机调用线程中的run()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1Thread t = <span class="keyword">new</span> Demo1Thread();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行main()方法"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1Thread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.继承Thread类</span></span><br><span class="line"><span class="comment">     * 2.重写run方法</span></span><br><span class="line"><span class="comment">     * 3.实例化</span></span><br><span class="line"><span class="comment">     * 4.调用start()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行run()方法"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2实现Runnable"><a href="#1-2实现Runnable" class="headerlink" title="1.2实现Runnable"></a>1.2实现Runnable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 多线程第二种方法，实现Runnable接口</span></span><br><span class="line"><span class="comment"> * 1.类实现Runnable</span></span><br><span class="line"><span class="comment"> * 2.重写Run()方法</span></span><br><span class="line"><span class="comment"> * 3.实例化创建的类</span></span><br><span class="line"><span class="comment"> * 4.实例化Thread，构造函数传值上面声明的实例</span></span><br><span class="line"><span class="comment"> * 5.调用start()方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/7 20:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo3Runnable d = <span class="keyword">new</span> Demo3Runnable();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(d);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行main()方法"</span> + i);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo3Runnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行run()方法"</span> + i);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用join-控制线程的执行顺序"><a href="#2-使用join-控制线程的执行顺序" class="headerlink" title="2.使用join()控制线程的执行顺序"></a>2.使用<code>join()</code>控制线程的执行顺序</h2><p>线程的执行是随机的，由CPU控制，但是我们可以通过以下的方法对多线程进行可控顺序的执行：</p>
<p>###2.1使用join()方法：让主线程等待子线程的执行完成</p>
<p>工作原理是：在当前线程调用其它线程的join会让当前线程阻塞等待join线程的执行完成，不停检查thread是否存活，如果存活则让当前线程一直wait，直到thread线程终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 使用join()控制线程的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/7 22:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Demo4Thread(<span class="number">1</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Demo4Thread(<span class="number">2</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Demo4Thread(<span class="number">3</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t3.join();</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo4Thread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo4Thread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行run()方法"</span> + i);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2使用CountDownLatch，它与join效果是一样的"><a href="#2-2使用CountDownLatch，它与join效果是一样的" class="headerlink" title="2.2使用CountDownLatch，它与join效果是一样的"></a>2.2使用<code>CountDownLatch</code>，它与join效果是一样的</h3><p>原理：<code>CountDownLatch</code> 定义了一个计数器，和一个阻塞队列， 当计数器的值递减为0之前，阻塞队列里面的线程处于挂起状态，当计数器递减到0时会唤醒阻塞队列所有线程，这里的计数器是一个标志，可以表示一个任务一个线程，也可以表示一个倒计时器，<code>CountDownLatch</code>可以解决那些一个或者多个线程在执行之前必须依赖于某些必要的前提业务先执行的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/9 22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数2</span></span><br><span class="line"><span class="comment">         * 最大线程数10</span></span><br><span class="line"><span class="comment">         * 线程池中超过corePoolSize数目的空闲线程最大存活时间 30秒</span></span><br><span class="line"><span class="comment">         * 阻塞队列----new ArrayBlockingQueue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">30L</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();<span class="comment">//执行减一操作</span></span><br><span class="line">            &#125;;</span><br><span class="line">            executor.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+Thread.currentThread().getName()+<span class="string">"等待子线程执行完成..."</span>);</span><br><span class="line">            latch.await();<span class="comment">//阻塞当前线程，直到计数器的值为0</span></span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+Thread.currentThread().getName()+<span class="string">"开始执行..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-停止线程"><a href="#3-停止线程" class="headerlink" title="3.停止线程"></a>3.停止线程</h3><h3 id="3-1使用自定义标记"><a href="#3-1使用自定义标记" class="headerlink" title="3.1使用自定义标记"></a>3.1使用自定义标记</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StopThread1 t = <span class="keyword">new</span> StopThread1();</span><br><span class="line">        t.start();</span><br><span class="line">        t.stopMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停止线程的两种方法</span></span><br><span class="line"><span class="comment"> * 1.自己设置一个标记位</span></span><br><span class="line"><span class="comment"> * 2.利用interrupt()做停止标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行run()方法"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用此自定义方法停止线程"</span>);</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2使用中断标记interrupt"><a href="#3-2使用中断标记interrupt" class="headerlink" title="3.2使用中断标记interrupt()"></a>3.2使用中断标记interrupt()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StopThread2 stopThread2 = <span class="keyword">new</span> StopThread2();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(stopThread2);</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Someone interrupted me."</span>);</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"中断标志位没被清除"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"this thread is running..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-暂停线程"><a href="#4-暂停线程" class="headerlink" title="4.暂停线程"></a>4.暂停线程</h2><p>###4.1<del>暂停suspend() 恢复resume()</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 暂停线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/8 22:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuspendThreadService test = <span class="keyword">new</span> SuspendThreadService();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test::method);</span><br><span class="line">        t1.setName(<span class="string">"A"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test::method);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暂停线程服务，演示为什么suspend()方法被弃用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuspendThreadService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上同步锁之后，暂停线程就不能释放锁，导致一直处于线程暂停状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程开始"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"A"</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程被暂停"</span>);</span><br><span class="line">            Thread.currentThread().suspend();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Java8 Stream()流处理集合</title>
    <url>/article/67ce2364.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
<a id="more"></a>

<h2 id="下面通过代码了解下"><a href="#下面通过代码了解下" class="headerlink" title="下面通过代码了解下"></a>下面通过代码了解下</h2><h3 id="创建学生类、精英学生类"><a href="#创建学生类、精英学生类" class="headerlink" title="创建学生类、精英学生类"></a>创建学生类、精英学生类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Double score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义精英学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EliteStudent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建两个集合，用于Stream-流处理"><a href="#构建两个集合，用于Stream-流处理" class="headerlink" title="构建两个集合，用于Stream()流处理"></a>构建两个集合，用于Stream()流处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Student&gt;&gt; listFlat;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span><span class="comment">//注解在非静态方法上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"盖伦1"</span>, <span class="number">200</span>, <span class="number">66.0</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"赵信"</span>, <span class="number">21</span>, <span class="number">90.0</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"乐芙兰1"</span>, <span class="number">21</span>, <span class="number">90.0</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">4</span>, <span class="string">"李青"</span>, <span class="number">50</span>, <span class="number">100</span>d),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">"泰达米尔"</span>, <span class="number">600</span>, <span class="number">90</span>d)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        listFlat = Arrays.asList(</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"盖伦1"</span>, <span class="number">200</span>, <span class="number">66.0</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"赵信"</span>, <span class="number">21</span>, <span class="number">90.0</span>)</span><br><span class="line">                ),</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"乐芙兰1"</span>, <span class="number">21</span>, <span class="number">90.0</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">4</span>, <span class="string">"李青"</span>, <span class="number">50</span>, <span class="number">100</span>d)</span><br><span class="line">                ),</span><br><span class="line">                Collections.singletonList(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">"泰达米尔"</span>, <span class="number">600</span>, <span class="number">90</span>d)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//各种流处理方法---------filter</span></span><br><span class="line">    <span class="comment">//----------------------map</span></span><br><span class="line">    <span class="comment">//--------------------reduce等等</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-filter"><a href="#1-filter" class="headerlink" title="1.filter"></a>1.filter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * filter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 过滤出list中学生名字中包括 "1" 的学生集合，</span></span><br><span class="line"><span class="comment">     *       并使用peek()利用其返回Stream&lt;Student&gt;直接以流的方式实现打印过滤出的学生</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       peek() 和 ForEach() 的区别：</span></span><br><span class="line"><span class="comment">     *       前者返回Stream&lt;T&gt; 可在流的基础上继续流操作</span></span><br><span class="line"><span class="comment">     *       后者返回void,想要继续流操作需要进行二次流处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">filterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Student&gt; collect = list.stream().filter(item -&gt; item.getName().contains(<span class="string">"1"</span>))</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, collect.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取过滤的第一条数据，如果包含则打印</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.stream().filter(item -&gt; item.getName().contains(<span class="string">"1"</span>))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-map"><a href="#2-map" class="headerlink" title="2.map"></a>2.map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 可以将List里面的对象转化成新的对象</span></span><br><span class="line"><span class="comment">     * 1.将学生集合里不小于90分的作为精英学生过滤出来,并打印</span></span><br><span class="line"><span class="comment">     * 2.获取所有学生的 name 集合,并打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;EliteStudent&gt; collect = list.stream().filter(item -&gt; item.getScore() &gt;= <span class="number">90</span>)</span><br><span class="line">                .map(student -&gt; &#123;</span><br><span class="line">                    EliteStudent eliteStudent = <span class="keyword">new</span> EliteStudent();</span><br><span class="line">                    BeanUtils.copyProperties(student, eliteStudent);</span><br><span class="line">                    <span class="keyword">return</span> eliteStudent;</span><br><span class="line">                &#125;).peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="number">3</span>, collect.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; nameList = list.stream().map(Student::getName)</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="number">5</span>, nameList.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-flatMap"><a href="#3-flatMap" class="headerlink" title="3.flatMap"></a>3.flatMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flatMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 将嵌套列表转换为普通列表，例如 List&lt;List&lt;Student&gt;&gt; 转化为 List&lt;Student&gt;</span></span><br><span class="line"><span class="comment">     * 1.将嵌套列表转化成普通列表，断言转化结果 = list</span></span><br><span class="line"><span class="comment">     * 2.转化后获取列表的 id 集合并打印</span></span><br><span class="line"><span class="comment">     * 3.转化后再提取集合的分数，求平均值，打印平均值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatMapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; collect = listFlat.stream().flatMap(Collection::stream)</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(collect, list);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; idList = listFlat.stream().flatMap(Collection::stream)</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .flatMapToInt(student -&gt; IntStream.of(student.getId()))</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .boxed()</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(idList.size(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        listFlat.stream().flatMap(Collection::stream)</span><br><span class="line">                .mapToDouble(Student::getScore)</span><br><span class="line">                .average()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-sorted"><a href="#4-sorted" class="headerlink" title="4.sorted"></a>4.sorted</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 排序</span></span><br><span class="line"><span class="comment">     * 1.先按照分数倒叙排列，如果分数相同按照年龄正序排列，如果年龄相同按照 id 正序排列，打印</span></span><br><span class="line"><span class="comment">     * 2.如果 reversed() 写在最后，则全部按照倒叙排列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortedTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; collect = list.stream().sorted(Comparator.comparing(Student::getScore).reversed()</span><br><span class="line">                .thenComparing(Student::getAge)</span><br><span class="line">                .thenComparing(Student::getId))</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="string">"李青"</span>, collect.get(<span class="number">0</span>).getName());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"-------------------------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; collect2 = list.stream().sorted(Comparator.comparing(Student::getScore)</span><br><span class="line">                .thenComparing(Student::getAge)</span><br><span class="line">                .thenComparing(Student::getId).reversed())</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="string">"李青"</span>, collect2.get(<span class="number">0</span>).getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-match"><a href="#5-match" class="headerlink" title="5.match"></a>5.match</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 验证list中的每一项是否匹配我们的条件</span></span><br><span class="line"><span class="comment">     * allMatch 全都匹配</span></span><br><span class="line"><span class="comment">     * anyMatch 任意匹配</span></span><br><span class="line"><span class="comment">     * noneMatch 全不匹配</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 设置匹配条件为正则表达式 ^[1-9]\\d*$ 正整数</span></span><br><span class="line"><span class="comment">     * 1.验证list的id是否全都匹配条件</span></span><br><span class="line"><span class="comment">     * 2.临时改变list的第一个年龄为 -1 验证是否年龄任意一个匹配条件</span></span><br><span class="line"><span class="comment">     * 3.验证分数是否全不匹配条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">matchTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = list.stream().allMatch(item -&gt; ReUtil.isMatch(<span class="string">"^[1-9]\\d*$"</span>, item.getId().toString()));</span><br><span class="line">        log.info(<span class="string">"输出list的id是否全部匹配条件,结果：----------[&#123;&#125;]"</span>, b);</span><br><span class="line"></span><br><span class="line">        list.get(<span class="number">0</span>).setAge(-<span class="number">1</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        <span class="keyword">boolean</span> b1 = list.stream().anyMatch(item -&gt; ReUtil.isMatch(<span class="string">"^[1-9]\\d*$"</span>, item.getAge().toString()));</span><br><span class="line">        log.info(<span class="string">"输出list的年龄是否任意匹配条件,结果：----------[&#123;&#125;]"</span>, b1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b2 = list.stream().noneMatch(item -&gt; ReUtil.isMatch(<span class="string">"^[1-9]\\d*$"</span>, item.getScore().toString()));</span><br><span class="line">        log.info(<span class="string">"输出list的年龄是否都不匹配条件,结果：----------[&#123;&#125;]"</span>, b2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-reduce"><a href="#6-reduce" class="headerlink" title="6.reduce"></a>6.reduce</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reduce</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 合并流元素产生单个值</span></span><br><span class="line"><span class="comment">     * 1.计算list中所有学生年龄的总和，存在则打印</span></span><br><span class="line"><span class="comment">     * 2.计算list中所有学生年龄的总和，存在则打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.stream().map(Student::getAge)</span><br><span class="line">                .reduce(Integer::sum)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        list.stream().map(Student::getScore)</span><br><span class="line">                .reduce(Double::sum)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-collertor"><a href="#7-collertor" class="headerlink" title="7.collertor"></a>7.collertor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * collector</span></span><br><span class="line"><span class="comment">     * 收集器，主要用于toList() / toSet() / toMap() / joining()连接字符串</span></span><br><span class="line"><span class="comment">     * 1.把list中的id作为key, name作为value转化成Map</span></span><br><span class="line"><span class="comment">     * 2.把学生名字用逗号拼接，并且第一个逗号用星号替换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">collectorTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, String&gt; map = list.stream().collect(Collectors.toMap(Student::getId, Student::getName));</span><br><span class="line">        map.forEach((k, v) -&gt; log.info(<span class="string">"key = &#123;&#125; , value = &#123;&#125;"</span>, k, v));</span><br><span class="line"></span><br><span class="line">        String s = list.stream().map(Student::getName)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">","</span>))</span><br><span class="line">                .replaceFirst(<span class="string">","</span>, <span class="string">"*"</span>);</span><br><span class="line">        log.info(<span class="string">"输出逗号拼接的字符串--&gt;&#123;&#125;"</span>, s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-summarizingDouble"><a href="#8-summarizingDouble" class="headerlink" title="8.summarizingDouble"></a>8.summarizingDouble</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * summarizingDouble</span></span><br><span class="line"><span class="comment">     * 1.计算集合中某个元素的 count / sum / avg / min / max</span></span><br><span class="line"><span class="comment">     * 2.第二种写法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">summarizingDoubleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DoubleSummaryStatistics collect = list.stream()</span><br><span class="line">                .collect(Collectors.summarizingDouble(Student::getScore));</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        DoubleSummaryStatistics doubleSummaryStatistics = list.stream()</span><br><span class="line">                .mapToDouble(Student::getScore)</span><br><span class="line">                .summaryStatistics();</span><br><span class="line">        System.out.println(doubleSummaryStatistics);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-partitioningBy"><a href="#9-partitioningBy" class="headerlink" title="9.partitioningBy"></a>9.partitioningBy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * partitioningBy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 用于分割列表</span></span><br><span class="line"><span class="comment">     * 把学生列表中年龄大于100的放进key为true的Map中</span></span><br><span class="line"><span class="comment">     * 小于等于100的放进key为false的Map中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partitioningByTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Boolean, List&lt;Student&gt;&gt; map = list.stream()</span><br><span class="line">                .collect(Collectors.partitioningBy(e -&gt; e.getAge() &gt; <span class="number">100</span>));</span><br><span class="line">        log.info(<span class="string">"true列表 = &#123;&#125;"</span>, map.get(Boolean.TRUE));</span><br><span class="line">        log.info(<span class="string">"false列表 = &#123;&#125;"</span>, map.get(Boolean.FALSE));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-groupingBy"><a href="#10-groupingBy" class="headerlink" title="10.groupingBy"></a>10.groupingBy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * groupingBy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 分组</span></span><br><span class="line"><span class="comment">     * 1.根据成绩分组</span></span><br><span class="line"><span class="comment">     * 2.获取每个分数的人数</span></span><br><span class="line"><span class="comment">     * 3.根据成绩获取取得每个成绩的学生的总分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">groupingByTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Double, List&lt;Student&gt;&gt; map1 = list.stream().collect(Collectors.groupingBy(Student::getScore));</span><br><span class="line">        map1.forEach((k, v) -&gt; System.out.println(k + <span class="string">"\t"</span> + v));</span><br><span class="line"></span><br><span class="line">        Map&lt;Double, Long&gt; map2 = list.stream().collect(Collectors.groupingBy(Student::getScore, Collectors.counting()));</span><br><span class="line">        map2.forEach((k,v) -&gt; System.out.println(k + <span class="string">"\t"</span> + v));</span><br><span class="line"></span><br><span class="line">        Map&lt;Double, Double&gt; map3 = list.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Student::getScore, Collectors.summingDouble(Student::getScore)));</span><br><span class="line">        map3.forEach((k, v) -&gt; System.out.println(k + <span class="string">"\t"</span> + v));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-parallel"><a href="#11-parallel" class="headerlink" title="11.parallel"></a>11.parallel</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * parallel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 并发</span></span><br><span class="line"><span class="comment">     * 延迟一秒后，并发的打印出学生的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parallel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.stream().parallel().forEach(<span class="keyword">this</span>::print);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"学生的名字是 ： &#123;&#125;"</span>, student.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-读写文件"><a href="#12-读写文件" class="headerlink" title="12.读写文件"></a>12.读写文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 读写文件</span></span><br><span class="line"><span class="comment">     * 先把list中的数据写到student.txt中</span></span><br><span class="line"><span class="comment">     * 再读取出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fileTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(Files.newBufferedWriter(Paths.get(<span class="string">"D://student.txt"</span>)));</span><br><span class="line">        <span class="comment">//list列表写出到文件student.txt中</span></span><br><span class="line">        list.forEach(printWriter::println);</span><br><span class="line">        printWriter.close();</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        List&lt;String&gt; collect = Files.lines(Paths.get(<span class="string">"D://student.txt"</span>))</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="number">5</span>, collect.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Stream()流</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman使用的几个小技巧</title>
    <url>/article/b811dc66.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Postman使用的几个小技巧"><a href="#Postman使用的几个小技巧" class="headerlink" title="Postman使用的几个小技巧"></a>Postman使用的几个小技巧</h2><h3 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1.环境变量"></a>1.环境变量</h3><ul>
<li>调用方式 </li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-1.png" alt="image-20200611212208754"></p>
<a id="more"></a>

<p>如上图标注位置，可以切换、查看、管理环境，在环境中可以指定环境变量，供Postman进行相应环境下的全局调用。</p>
<p>真正的不分环境的全局变量可设置成全局变量。</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-2.png" alt="image-20200611212530159"></p>
<ul>
<li><p>例如我在环境 变量中设置了一个变量 <code>url_base</code> 值为 <code>localhost:8080</code>之后每次测试接口就直接调用<code></code>就可以了。</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-3.png" alt="image-20200611215620570"></p>
</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-4.png" alt="image-20200611222906182"></p>
<h3 id="2-设置接口调用前执行脚本"><a href="#2-设置接口调用前执行脚本" class="headerlink" title="2.设置接口调用前执行脚本"></a>2.设置接口调用前执行脚本</h3><ul>
<li>例如：登录之前需要执行一个接口获取验证码，</li>
<li>然后将返回结果中的验证码设置到环境中</li>
<li>供登录接口作为参数调用</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/image-20200611221039122.png" alt="image-20200611221039122"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送一个Get请求</span></span><br><span class="line">pm.sendRequest(<span class="string">"http://127.0.0.1:8080/api/account/getverifycode"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//打印返回的json结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(response.json());</span><br><span class="line">    <span class="comment">//从返回的结果中设置变量到环境中</span></span><br><span class="line">    pm.environment.set(<span class="string">"text"</span>, response.json().data.text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-6.png" alt="image-20200611221333496"></p>
<h3 id="3-设置调用之后的Test脚本"><a href="#3-设置调用之后的Test脚本" class="headerlink" title="3.设置调用之后的Test脚本"></a>3.设置调用之后的<code>Test</code>脚本</h3><ul>
<li>我们可以在Tests中书写捷空运调用之后执行的脚本，可以进行结果断言、控制台打印、设置变量等等</li>
<li>例如登录成功之后，打印返回token到控制台，postman控制台在软件左下角，并把token设置为环境变量</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-7.png" alt="image-20200611220545705"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取返回结果</span></span><br><span class="line"><span class="keyword">var</span> jsonData = <span class="built_in">JSON</span>.parse(responseBody);</span><br><span class="line"><span class="comment">//打印返回结果中的token到控制台</span></span><br><span class="line"><span class="built_in">console</span>.log(jsonData.data);</span><br><span class="line"><span class="comment">//设置返回结果的token为变量到环境中</span></span><br><span class="line">pm.environment.set(<span class="string">"token"</span>, jsonData.data);</span><br></pre></td></tr></table></figure>

<h3 id="4-登录成功的Token的使用"><a href="#4-登录成功的Token的使用" class="headerlink" title="4.登录成功的Token的使用"></a>4.登录成功的Token的使用</h3><ul>
<li>登录成功之后的Token被我们使用脚本存储到环境中，在之后测试需要登录的接口的时候，我们需要将这个token加到Headers请求头中，但是每个接口都要设置一次太麻烦</li>
<li>找了很久没有发现设置一次性解决方案</li>
<li>最后发现了一个提前设置好，一键添加的方案</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-8.png" alt="image-20200611222149293"></p>
<ul>
<li>之后测试接口的时候可以直接点击这里，一键设置token到请求头</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-9.png" alt="image-20200611222316152"></p>
<ul>
<li>效果：</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-10.png" alt="image-20200611222359442"></p>
]]></content>
      <tags>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>java链接Lettuce客户端操作</title>
    <url>/article/dc5eed37.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="java使用Lettuce客户端连接redis学习基本redis指令"><a href="#java使用Lettuce客户端连接redis学习基本redis指令" class="headerlink" title="java使用Lettuce客户端连接redis学习基本redis指令"></a>java使用Lettuce客户端连接redis学习基本redis指令</h2><ul>
<li><p>参考try.redis.io进行以下几种存储类型的指令学习</p>
</li>
<li><p>string、list、set、zset、hash</p>
</li>
</ul>
<p>由于Springboot 2.0 中redis客户端使用了Lettue,所以没使用jedis进行学习，依赖由于项目中引入了以下依赖，所以就不用别的了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--因为Springboot 2.0 中redis客户端使用了Lettue, 其依赖于commons--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>操作基本指令代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 参考 try.redis.io</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/3 16:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisClient redisClient;</span><br><span class="line">    StatefulRedisConnection&lt;String, String&gt; redisConnection;</span><br><span class="line">    RedisCommands&lt;String, String&gt; sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@BeforeEach</span> 注解在非静态方法上，所有测试方法之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@BeforeAll</span> 注解在静态方法上，所有测试方法之前执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connRedisByLettuce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisURI redisUri = RedisURI.builder()</span><br><span class="line">            .withHost(<span class="string">"127.0.0.1"</span>)</span><br><span class="line">            .withPort(<span class="number">6379</span>)</span><br><span class="line">            .withTimeout(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS))</span><br><span class="line">            .build();</span><br><span class="line">        redisClient = RedisClient.create(redisUri);</span><br><span class="line">        redisConnection = redisClient.connect();</span><br><span class="line">        sync = redisConnection.sync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisConnection.close();</span><br><span class="line">        redisClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string类型set get</span></span><br><span class="line"><span class="comment">     * ttl 返回-1永不超时</span></span><br><span class="line"><span class="comment">     * ttl 返回-2不存在此key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(sync.set(<span class="string">"k1"</span>, <span class="string">"v1"</span>));</span><br><span class="line">        sync.expire(<span class="string">"k1"</span>, <span class="number">1000</span>); <span class="comment">//设置1000秒超时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(sync.ttl(<span class="string">"k1"</span>).toString()); <span class="comment">//获取剩余超时时间</span></span><br><span class="line">        log.info(sync.get(<span class="string">"k1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis 列表，相当于链表</span></span><br><span class="line"><span class="comment">     * lpush 左侧添加，是可变参数，可同时追加多个</span></span><br><span class="line"><span class="comment">     * rpush 右侧添加，是可变参数，可同时追加多个</span></span><br><span class="line"><span class="comment">     * lrange key 0 -1 获取列表第一到最后一个</span></span><br><span class="line"><span class="comment">     * lpop key 删除列表左侧第一个</span></span><br><span class="line"><span class="comment">     * rpop key 删除列表右侧第一个</span></span><br><span class="line"><span class="comment">     * llen key 获取当前列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.rpush(<span class="string">"friends"</span>, <span class="string">"Tom"</span>, <span class="string">"yunqing"</span>);</span><br><span class="line">        sync.rpush(<span class="string">"friends"</span>, <span class="string">"Bob"</span>, <span class="string">"kkk"</span>);</span><br><span class="line">        sync.lpush(<span class="string">"friends"</span>, <span class="string">"peter"</span>);</span><br><span class="line">        log.info(sync.llen(<span class="string">"friends"</span>).toString());</span><br><span class="line">        List&lt;String&gt; friends = sync.lrange(<span class="string">"friends"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        friends.forEach(System.out::println);</span><br><span class="line">        sync.lpop(<span class="string">"friends"</span>);</span><br><span class="line">        sync.rpop(<span class="string">"friends"</span>);</span><br><span class="line">        List&lt;String&gt; friends2 = sync.lrange(<span class="string">"friends"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        friends2.forEach(System.out::println);</span><br><span class="line">        log.info(sync.llen(<span class="string">"friends"</span>).toString());</span><br><span class="line">        sync.expire(<span class="string">"friends"</span>, <span class="number">10</span>);<span class="comment">//设置1000秒过期</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis  set集合</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.sadd(<span class="string">"names"</span>, <span class="string">"yunqing"</span>, <span class="string">"kkk"</span>, <span class="string">"tom"</span>, <span class="string">"tom"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>);</span><br><span class="line">        log.info(<span class="string">"输出set集合[&#123;&#125;]"</span>, String.valueOf(sync.smembers(<span class="string">"names"</span>)));</span><br><span class="line">        log.info(<span class="string">"测试是否存在---------[&#123;&#125;]"</span>, sync.sismember(<span class="string">"names"</span>, <span class="string">"yunqing"</span>));</span><br><span class="line">        log.info(<span class="string">"删除结果1成功，0失败---------[&#123;&#125;&#125;]"</span>, sync.srem(<span class="string">"names"</span>, <span class="string">"tom"</span>));</span><br><span class="line">        log.info(<span class="string">"输出集合[&#123;&#125;]"</span>, sync.smembers(<span class="string">"names"</span>));</span><br><span class="line">        sync.expire(<span class="string">"names"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带排序的set集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisZSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">1</span>, <span class="string">"yunqing"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">3</span>, <span class="string">"tom"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">2</span>, <span class="string">"kkk"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">10</span>, <span class="string">"tom"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">5</span>, <span class="string">"peter"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">5</span>, <span class="string">"bob"</span>);</span><br><span class="line">        log.info(<span class="string">"查看集合所有[&#123;&#125;]---------"</span>, sync.zrange(<span class="string">"names"</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        log.info(<span class="string">"删除一个-----[&#123;&#125;]"</span>, sync.zrem(<span class="string">"names"</span>, <span class="string">"peter"</span>));</span><br><span class="line">        log.info(<span class="string">"查看集合所有[&#123;&#125;]---------"</span>, sync.zrange(<span class="string">"names"</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        sync.expire(<span class="string">"names"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash格式存储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.hset(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"yunqing"</span>);</span><br><span class="line">        sync.hset(<span class="string">"user"</span>, <span class="string">"age"</span>, <span class="string">"26"</span>);</span><br><span class="line">        log.info(<span class="string">"获取所有-----[&#123;&#125;]"</span>, sync.hgetall(<span class="string">"user"</span>));</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line">        map.put(<span class="string">"email"</span>, <span class="string">"10001"</span>);</span><br><span class="line">        sync.hmset(<span class="string">"user"</span>, map);</span><br><span class="line">        log.info(<span class="string">"获取所有-----[&#123;&#125;]"</span>, sync.hgetall(<span class="string">"user"</span>));</span><br><span class="line">        log.info(<span class="string">"获取一个------[&#123;&#125;]"</span>, sync.hget(<span class="string">"user"</span>, <span class="string">"email"</span>));</span><br><span class="line">        sync.expire(<span class="string">"user"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用redis特性来创建每日流水号</title>
    <url>/article/8f6dc9b4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这里需求是创建每日的流水号，例如：每向数据库中添加一条数据，其编号设置为yyyyMMdd0001、yyyyMMdd0002这样的格式，日期加后四位为当日流水号，也就是当日第几个添加的数据。</p>
</blockquote>
<a id="more"></a>

<ul>
<li>为什么考虑使用redis呢？</li>
</ul>
<p>额、redis的特性就不介绍了，反正本文也不是介绍redis怎么使用的…</p>
<p>简而言之，为了显示自己用过redis而用，哈哈哈</p>
<ul>
<li>这里docker启动redis遇到一个问题，记录一下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建容器的时候报错WARNING: IPv4 forwarding is disabled. Networking will not work.</span></span><br><span class="line"><span class="comment">#这个错导致连接不上redis，但是在容器内部docker exec -it redis bash     redis-cli能够使用</span></span><br><span class="line"><span class="comment">#我启动redis容器的命令</span></span><br><span class="line">docker run -d --privileged=<span class="literal">true</span> --restart=always -p 6379:6379 -v /usr/docker/redis/data:/data --name redis redis:latest redis-server --appendonly yes</span><br><span class="line"><span class="comment">#解决办法</span></span><br><span class="line">vim  /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment">#添加下面这行</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"><span class="comment">#重启network</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="comment">#删除错误的重启重新执行启动redis的命令</span></span><br><span class="line">docker stop redis</span><br><span class="line">docker rm redis</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个spring boot项目，在pom.xml中引入如下依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--因为Springboot 2.0 中redis客户端使用了Lettue, 其依赖于commons--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置application.yml连接redis</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.16</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># 连接超时时间（记得添加单位，Duration）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10000ms</span></span><br><span class="line">    <span class="comment"># Redis默认情况下有16个分片，这里配置具体使用的分片</span></span><br><span class="line">    <span class="comment"># database: 0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接 默认 8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接 默认 0</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建redis操作类，这里主要利用的redis自增操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Title</span>: incr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 获取redis自增序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis的 key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 自增的增量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> l = redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"redis获取"</span> + key + <span class="string">"失败"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Title</span>: expire</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 设置过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"redis设置"</span> + key + <span class="string">"过期时间失败"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把获取到的redis自增的序号格式化成指定格式0001/0002/…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将传入的数 seq 格式化成 length 位，不够前边补 0</span></span><br><span class="line"><span class="comment">     * 如果 length &lt; 3 则按照 3 算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSequence</span><span class="params">(<span class="keyword">long</span> seq, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(seq);</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        length = Math.max(length, DEFAULT_LENGTH);</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= length) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rest = length - len;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试获取到的yyyyMMdd0001格式的每日流水号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoRedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String  SERIAL_NUM= <span class="string">"redis:serialNumber:"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisCacheTemplate redisCacheTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String currentDate = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">		String key = SERIAL_NUM + currentDate;</span><br><span class="line">		<span class="keyword">long</span> incr = redisCacheTemplate.incr(key, <span class="number">1</span>, <span class="number">86400</span>);</span><br><span class="line">		<span class="comment">//移位运算符&lt;&lt;，左移几位相当于乘以2的几次方, 1 &lt;&lt; 2 = 4</span></span><br><span class="line">		String code = SequenceUtil.getSequence(incr, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">		log.info(currentDate + code);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释一下：用redis:serialNumber:20200409这个作为redis的key去查找自增值，每次执行加1</p>
<p>redis中的key-value将是这样：</p>
<p>key                                                               value</p>
<p>redis:serialNumber:20200409                0001</p>
<p>redis:serialNumber:20200409                0002</p>
<p>…</p>
<p>直到下一天key变成了redis:serialNumber:20200410,value则会从0001开始递增</p>
<p>又因为我设置了redis的过期时间是86400秒 = 1天，所以过期的数据会自动删除</p>
</blockquote>
<ul>
<li>看一下控制台的log日志</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/09-8f6dc9b4-1.png" alt="09-8f6dc9b4-1"></p>
<ul>
<li>在执行一次</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/09-8f6dc9b4-2.png" alt="09-8f6dc9b4-2"></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>基于mybatis plus讲解一些知识点</title>
    <url>/article/cf7f7e62.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mybatis-plus之主键生成策略"><a href="#mybatis-plus之主键生成策略" class="headerlink" title="mybatis plus之主键生成策略"></a>mybatis plus之主键生成策略</h2><h3 id="1-自增策略"><a href="#1-自增策略" class="headerlink" title="1.自增策略"></a>1.自增策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.AUTO)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure>

<h3 id="2-雪花生成器（推）"><a href="#2-雪花生成器（推）" class="headerlink" title="2.雪花生成器（推）"></a>2.雪花生成器（推）</h3>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.ASSIGN_ID)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="3-UUID"><a href="#3-UUID" class="headerlink" title="3.UUID"></a>3.UUID</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.ASSIGN_UUID)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>自3.3.0开始,默认使用雪花算法+UUID(不含中划线)</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th>主键生成策略</th>
<th>主键类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nextId</td>
<td>ASSIGN_ID，<del>ID_WORKER，ID_WORKER_STR</del></td>
<td>Long,Integer,String</td>
<td>支持自动转换为String类型，但数值类型不支持自动转换，需精准匹配，例如返回Long，实体主键就不支持定义为Integer</td>
</tr>
<tr>
<td align="center">nextUUID</td>
<td>ASSIGN_UUID，<del>UUID</del></td>
<td>String</td>
<td>默认不含中划线的UUID生成</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-Sequence主键"><a href="#4-Sequence主键" class="headerlink" title="4.Sequence主键"></a>4.Sequence主键</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@KeySequence</span>(value = <span class="string">"SEQ_ORACLE_STRING_KEY"</span>, clazz = String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">YourEntity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"ID_STR"</span>, type = IdType.INPUT)</span><br><span class="line">    <span class="keyword">private</span> String idStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>主键生成策略必须使用INPUT</strong></p>
</blockquote>
<blockquote>
<p>支持父类定义@KeySequence子类继承使用</p>
</blockquote>
<p>内置支持：</p>
<ul>
<li>DB2KeyGenerator</li>
<li>H2KeyGenerator</li>
<li>KingbaseKeyGenerator</li>
<li>OracleKeyGenerator</li>
<li>PostgreKeyGenerator</li>
</ul>
<blockquote>
<p>如果内置支持不满足你的需求，可实现IKeyGenerator接口来进行扩展.</p>
</blockquote>
<h4 id="SpringBoot方式一：配置类"><a href="#SpringBoot方式一：配置类" class="headerlink" title="SpringBoot方式一：配置类"></a>SpringBoot方式一：配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IKeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> H2KeyGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SpringBoot方式二：通过MybatisPlusPropertiesCustomizer自定义"><a href="#SpringBoot方式二：通过MybatisPlusPropertiesCustomizer自定义" class="headerlink" title="SpringBoot方式二：通过MybatisPlusPropertiesCustomizer自定义"></a>SpringBoot方式二：通过MybatisPlusPropertiesCustomizer自定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MybatisPlusPropertiesCustomizer <span class="title">plusPropertiesCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plusProperties -&gt; plusProperties.getGlobalConfig().getDbConfig().setKeyGenerator(<span class="keyword">new</span> H2KeyGenerator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatis-plus之自动填充字段功能"><a href="#mybatis-plus之自动填充字段功能" class="headerlink" title="mybatis plus之自动填充字段功能"></a>mybatis plus之自动填充字段功能</h2><ul>
<li>个人比较喜欢这个功能，尤其是用于<code>create_time</code>和<code>update_time</code>两个字段的自动填充。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注意：设置此字段为自动填充字段，即添加记录的时候自动添加创建时间</span></span><br><span class="line"><span class="comment">    * 需要配置实现接口 MetaObjectHandler</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@TableField</span>(fill = FieldFill.INSERT)</span><br><span class="line">   <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注意：设置此字段为自动填充字段，添加或更新记录时候，此字段自动填充</span></span><br><span class="line"><span class="comment">    * 需要配置实现接口 MetaObjectHandler</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@TableField</span>(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">   <span class="keyword">private</span> LocalDateTime updateTime;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要实现接口<code>MetaObjectHandler</code>元数据处理器接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现添加的时候自动填充的字段</span></span><br><span class="line"><span class="comment">     * 添加记录的时候自动设置创建时间和修改时间为当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"createTime"</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改的时候自动填充的字段, 填充为当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatis-plus之乐观锁"><a href="#mybatis-plus之乐观锁" class="headerlink" title="mybatis plus之乐观锁"></a>mybatis plus之乐观锁</h2><ul>
<li>首先了解一下什么是乐观锁？什么是悲观锁？</li>
</ul>
<blockquote>
<p>乐观锁与悲观锁都是用来解决并发情况下写操作可能会导致的<strong>丢失更新</strong>的问题。</p>
</blockquote>
<ul>
<li>什么是并发操作下造成的读的问题 ？</li>
</ul>
<blockquote>
<p>首先来说如果不考虑事务的隔离性，会产生几个读的问题，<strong>脏读、不可重复读、幻读</strong></p>
<p><strong>脏读</strong>：读到未提交的数据，也就是事务A读到事务B更改后的数据，事务B异常回滚了，所以事务A读到的是脏数据。</p>
<p><strong>不可重复读</strong>：例如事务A读到小李30岁，这时候事务B把小李改成20岁提交了，事务A未结束又读了一遍，发现小李变成了20岁。</p>
<p><strong>幻读</strong>：例如事务A读员工数量200人，这时候事务B添加了5条员工数据并提交，这时候事务A未结束，又读取了一遍员工数量，发现变成了205条。</p>
</blockquote>
<ul>
<li><p>额、上面简单总结一下，不考虑事务的隔离级别的情况下可能造成的读的问题。</p>
</li>
<li><p>事务的隔离级别有什么呢？</p>
</li>
</ul>
<blockquote>
<p>1、Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大；</p>
</blockquote>
<blockquote>
<p>2、REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。</p>
</blockquote>
<blockquote>
<p>3、READ COMMITTED （读提交）：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。</p>
</blockquote>
<blockquote>
<p>4、Read Uncommitted（读未提交） ：事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。</p>
</blockquote>
<ul>
<li>mysql默认的事务隔离级别是：可重复读</li>
</ul>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong>可重复读（repeatable-read）</strong></td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li>什么是并发写操作造成的丢失更新？</li>
</ul>
<blockquote>
<p>例如事务A和事务B同时修改小明的工资，他们两个读取到的小明工资都是2000然后事务A更改了小明工资为3000后提交，这时候事务B更改了小明的工资为5000，提交之后事务A对工资的更新就丢失了。结果为5000</p>
</blockquote>
<blockquote>
<p>悲观锁和乐观锁就是为了解决并发操作造成的丢失更新问题:</p>
<p><strong>悲观锁：</strong>顾名思义，就是悲观的认为并发问题一定会出现，所以在对一个数据进行操作的时候一定会加锁，因为他认为不加锁一定会产并发问题。</p>
<p><strong>乐观锁：</strong>顾名思义，就是乐观的认为读取数据的时候不会有其他事务进行修改，所以不会加锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用<strong>版本号机制</strong>或<strong>CAS操作</strong>实现。这里mybatis plus使用的就是版本号机制实现的乐观锁。</p>
</blockquote>
<ul>
<li>先介绍一下CAS操作：Compare and Swap，即比较再交换。</li>
</ul>
<blockquote>
<p>java中有一个并发包<code>java.util.concurrent.*</code>,这个包中的类就是使用CAS算法实现了乐观锁。之前java语言靠<code>synchronized</code>关键字保证同步，使用<code>synchronized</code>关键字是一种独占锁，属于悲观锁。</p>
</blockquote>
<ul>
<li>CAS的功能是判断内存中的某个位置的值是否为预期值，如果是则改变为新的值，这个过程是原子的。</li>
</ul>
<blockquote>
<p>CAS算法实现的一个前提是需要取出内存中某时刻的数据，并在当前时间进行比较并替换，那么在这个时间差内，如果线程A从内存V处取出值为1，这时候另一个线程B也在内存V处取出值为1，并且线程B经过一些操作将值改成了2，然后线程B又经过操作将值改回1，这时候线程A操作CAS发现内存中的值仍为1，然后线程A操作成功改了V处的值为3。</p>
<p>尽管这个线程A的CAS操作执行成功，但是并不代表这个过程是没有问题的。这就是著名的<code>ABA问题</code>。</p>
</blockquote>
<ul>
<li>如何解决ABA问题？使用版本号！mybatis plus就是使用版本号来实现乐观锁的。</li>
</ul>
<blockquote>
<p>可以使用版本号来解决，例如:数据库中添加一个版本号，取出记录的时候，获取当前的版本号，更新数据的时候，带上这个版本号，即 update set version = newVersion where version = oldVersion,如果版本号不等于之前的版本号，说明已经被更改过了，即本次更新失败。</p>
</blockquote>
<ul>
<li>使用mybatis plus实现乐观锁</li>
</ul>
<ol>
<li>表中添加字段，作为乐观锁的版本号</li>
<li>对应实体类添加属性version</li>
<li>在实体类版本号属性上添加@Version注解</li>
<li>配置mybatis plus乐观锁的插件</li>
<li>（可选）可以利用之前讲的自动填充在添加记录的时候给Version一个默认值1</li>
</ol>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-1.png" alt="image-20200406185428516"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 版本号属性</span></span><br><span class="line"><span class="comment"> * 设置此字段在添加的时候自动设置version值为 1</span></span><br><span class="line"><span class="comment"> * 需要配置实现接口 MetaObjectHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="meta">@TableField</span>(fill = FieldFill.INSERT)</span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.yunqing.demomybatisplus.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//配置乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现添加的时候自动填充的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置添加role记录的时候自动填充版本号为1</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"version"</span>, <span class="string">"1"</span>, metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试使用乐观锁进行更新数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ActiveRecord修改</span></span><br><span class="line"><span class="comment">     * UPDATE t_role SET role_code=?, role_name=?, update_time=?, version=? WHERE id=? AND version=?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * UPDATE t_role SET create_time=? WHERE (id = ?)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 测试乐观锁更新Role,先查询获取版本号，在更新，之后再获取版本号</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Role role = <span class="keyword">new</span> Role().selectById(<span class="number">2L</span>);</span><br><span class="line">        log.info(<span class="string">"更新之前获取版本号 = &#123;&#125;"</span>, role.getVersion());</span><br><span class="line">        role.setRoleName(<span class="string">"管理员1234"</span>);</span><br><span class="line">        Assertions.assertTrue(role.updateById());</span><br><span class="line">        Role role2 = <span class="keyword">new</span> Role().selectById(<span class="number">2L</span>);</span><br><span class="line">        log.info(<span class="string">"更新之后获取版本号 = &#123;&#125;"</span>, role2.getVersion());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非乐观锁更新，直接更新</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assertions.assertTrue(<span class="keyword">new</span> Role().update(<span class="keyword">new</span> UpdateWrapper&lt;Role&gt;().lambda()</span><br><span class="line">                .set(Role::getCreateTime, LocalDateTime.now()).eq(Role::getId, <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到控制台如下输出：</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-2.png" alt="image-20200406191834047"></p>
<ul>
<li><strong>适用场景：读取频繁使用乐观锁，写入频繁使用悲观锁</strong></li>
</ul>
<h2 id="mybatis之逻辑删除"><a href="#mybatis之逻辑删除" class="headerlink" title="mybatis之逻辑删除"></a>mybatis之逻辑删除</h2><ul>
<li>之前我们做逻辑删除，需要先在数据库创建标志位，之后删除语句也成修改，修改标志位的值，查询的时候还要添加where deleted = 0 来查询没被删除的。</li>
<li>mybatis 提供了一个注解<code>@TableLogic</code>来让我们不再需要关注这个标志位。</li>
<li>只需要给实体类中的逻辑删除字段加上此注解即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逻辑删除标志位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行删除操作，默认就是逻辑删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试逻辑删除</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ljDeleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Assertions.assertTrue(<span class="keyword">new</span> Role().setId(<span class="number">2L</span>).deleteById());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看到上面测试代码执行的是mybatis plus的删除操作，看一下控制行输出代码，执行的却是update</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-3.png" alt="05-cf7f7e62-3"></p>
<ul>
<li>由下图可以看到，id为2的这条数据被逻辑删除了 deleted = 1</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-4.png" alt="05-cf7f7e62-4"></p>
<ul>
<li>之后执行查询的时候也不用关注这个逻辑删除标志位了，默认查询未被删除的数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试查询，看看逻辑删除的数据是否还在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Role&gt; roles = <span class="keyword">new</span> Role().selectAll();</span><br><span class="line">    roles.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看控制台输出的sql 自动帮我们加上了<code>where deleted = 0</code>并且遍历结果集，没有被逻辑删除的id = 2的数据。</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-5.png" alt="05-cf7f7e62-5"></p>
<blockquote>
<p>以后再写查询再也不用关注是否被逻辑删除了，但是这也造成了另一个问题，假如我们想要查询被逻辑删除的数据怎么办？？？</p>
<p>这就要通过在<code>mapper.xml</code>中手写sql来完成啦，也很方便，毕竟查询被逻辑删除的数据的业务需求几乎没有。</p>
</blockquote>
<p><a href="https://mybatis.plus/guide/logic-delete.html" target="_blank" rel="noopener external nofollow noreferrer" class="LinkCard">更多自定义配置☞官方文档</a></p>
<p><a href="https://github.com/kangqing/boot-demos/tree/master/demo-mybatis-plus" target="_blank" rel="noopener external nofollow noreferrer" class="LinkCard">以上代码地址☞见github</a></p>
]]></content>
      <tags>
        <tag>mybatis plus</tag>
        <tag>乐观锁</tag>
        <tag>悲观锁</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo之next主题美化</title>
    <url>/article/29e1e123.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>next7之后为了方便升级，修改主题配置文件/source/_data/next.yml文件</li>
</ul>
<p>​    <a href="https://theme-next.js.org/" target="_blank" rel="noopener external nofollow noreferrer">具体参考地址</a></p>
<ul>
<li><p>安装<code>nodejs/git/hexo</code>初始化这些基本就不讲了，网上一找一大堆，直接从入手<code>next</code>主题开始.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入博客根目录，从git拉取next主题到themes目录下重命名为next</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.启用主题，博客根目录，`_config.yml`中找theme</span></span><br><span class="line"><span class="string">theme</span> <span class="string">:next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.next包含四套主题，进入next目录下的`_config.yml`查找scheme,选择哪个自己取消注释</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.设置语言，根目录`_config.yml`中language</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.设置菜单及对应页面，next下`_config.yml`中查找menu</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.1上面新建菜单如果要翻译成中文去next-language-zh-CN.yml中自定义</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">资源</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>头像优化</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml中查找avatar</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">http://xxxxxxxxxx</span>  <span class="comment">#你的头像地址</span></span><br><span class="line"><span class="comment"># 站点内地址	图片放至themes/next/source/images/配置为：avatar: /images/图片名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站图标设置，查找favicon</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span>  <span class="comment">#你的网站图标16x16</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span> <span class="comment">#你的网站图标32x32</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文章时候自动打开Typora</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 在next/scripts下创建events.js文件</span><br><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"><span class="comment">// Hexo 3 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  spawn(<span class="string">'start  "D:/software/Typora/Typora.exe" '</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给代码段更换成mac panel风格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于使用的是next7主题，所以直接到hexo下_config.yml中设置高亮配置即可</span></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: </span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span></span><br><span class="line">  <span class="comment"># 添加复制按钮</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 显示文本复制结果。</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>使用<code>algolia搜索</code></p>
<p>去<a href="https://www.algolia.com/注册账号" target="_blank" rel="noopener external nofollow noreferrer">https://www.algolia.com/注册账号</a></p>
<p>[参考了此篇文章](<a href="http://www.werty.cn/2019/07/hexo/hexo" target="_blank" rel="noopener external nofollow noreferrer">http://www.werty.cn/2019/07/hexo/hexo</a> algolia命令执行失败解决方案/)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载插件</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-algolia</span> <span class="string">--save</span></span><br><span class="line"><span class="comment"># 配置环境变量windows参考上面那篇文章</span></span><br><span class="line"><span class="comment"># 根目录_config.yml配置</span></span><br><span class="line"><span class="comment"># Algolia Search API Key</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">applicationID:</span> <span class="string">你的applicationID</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">你的apiKey</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="string">你的索引名字</span></span><br><span class="line"><span class="comment"># hexo的_config.yml配置</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">搜索关键字文章</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">"我们没有找到任何搜索结果: $&#123;query&#125;"</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">"查找到 $&#123;hits&#125; 个结果，用时 $&#123;time&#125; ms"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>额不多说了，参照这两位大佬的吧，配置的很<code>nice</code></p>
<p><a href="https://tding.top/" target="_blank" rel="noopener external nofollow noreferrer">大佬博客：小丁的个人博客</a></p>
<p><a href="https://hasaik.com/" target="_blank" rel="noopener external nofollow noreferrer">大佬博客：Xu’s Blog</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo美化</tag>
      </tags>
  </entry>
  <entry>
    <title>用Docker安装nginx和vsftpd搭建文件服务器</title>
    <url>/article/11c2cd82.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="用Docker安装nginx和vsftpd搭建文件服务器"><a href="#用Docker安装nginx和vsftpd搭建文件服务器" class="headerlink" title="用Docker安装nginx和vsftpd搭建文件服务器"></a>用Docker安装nginx和vsftpd搭建文件服务器</h2><h3 id="讲真的我这辈子绝对不会学docker—————–能香，哈哈！"><a href="#讲真的我这辈子绝对不会学docker—————–能香，哈哈！" class="headerlink" title="讲真的我这辈子绝对不会学docker—————–能香，哈哈！"></a>讲真的我这辈子绝对不会学docker—————–能香，哈哈！</h3><p>docker在centos7的安装方式建议看官网教程，不然docker安装nginx很可能出错。</p>
<p><a href="https://www.jianshu.com/p/3b28f3416dda" target="_blank" rel="noopener external nofollow noreferrer">安装docker可以直接参照我简书上的安装过程</a></p>
<a id="more"></a>

<ul>
<li><p>用docker安装Nginx的过程又学到了很多，例如复制docker容器内的文件到宿主机上等等</p>
</li>
<li><p>使用nginx的很重要的一点是修改nginx.conf这个配置文件</p>
</li>
<li><p>首先从dockerhub上拉取nginx最新的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>先简单的启动一个nginx容器，为了从容器中复制nginx.conf文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker启动nginx容器，命名为test</span></span><br><span class="line">docker run --name <span class="built_in">test</span> -d nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看nginx容器id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h2 id="注意：docker启动nginx需要两个配置文件"><a href="#注意：docker启动nginx需要两个配置文件" class="headerlink" title="注意：docker启动nginx需要两个配置文件"></a>注意：docker启动nginx需要两个配置文件</h2></li>
</ul>
<p>  <a href="https://blog.csdn.net/weixin_42880943/article/details/100777093?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener external nofollow noreferrer" class="LinkCard">此处参考☛迷彩诱惑的青春</a></p>
<ul>
<li><p>一个是位于容器内部的<code>/etc/nginx/nginx.conf</code></p>
</li>
<li><p>另一个是位于容器内部的<code>/etc/nginx/conf.d/default.conf</code></p>
</li>
<li><p><code>default.conf</code>配置的是<code>server { }</code>的内容</p>
<h2 id="所以在这里我们需要把这两个配置文件复制到宿主机用于挂载"><a href="#所以在这里我们需要把这两个配置文件复制到宿主机用于挂载" class="headerlink" title="所以在这里我们需要把这两个配置文件复制到宿主机用于挂载"></a>所以在这里我们需要把这两个配置文件复制到宿主机用于挂载</h2></li>
</ul>
<ul>
<li><p>创建目录用于存放nginx.conf 和 default.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -p创建多级目录</span></span><br><span class="line">mkdir /usr/docker/nginx -p</span><br><span class="line">mkdir /usr/docker/nginx/conf.d/ -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>从nginx容器中复制出nginx文件到刚才新建的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker复制容器id为e9bf057b53bb的/etc/nginx/nginx.conf路径的nginx.conf文件到容器外宿主机的/docker/nginx/目录</span></span><br><span class="line">docker cp e9bf057b53bb:/etc/nginx/nginx.conf /usr/docker/nginx/</span><br><span class="line"><span class="comment"># 复制default.conf,含义参考上条注释</span></span><br><span class="line">docker cp e9bf057b53bb:/etc/nginx/conf.d/default.conf /usr/docker/nginx/conf.d/</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制出来之后删除刚才临时启动的test的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#停止名为test的容器</span></span><br><span class="line">docker stop <span class="built_in">test</span></span><br><span class="line"><span class="comment">#删除名为test的容器</span></span><br><span class="line">docker rm <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动一个完整的nginx容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 \</span><br><span class="line">--name nginx --net host \</span><br><span class="line">-v /usr/docker/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /usr/docker/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \</span><br><span class="line">-v /usr/docker/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /usr/docker/vsftpd/root:/mnt/data \</span><br><span class="line">-v /usr/docker/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">--privileged=<span class="literal">true</span> --restart=always nginx</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="下面的配置解释很重要-结合我default-conf的配置看"><a href="#下面的配置解释很重要-结合我default-conf的配置看" class="headerlink" title="下面的配置解释很重要****结合我default.conf的配置看"></a>下面的配置解释很重要<code>****</code>结合我default.conf的配置看</h2><blockquote>
<p>解释：</p>
<p>-p 宿主机的80端口映射到容器的80端口</p>
<p>–name nginx 容器命名为nginx</p>
<p>–net host 容器和宿主机公用网络</p>
<p><strong>-v 映射宿主机和容器内的路径，首先是把两个配置文件nginx.conf和default.conf从容器目录映射到宿主机的/usr/docker/nginx下的相应目录中，之后只要改宿主机的配置就相当于改了容器中的配置文件。</strong></p>
<p><strong>其次看下面图片中的配置全是去找的容器相应位置的文件，没错，就是找容器相应位置，但是这些位置我也做了映射，例如把nginx的主页位置映射到了/usr/docker/nginx/html最重要的是把静态资源的位置映射到了宿主机的vsftpd静态资源服务器/usr/docker/vsftpd/root目录下，结合default.conf中的配置，就能通过nginx访问vsftpd下的静态图片文件了。</strong></p>
<p>-v 还做了日志文件目录的映射</p>
<p>–privileged=true 给容器内root权限</p>
<p>–restart=always 随docker自启动</p>
<p>启动nginx:latest镜像</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-0.png" alt="image-20200402213717324"></p>
<ul>
<li>开启防火墙相关端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启宿主机防火墙80端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="comment">#重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment">#查看防火墙已经启动的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这时候打开浏览器访问宿主机ip我这里是192.168.137.100就应该访问调到nginx欢迎页，<strong>这里会报错403因为/usr/docker/nginx/html路径下并没有index.html这个欢迎页</strong></p>
</li>
<li><p>额，但是准确的说nginx已经作为docker容器启动了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单的自己写一个欢迎页吧，最起码访问宿主机ip我这是192.168.137.100要看到效果啊</span></span><br><span class="line"><span class="built_in">cd</span> /usr/docker/nginx/html</span><br><span class="line"><span class="comment"># 添加一个index.html文件写入hello nginx</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello nginx"</span> &gt; index.html</span><br><span class="line"><span class="comment"># 容器中的nginx热更新</span></span><br><span class="line">docker <span class="built_in">exec</span> -it nginx  nginx -s reload</span><br><span class="line"><span class="comment"># 不管用就直接重启ngixn容器</span></span><br><span class="line">docker restart nginx</span><br><span class="line"><span class="comment"># 强迫症非要nginx首页如我的话，我直接拷贝windows中nginx的index页到/usr/docker/nginx/html中了</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-1.png" alt="image-20200402204959612"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-2.png" alt="image-20200402205847973"></p>
<h3 id="到这nginx容器启动好了，下面启动vsftpd容器"><a href="#到这nginx容器启动好了，下面启动vsftpd容器" class="headerlink" title="到这nginx容器启动好了，下面启动vsftpd容器"></a>到这nginx容器启动好了，下面启动vsftpd容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取vsftpd镜像</span></span><br><span class="line">docker pull fauria/vsftpd</span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">docker run -d -v /usr/docker/vsftpd:/home/vsftpd \</span><br><span class="line">-p 20:20 -p 21:21 -p 21100-21110:21100-21110 \</span><br><span class="line">-e FTP_USER=root -e FTP_PASS=123456 \</span><br><span class="line">-e PASV_ADDRESS=192.168.137.100 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 \</span><br><span class="line">--name vsftpd --privileged=<span class="literal">true</span> --restart=always fauria/vsftpd</span><br><span class="line"><span class="comment">#开启20防火墙端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=20/tcp --permanent</span><br><span class="line"><span class="comment">#开启21防火墙端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=21/tcp --permanent</span><br><span class="line"><span class="comment">#开启21100-21110防火墙端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=21100-21110/tcp --permanent</span><br><span class="line"><span class="comment">#重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment">#查看防火墙已经启动的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker启动命令解释：</p>
<p>-v挂载目录，相当于把容器内目录挂载到本地</p>
<p>-p 端口映射本地20容器20   ….等等</p>
<p>-e 分别设置用户名、密码、宿主机地址、最小最大端口</p>
<p>–name 命名容器为vsftpd</p>
<p>–privileged=true 给容器root权限</p>
<p>–restart=always 随docker开启而自启动</p>
<p>fauria/vsftpd  运行的run的这个名字的镜像</p>
</blockquote>
<ul>
<li><p>打开浏览器访问<code>ftp://192.168.137.100</code></p>
</li>
<li><p>至此文件服务器搭建成功</p>
</li>
<li><p>将新的FTP用户添加到现有容器中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it vsftpd bash</span><br><span class="line"><span class="comment"># 新建myuser用户的文件夹</span></span><br><span class="line">mkdir /home/vsftpd/myuser</span><br><span class="line"><span class="comment"># 添加新用户myuser换行密码5678写入文件中</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"myuser\n5678"</span> &gt;&gt; /etc/vsftpd/virtual_users.txt</span><br><span class="line"><span class="comment"># 密码写入数据库</span></span><br><span class="line">/usr/bin/db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/virtual_users.txt /etc/vsftpd/virtual_users.db</span><br><span class="line"><span class="comment"># 退出容器内部</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 重启vsftpd</span></span><br><span class="line">docker restart vsftpd</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>通过nginx访问到静态资源服务器中的图片了<code>http://192.168.16.128/images/test.png</code></li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-3.png" alt="image-20200402211508955"></p>
<ul>
<li><p>用nginx是方便我们使用http协议访问静态资源服务器</p>
</li>
<li><p>其实只需要安装vsftpd就能ftp协议上传图片了，浏览器访问<code>ftp://192.168.16.128</code>,填写我们之前设置的用户名<code>root</code> 密码<code>5678</code></p>
</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-4.png" alt="image-20200402211957464"></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>nginx</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会读书笔记（3）</title>
    <url>/article/970ccb5d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="21-创建和操纵表"><a href="#21-创建和操纵表" class="headerlink" title="21.创建和操纵表"></a>21.创建和操纵表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t_class&#96; </span><br><span class="line">(</span><br><span class="line">	&#96;id&#96; INT NOT NULL Auto_Increment, </span><br><span class="line">	&#96;name&#96; VARCHAR ( 20 ) NOT NULL, </span><br><span class="line">	PRIMARY KEY ( &#96;id&#96; ) </span><br><span class="line">) ENGINE &#x3D; INNODB;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>创建表的时候，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有表，mysql要求先手动删除该表，然后再重建他，而不是用简单的创建表语句覆盖它。<br>如果你仅仅想在一个表不存在时创建他，应该在表名后给出<code>IF NOT EXISTS</code></p>
</blockquote>
<h3 id="理解NULL值"><a href="#理解NULL值" class="headerlink" title="理解NULL值"></a>理解NULL值</h3><blockquote>
<p>NULL值是没有值，不是空字符串<code>&#39;&#39;</code>,空字符串代表有值，空字符串会被NOT NULL接收。</p>
</blockquote>
<h3 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h3><blockquote>
<p>①AUTO_INCREMENT 每个表只允许一个自增列，而且他必须被索引（如，通过使它成为主键）<br>②如果一个列被指定为自增，那么他需要特殊的值吗？你可以在insert语句中指定任意一个值，只要他是唯一的且至今未被使用过的即可，该值将被用于代替自动生成的值。后续的增量将开始使用该收工插入的值。<br>③如何在插入之后获取自增的值呢？<code>select last_insert_id()</code>函数将获取最后一个自增的值。</p>
</blockquote>
<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><blockquote>
<p>为了更新表定义，可以使用<code>ALTER  TABLE</code>语句。但是理想的状态下，当表中存储数据以后，该表就不应该再被更新定义，在表的设计过程中需要花费大量时间来考虑，一边后期不对该表进行大的更改。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给表添加一个列</span><br><span class="line">ALTER TABLE &#96;t_class&#96; ADD &#96;create_time&#96; datetime;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除刚才添加的列</span><br><span class="line">ALTER TABLE &#96;t_class&#96; DROP COLUMN &#96;create_time&#96;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给&#96;name&#96;列添加一个索引</span><br><span class="line">ALTER TABLE &#96;t_class&#96; ADD INDEX index_name ( &#96;name&#96; );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意小心使用ALTER TABLE,应该在进行改动前进行完整的备份，数据库表的更改不能插销，如果增加了不必要的列，可能不能删除他们，相应的如果删除了不应该删除的列，可能会丢失该列的全部数据。</p>
</blockquote>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE   &#96;表名&#96;;</span><br></pre></td></tr></table></figure>
<h3 id="重命名表-多个表用逗号隔开"><a href="#重命名表-多个表用逗号隔开" class="headerlink" title="重命名表(多个表用逗号隔开)"></a>重命名表(多个表用逗号隔开)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE &#96;t_class&#96; TO &#96;my_class&#96;;</span><br></pre></td></tr></table></figure>

<h2 id="22-使用视图"><a href="#22-使用视图" class="headerlink" title="22.使用视图"></a>22.使用视图</h2><h3 id="理解视图"><a href="#理解视图" class="headerlink" title="理解视图"></a>理解视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 首先来看一个sql,查询学生，班级名称，成绩等字段</span><br><span class="line">SELECT</span><br><span class="line">	t1.name,</span><br><span class="line">	t1.score,</span><br><span class="line">	t2.name className</span><br><span class="line"></span><br><span class="line">FROM</span><br><span class="line">	student t1</span><br><span class="line">	LEFT JOIN t_class t2 ON t1.class_id &#x3D; t2.id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在把整个查询包装成一个名为studentclass的虚拟表，则可以如下轻松的检索出相同的数据.<br>这就是视图的作用，studentclass是一个视图，作为视图它不包含表中应该有的任何列或数据，它包含的是一个SQL查询。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name, score, className from studentclass;</span><br></pre></td></tr></table></figure>

<h3 id="为什么使用视图？"><a href="#为什么使用视图？" class="headerlink" title="为什么使用视图？"></a>为什么使用视图？</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-0.png" alt="图片"></p>
<h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><blockquote>
<p>①与表一样，视图必须唯一命名，不能跟已有的表或视图重名。<br>②对于可以创建的视图的数量没有限制。<br>③为了创建视图必须具有足够的权限。<br>④视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。<br>⑤order by可以用在视图中，但是如果从该视图检索数据select语句中也有order by，会覆盖视图中的order by<br>⑥视图不能索引，也不能有关联的触发器或默认值。<br>⑦视图可以和表一起使用，例如编写一条联结表和视图的select 语句。</p>
</blockquote>
<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><blockquote>
<p>①视图用<code>create view</code>语句来创建<br>②使用<code>show create view viewname;</code> 来查看创建视图的语句；<br>③用<code>drop</code>删除视图，可以先drop 再create,也可以直接使用<code>create or replace view</code>,如果更新的视图不存在则创建一个，存在则替换原来的视图。</p>
</blockquote>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如，本章开始理解视图的那个sql可以如下，创建或更新视图studentclass</span><br><span class="line">CREATE </span><br><span class="line">	OR REPLACE VIEW studentclass AS SELECT</span><br><span class="line">	t1.&#96;name&#96;,</span><br><span class="line">	t1.score,</span><br><span class="line">	t2.&#96;name&#96; className </span><br><span class="line">FROM</span><br><span class="line">	student t1</span><br><span class="line">	LEFT JOIN t_class t2 ON t1.class_id &#x3D; t2.id;</span><br><span class="line"></span><br><span class="line">-- 然后从创建的视图中查询结果</span><br><span class="line">SELECT</span><br><span class="line">	&#96;name&#96;,</span><br><span class="line">	score,</span><br><span class="line">	className </span><br><span class="line">FROM</span><br><span class="line">	studentclass;</span><br></pre></td></tr></table></figure>
<h3 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如我们需要得到&#96;姓名-班级名-分数&#96;这样格式的数据，可以如下实现</span><br><span class="line">SELECT</span><br><span class="line">	CONCAT( t1.&#96;name&#96;, &#39;-&#39;, t2.&#96;name&#96;, &#39;-&#39;, t1.score ) AS &#96;data&#96; </span><br><span class="line">FROM</span><br><span class="line">	student t1</span><br><span class="line">	LEFT JOIN t_class t2 ON t1.class_id &#x3D; t2.id;</span><br><span class="line"></span><br><span class="line">-- 假如我们经常需要这个格式的结果，则可以创建一个视图，需要的时候使用它即可。</span><br><span class="line">CREATE </span><br><span class="line">	OR REPLACE VIEW &#96;my_format&#96; AS SELECT</span><br><span class="line">	CONCAT( t1.&#96;name&#96;, &#39;-&#39;, t2.&#96;name&#96;, &#39;-&#39;, t1.score ) AS &#96;data&#96; </span><br><span class="line">FROM</span><br><span class="line">	student t1</span><br><span class="line">	LEFT JOIN t_class t2 ON t1.class_id &#x3D; t2.id;</span><br><span class="line"></span><br><span class="line">-- 之后在查询这个格式的数据的时候就可以在试图中查询了</span><br><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	my_format;</span><br></pre></td></tr></table></figure>
<h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h3><blockquote>
<p>如果从视图检索数据时候使用了一条where子句，而视图中也有一个where子句，则两个子句将自动组合。</p>
</blockquote>
<h3 id="使用时突与计算字段"><a href="#使用时突与计算字段" class="headerlink" title="使用时突与计算字段"></a>使用时突与计算字段</h3><blockquote>
<p>例如查询购物车每种商品的总价，个数*单价，则可以先创建求购物车的每种商品总价视图，再用where过滤具体哪个购物车。</p>
</blockquote>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><blockquote>
<p>mysql允许更新视图，实际上是对基表增加或删除行，但是当视图中有以下操作，则不能进行视图的更新<br>①分组<code>group by ...having</code><br>②联结<br>③子查询<br>④并<br>⑤聚集函数<br>⑥distinct<br>⑦导出列<br>看起来很多试图都是不可更新的，像是一个很严重的限制，实际上就是，因为视图主要适用于数据检索的</p>
</blockquote>
<h2 id="23-使用存储过程"><a href="#23-使用存储过程" class="headerlink" title="23.使用存储过程"></a>23.使用存储过程</h2><blockquote>
<p>###调用存储过程<br>mysql称存储过程的执行为调用，mysql调用存储过程需要用到<code>CALL</code>关键字。<br><code>CALL</code>接受存储过程的名字以及需要传递给他的任意参数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如，调用存储过程studentscore,它计算返回学生表所有行成绩的最低分、最高分、平均分</span><br><span class="line">CALL studentscore (@scorelow, @scorehigh, @scoreavg);</span><br></pre></td></tr></table></figure>

<h3 id="创建及调用存储过程"><a href="#创建及调用存储过程" class="headerlink" title="创建及调用存储过程"></a>创建及调用存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- mysql默认分隔符为分号 ; 这里修改成 $（注意不能修改为 \ ）</span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储过程studentscore()，不带输入输出参数</span><br><span class="line">CREATE PROCEDURE studentscore ( ) </span><br><span class="line">-- 存储过程开始</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT</span><br><span class="line">		AVG( score ) AS scoreavg </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line">-- 存储过程结束	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">-- 把mysql默认分隔符改回 ;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用刚才新建的存储过程studentscore()</span><br><span class="line">CALL studentscore();</span><br></pre></td></tr></table></figure>

<h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除存储过程</span><br><span class="line">DROP PROCEDURE studentscore;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 更严谨一点，仅当存在时候删除存储过程studentscore</span><br><span class="line">DROP PROCEDURE</span><br><span class="line">IF</span><br><span class="line">	EXISTS studentscore;</span><br></pre></td></tr></table></figure>

<h3 id="使用存储过程参数"><a href="#使用存储过程参数" class="headerlink" title="使用存储过程参数"></a>使用存储过程参数</h3><blockquote>
<p>关键字<code>out</code>用来指定从存储过程传出一个值（返回给调用者）<br>关键字<code>in</code>用来传递给存储过程一个参数<br>关键字<code>inout</code>用来指定对存储过程传入和传出类型的参数<br>存储过程的代码位于<code>begin</code>和<code>end</code>之间<br>存储过程可以是一个select语句然后把检索的值通过<code>into</code>关键字指定到相应变量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储并返回sl,sh,sa三个参数</span><br><span class="line">CREATE PROCEDURE studentscore (</span><br><span class="line">	OUT sl DECIMAL ( 8, 2 ),</span><br><span class="line">	OUT sh DECIMAL ( 8, 2 ),</span><br><span class="line">	OUT sa DECIMAL ( 8, 2 ) </span><br><span class="line">	) </span><br><span class="line">	-- 开始存储过程</span><br><span class="line">	BEGIN</span><br><span class="line">	</span><br><span class="line">	-- 查询成绩最低的存到sl参数</span><br><span class="line">	SELECT</span><br><span class="line">		MIN( score ) INTO sl </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line">	-- 查询成绩最高的存到sh参数</span><br><span class="line">	SELECT</span><br><span class="line">		max( score ) INTO sh </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line">	-- 查询成绩平均值的存到sa参数</span><br><span class="line">	SELECT</span><br><span class="line">		avg( score ) INTO sa </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line"></span><br><span class="line">-- 存储过程结束</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">delimiter;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程，用@开始的三个变量接收存储过程返回的三个值，在调用时，这条语句并不显示任何数据，为了显示这几个变量需要进行如下查询</span><br><span class="line">CALL studentscore(@sl, @sh, @sa);</span><br><span class="line"></span><br><span class="line">-- 为了显示三个存储过程返回的变量需要执行的查询</span><br><span class="line">SELECT</span><br><span class="line">	@sl AS scorelow,</span><br><span class="line">	@sh AS scorehigh,</span><br><span class="line">	@sa AS scoreavg;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-1.png" alt="查询结果"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储过程接收inid参数，返回outscore参数</span><br><span class="line">CREATE PROCEDURE queryscorebyid ( </span><br><span class="line">	IN inid INT, </span><br><span class="line">	OUT outscore DECIMAL ( 8, 2 ) </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">-- 开始存储过程</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">-- 根据学生id查询学生成绩</span><br><span class="line">	SELECT</span><br><span class="line">		score </span><br><span class="line">	FROM</span><br><span class="line">		student </span><br><span class="line">	WHERE</span><br><span class="line">		id &#x3D; inid INTO outscore;</span><br><span class="line"></span><br><span class="line">-- 存储过程结束</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">delimiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 调用存储过程，输入参数1，返回参数@outscore,相当于查询id&#x3D;1的学生成绩</span><br><span class="line">CALL queryscorebyid(1, @outscore);</span><br><span class="line">-- 查询@outscore参数的值</span><br><span class="line">select @outscore;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-2.png" alt="返回结果"></p>
<h3 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h3><blockquote>
<p>迄今为止，上边介绍的存储过程全是简单查询的存储过程，实际上存储过程是为了实现更加复杂的业务规则处理使用的。<br>考虑这个场景。你需要获得与以前一样的订单合计，但需要对合计增加营业税，不过只针对某些顾客（或许是你所在州中那些顾客）。那么，你需要做下面几件事情：<br>1、获得合计（和以前一样）<br>2、把营业税有条件的添加到合计<br>3、返回合计（带或不带税的）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Name: ordertotal        &#x2F;&#x2F;   添加注释</span><br><span class="line">-- Parameters: onumber &#x3D; order number</span><br><span class="line">--             taxable &#x3D; 0 if not taxable, 1 if taxtable</span><br><span class="line">--             ototal &#x3D; order total variable</span><br><span class="line"></span><br><span class="line">CREATE     PROCEDURE ordertotal (</span><br><span class="line">IN onumber INT,</span><br><span class="line">IN taxable BOOLEAN,</span><br><span class="line">OUT ototal DECIMAL(8,2)</span><br><span class="line">) COMMENT &#39;Obtain order total, optionally adding tax&#39;</span><br><span class="line">BEGIN</span><br><span class="line">    </span><br><span class="line">        -- Declare variable for total</span><br><span class="line">        DECLARE total DECIMAL(8,2);     &#x2F;&#x2F;   声明变量   </span><br><span class="line">        -- Declare tax percentage</span><br><span class="line">        DECLARE taxrate INT DEFAULT 6;</span><br><span class="line">        </span><br><span class="line">        -- Get the order total</span><br><span class="line">        SELECT Sum(item_price*quantity)</span><br><span class="line">        FROM orderitems</span><br><span class="line">        WHERE order_num &#x3D; onumber</span><br><span class="line">        INTO total;</span><br><span class="line">        </span><br><span class="line">        -- Is this taxable?</span><br><span class="line">        IF taxable THEN</span><br><span class="line">            -- yes,so add taxrate to the total</span><br><span class="line">            SELECT total+(total&#x2F;100*taxrate) INTO total;</span><br><span class="line">        END IF;</span><br><span class="line">        --  And finally, save to out variable</span><br><span class="line">        SELECT total INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此存储过程有很大的变动。首先，增加了注释（前面放置 –）。在存储过程复杂性增加时，这样做特别重要。<br>添加了另外一个参数 taxable，它是一个布尔值（如果要增加税则为真，否则为假）。<br>在存储过程体中，用 DECLARE语句定义了两个局部变量。 DECLARE要求指定变量名和数据类型，<br>它也支持可选的默认值（这个例子中的 taxrate的默认被设置为 6%）。SELECT 语句变，因此其结果存储到 total（局部变量）而不是 ototal。<br>IF 语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量 total。<br>最后，用另一SELECT语句将total（它增加或许不增加营业税）保存到 ototal。<br>注意：COMMENT关键字 ，本例子中的存储过程在 CREATE PROCEDURE语句中包含了一个 COMMENT值。<br>它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示。</p>
</blockquote>
<p>这显然是一个更高级，功能更强的存储过程。为试验它，请用以下两条语句：<br>第一条：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call ordertotal(20005, 0, @total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>
<p>第二条：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call ordertotal(20009, 1，@total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BOOLEAN值指定为1 表示真，指定为 0表示假（实际上，非零值都考虑为真，只有 0被视为假）。通过给中间的参数指定 0或1 ，可以有条件地将营业税加到订单合计上。</p>
</blockquote>
<blockquote>
<p>这个例子给出了 MySQL的IF 语句的基本用法。 IF语句还支持 ELSEIF和ELSE 子句（前者还使用 THEN子句，后者不使用）。在以后章节中我们将会看到 IF的其他用法（以及其他流控制语句）。</p>
</blockquote>
<h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 显示创建存储过程的语句</span><br><span class="line">SHOW CREATE PROCEDURE studentscore;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-3.png" alt="显示的结果"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 为了显示何时？ 由谁创建了存储过程？</span><br><span class="line">SHOW PROCEDURE STATUS;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-4.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表比较多，用like过滤存储过程</span><br><span class="line">SHOW PROCEDURE STATUS LIKE &#39;studentscore&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-5.png" alt="image.png"></p>
<h2 id="24-使用游标"><a href="#24-使用游标" class="headerlink" title="24.使用游标"></a>24.使用游标</h2><blockquote>
<p>游标是一个存储在mysql服务器上的数据库查询，他不是一条select语句，而是被该语句检索出来的结果集，在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。<br><code>不像多数DBMS，mysql的游标只能用于存储过程和函数。</code></p>
</blockquote>
<h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><blockquote>
<p>使用游标涉及几个明确的步骤：<br>①在能够使用游标前，必须声明它，这个过程实际并没有检索数据，他只是定义要使用的select语句。<br>②一旦声明后，必须打开游标以供使用。这个过程用前面定义的select语句吧数据实际检索出来。<br>③对于填写有数据的游标，根据需要检索各行。<br>④在结束游标使用时，必须关闭游标。<br>⑤在声明游标后，可根据需要频繁的打开和关闭游标。在油表打开后，可根据需要频繁的执行取操作。</p>
</blockquote>
<h3 id="创建游标-打开和关闭游标"><a href="#创建游标-打开和关闭游标" class="headerlink" title="创建游标,打开和关闭游标"></a>创建游标,打开和关闭游标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储过程studentscore()</span><br><span class="line">CREATE PROCEDURE studentscore ( )</span><br><span class="line"></span><br><span class="line">-- 存储过程开始</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">	-- 声明游标queryscore从下面的select中</span><br><span class="line">	DECLARE</span><br><span class="line">		queryscore CURSOR FOR</span><br><span class="line">		</span><br><span class="line">	SELECT</span><br><span class="line">		score </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line"></span><br><span class="line">    -- 打开刚才声明的游标</span><br><span class="line">	OPEN queryscore;</span><br><span class="line">	</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE queryscore;</span><br><span class="line">		</span><br><span class="line">-- 存储过程结束	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">delimiter;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在一个游标关闭后，如果不重新打开，则无法使用它，声明过的游标不需要再次声明，打开它就可以使用了。</p>
</blockquote>
<h3 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储过程studentscore()</span><br><span class="line">CREATE PROCEDURE studentscore ( OUT abc INT) </span><br><span class="line"></span><br><span class="line">-- 存储过程开始</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">	-- 声明一个本地参数</span><br><span class="line">	DECLARE myscore INT;</span><br><span class="line"></span><br><span class="line">	-- 声明游标queryscore从下面的select中</span><br><span class="line">	DECLARE</span><br><span class="line">		queryscore CURSOR FOR</span><br><span class="line">		</span><br><span class="line">	SELECT</span><br><span class="line">		score </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line">		</span><br><span class="line">	-- 打开刚才声明的游标</span><br><span class="line">	OPEN queryscore;</span><br><span class="line">	</span><br><span class="line">	-- 从游标中检索单个行，第一行</span><br><span class="line">	FETCH queryscore INTO myscore;</span><br><span class="line">	-- 设置返回参数 &#x3D; 本地参数myscore</span><br><span class="line">	SET abc :&#x3D; myscore;</span><br><span class="line">	</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE queryscore;</span><br><span class="line">		</span><br><span class="line">-- 存储过程结束</span><br><span class="line">	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">delimiter;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL studentscore(@abc);</span><br><span class="line"></span><br><span class="line">-- 查询返回值@abc</span><br><span class="line">SELECT @abc;</span><br></pre></td></tr></table></figure>
<h2 id="25-使用触发器"><a href="#25-使用触发器" class="headerlink" title="25.使用触发器"></a>25.使用触发器</h2><blockquote>
<p>mysql语句在需要被执行时执行，存储过程也是如此，但是如果你想要某条语句在事件发生时自动执行，例如：①用户订购一个产品，在库存中减少相应数量<br>②无论何时删除一行，都在存档表中保留一个副本<br>③每添加一个顾客，都检查他的手机号码格式时候正确</p>
</blockquote>
<p><strong>所有以上这些例子共同之处就是需要某个表发生更改时候自动处理，这确切的说就是触发器，触发器是相应增删改而自动执行的一条mysql语句，（或位于begin和end之间的一组语句）</strong></p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><blockquote>
<p>①唯一的触发器名<br>②触发器关联的表<br>③触发器应该相应的活动（delete/insert/update）<br>④触发器或是执行（处理之前或处理之后）</p>
</blockquote>
<blockquote>
<p>触发器在mysql5中是以表为分界触发器名在表中必须唯一，这一点在其他DBMS中是不允许的，而且以后的MySQL版本很可能会使命名规则更为严格。因此，现在最好是在数据库范围内使用唯一的触发器名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 如书上这么写会报错1415 - Not allowed to return a result set from a trigger，</span><br><span class="line">-- 因为mysql5之后不支持mysql返回结果集</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER newclass AFTER INSERT ON t_class FOR EACH ROW</span><br><span class="line">SELECT</span><br><span class="line">	&#39;插入成功&#39;;</span><br><span class="line"></span><br><span class="line">-- 所以把如上写法加上into @ee把结果赋值给ee参数就可以了</span><br><span class="line">-- 解释：创建触发器名为newclass，触发器在t_class表每一行的插入之后执行查询 插入成功 赋值给 @ee</span><br><span class="line">CREATE TRIGGER newclass AFTER INSERT ON t_class FOR EACH ROW</span><br><span class="line">SELECT</span><br><span class="line">	&#39;插入成功&#39; into @ee;</span><br><span class="line"></span><br><span class="line">-- 插入</span><br><span class="line">INSERT INTO t_class ( id, &#96;name&#96; )</span><br><span class="line">VALUES</span><br><span class="line">	( 5, &#39;摄影班&#39; );</span><br><span class="line"></span><br><span class="line">-- 查询@ee看是否有值为 插入成功	</span><br><span class="line">select @ee;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-6.png" alt="image.png"></p>
<blockquote>
<p>仅支持表，只有表才支持触发器，视图不支持，临时表也不支持。触发器每个表每个事件每次只允许一个触发器，因此每个表最多支持6个触发器，insert之前之后、update之前之后、delete之前之后，并且单一触发器不能与多个事件和多个表关联。</p>
</blockquote>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p><strong>触发器不能更新或者覆盖，因此想要修改一个触发器，必须先删除它</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除刚才创建的触发器newclass</span><br><span class="line">drop trigger newclass;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-7.png" alt="image.png"></p>
<h3 id="删除触发器-1"><a href="#删除触发器-1" class="headerlink" title="删除触发器"></a>删除触发器</h3><blockquote>
<p>①在删除触发器代码内，亦可以引用一个名为OLD的虚拟表，访问将要被删除的行。<br>②OLD的值全部是只读的，不能更新。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建触发器deleteclass 在删除t_class表的每行之前执行，执行查询将要删除的t_class的name赋值给@deleteName变量</span><br><span class="line">CREATE TRIGGER deleteclass BEFORE DELETE ON t_class FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT</span><br><span class="line">		OLD.NAME INTO @deleteName;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 查询变量@deleteName为空</span><br><span class="line">SELECT @deleteName;</span><br><span class="line"></span><br><span class="line">-- 删除t_class表的一条数据</span><br><span class="line">DELETE FROM t_class where id&#x3D;5;</span><br><span class="line"></span><br><span class="line">-- 再次查询变量@deleteName</span><br><span class="line">SELECT @deleteName;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-8.png" alt="image.png"></p>
<h3 id="update触发器"><a href="#update触发器" class="headerlink" title="update触发器"></a>update触发器</h3><blockquote>
<p>①在update触发器中亦可以引用一个OLD的虚拟表，访问更新前的值，引用一个NEW的虚拟表访问更新后的值<br>②在BEFORE UPDATE触发器中，new中的值可能被更新（允许在触发器中更新将要用于更新的值）<br>③OLD中的值全部是只读的</p>
</blockquote>
<blockquote>
<p>mysql的触发器中不能调用存储过程，也就是不能用CALL，如果想要使用存储过程，需要复制存储过程代码到触发器内。</p>
</blockquote>
<h2 id="26-管理事务处理"><a href="#26-管理事务处理" class="headerlink" title="26.管理事务处理"></a>26.管理事务处理</h2><h3 id="1-事务处理"><a href="#1-事务处理" class="headerlink" title="1.事务处理"></a>1.事务处理</h3><blockquote>
<p>并非是所有的数据库引擎都支持数据处理，<code>MyISAM</code>和<code>InnoDB</code>是mysql中最常使用的两种引擎，前者不支持事务处理，而后者支持。事务处理用来维护数据库的完整性，他保证成批的mysql操作要么完全执行，要么完全不执行。</p>
</blockquote>
<h3 id="2-控制事务处理"><a href="#2-控制事务处理" class="headerlink" title="2.控制事务处理"></a>2.控制事务处理</h3><p>管理事务处理的关键在于将SQL语句组分解为逻辑块，病明确规定数据何时应该回退，何时不应该回退。</p>
<p>mysql使用下面的语句来标识事务的开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure>

<p>mysql的<code>Rollback</code> 命令用来回退mysql语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询所有学生</span><br><span class="line">SELECT * FROM t_student;</span><br><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line">-- 删除所有学生</span><br><span class="line">delete from t_student;</span><br><span class="line">-- 查询所有学生（已删除）</span><br><span class="line">select * from t_student;</span><br><span class="line">-- 回退</span><br><span class="line">Rollback;</span><br><span class="line">-- 查询所有学生（删除的已经回来了）</span><br><span class="line">select * from t_student;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显然，<code>rollback</code>只能够在一个事务处理之内使用（在事务开始之后使用）</p>
</blockquote>
<p>哪些语句不能回退？</p>
<ul>
<li><code>select</code>回退查询没有意义</li>
<li><code>create</code>和<code>drop</code>这两个关键字执行完毕后不可以回退，即使执行回退，也不会被撤销。</li>
</ul>
<h3 id="3-使用commit"><a href="#3-使用commit" class="headerlink" title="3.使用commit"></a>3.使用<code>commit</code></h3><p>一般的sql语句都是默认执行隐式的提交的，但是在事务中，不会进行隐式的提交，为了明确提交操作，可以使用<code>commit</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line">delete from student where id &#x3D; 1;</span><br><span class="line">delete from student where id &#x3D; 2;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例如上面的事务处理，首先如果两条数据都能够删除成功，则执行commit提交事务，如果任意一条删除失败则不会提交事务，会被自动撤销。</p>
<p>当执行<code>commit</code>和<code>rollback</code>之后，事务会自动关闭，之后的sql默认隐式的提交。</p>
</blockquote>
<h3 id="4-使用保留点"><a href="#4-使用保留点" class="headerlink" title="4.使用保留点"></a>4.使用保留点</h3><p>简单的事务处理可以使用<code>Rollback</code>或者<code>commit</code>回退或提交整个事务，但是复杂的事务操作往往需要我们只回退一部分事务，这就需要在事务处理块中合适的位置放置<code>占位符</code>这样如果需要回退操作，可以回退到某个占位符。这些占位符被称为<code>保留点</code>为了创建占位符，可使用<code>savepoint</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 每个保留点都取一个唯一的名字，以便回退的时候精准定位回退到何处</span><br><span class="line">savepoint &#96;delete-1&#96;;</span><br><span class="line">-- 回退到delete-1保留点</span><br><span class="line">rollback to &#96;delete-1&#96;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>保留点越多越好？</p>
<p>是这样的，因为保留点越多你越能够按照自己的意愿灵活的进行回退。</p>
<p>保留点在事务处理完成，执行一条Rollback或者commit之后自动释放。自mysql5以来，也可以使用<code>release savepoint</code>关键字明确的释放保留点。</p>
</blockquote>
<h3 id="5-更改默认的提交行为"><a href="#5-更改默认的提交行为" class="headerlink" title="5.更改默认的提交行为"></a>5.更改默认的提交行为</h3><p>正如上面所述：mysql默认行为是自动提交的，如果要修改不自动提交，可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">-- autocommit标志决定是否自动提交更改，设置为0之后，不自动提交，直到使用commit提交或者设置autocommit&#x3D;1</span><br></pre></td></tr></table></figure>

<h2 id="27-全球化和本地化"><a href="#27-全球化和本地化" class="headerlink" title="27.全球化和本地化"></a>27.全球化和本地化</h2><h3 id="1-字符集和校对顺序"><a href="#1-字符集和校对顺序" class="headerlink" title="1.字符集和校对顺序"></a>1.字符集和校对顺序</h3><p>数据库用来存储和检索数据，不同语言和字符集需要以不同的方式进行存储和检索，因此mysql需要适应不同的字符集。</p>
<ul>
<li>字符集：字母和符号的集合；</li>
<li>编码：为某个字符集成员的内部表示；</li>
<li>校对：为规定字符如何比较的指令。</li>
</ul>
<blockquote>
<p>简而言之，就是例如大小写，不同语言，日语、俄语、法语等等之间的排序问题，由字符集来控制。</p>
</blockquote>
<h3 id="2-使用字符集和校对顺序"><a href="#2-使用字符集和校对顺序" class="headerlink" title="2.使用字符集和校对顺序"></a>2.使用字符集和校对顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询mysql支持的所有字符集</span><br><span class="line">show character set;</span><br><span class="line">-- 查看所支持校对的完整列表</span><br><span class="line">show collation;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此语句显示所有可用校对，以及他们适用的字符集，例如：<code>latin1</code>对不同的欧洲语言有几种校对，而许多校对出现两次，一次区分大小写 <code>_cs</code> 表示，一次不区分大小写 <code>_ci</code> 表示</p>
</blockquote>
<p>为了查询所用的字符集和校对：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询所用字符集</span><br><span class="line">show variables like &#39;character%&#39;;</span><br><span class="line">-- 所用校对</span><br><span class="line">show variables like &#39;collation%&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，字符集很少是服务器或者数据库层面的设置，不同的表，甚至不同的列都有可能需要不同的字符集，而且两者都可以在创建表的时候指定。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table mytable</span><br><span class="line">(</span><br><span class="line">	column1 int,</span><br><span class="line">    column2 varchar(10) character set latin1 collate latin1_general_ci</span><br><span class="line">) default character set utf8</span><br><span class="line">collate utf8_general_ci;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这个例子既指定了字符集，还指定了校对，</p>
<p>如果只指定字符集，则使用它的默认校对，如<code>show character set;</code>查询到的默认校对，</p>
<p>如果都不指定，则使用数据库的默认</p>
<p>上图还指定了column2这一列应该使用的字符集和校对。</p>
</blockquote>
<p>如前所述，校对在对用order by 的字句检索出来的数据排序其非常重要的作用，如果你需要用与创建表时候不同的校对排序特定的select语句，你可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在不区分大小写的表中临时区分大小写进行查询</span><br><span class="line">select * from student order by lastname, firstname Collate utf8_general_cs;</span><br></pre></td></tr></table></figure>

<ul>
<li>select 的其他collate字句， Collate临时在select中改变校对顺序还可以用于group by、having、聚合函数、别名等。</li>
<li>值得注意的是，如果绝对需要，串可以在字符集之间进行转换。为此，使用cast()或者convert()函数。</li>
</ul>
<h2 id="28-安全管理"><a href="#28-安全管理" class="headerlink" title="28.安全管理"></a>28.安全管理</h2><h3 id="1-访问控制"><a href="#1-访问控制" class="headerlink" title="1.访问控制"></a>1.访问控制</h3><p>MySQL的服务器的安全基础是，用户应该对他们需要的数据具有适当的访问权，既不能多，也不能少。我们都知道为了执行数据库操作，需要登录，一般我们总是习惯直接使用root用户进行操作，他对整个数据库具有完全控制权限，这在学习中是可以的，但是在现实生产环境中，绝对不能使用root,应该创建一系列账号，有的用于管理，有的用于用户使用，有的用于开发人员开发，等等。</p>
<h3 id="2-管理用户"><a href="#2-管理用户" class="headerlink" title="2.管理用户"></a>2.管理用户</h3><p>mysql的用户账号和信息存储在名为mysql的数据库表中，一般不需要直接访问，但是有时候需要直接访问，直接访问的契机之一是需要获得所有用户账号列表，为此可以写出下面的sql:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用mysql数据库</span><br><span class="line">USE &#96;mysql&#96;;</span><br><span class="line">-- 查询user字段从user表</span><br><span class="line">select user from &#96;user&#96;;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-9.png" alt="image-20200324202553530"></p>
<h4 id="2-1创建用户账号"><a href="#2-1创建用户账号" class="headerlink" title="2.1创建用户账号"></a>2.1创建用户账号</h4><p>创建用户账号可以使用<code>create user</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建新的用户yunqing密码是123456</span><br><span class="line">CREATE USER yunqing IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">-- 查询所用用户</span><br><span class="line">SELECT USER FROM USER;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-10.png" alt="image-20200324203210472"></p>
<p>修改账户名和删除账户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 重命名账户</span><br><span class="line">RENAME USER yunqing TO qing;</span><br><span class="line">-- 删除账户</span><br><span class="line">DROP USER qing;</span><br></pre></td></tr></table></figure>

<h4 id="2-2设置访问权限"><a href="#2-2设置访问权限" class="headerlink" title="2.2设置访问权限"></a>2.2设置访问权限</h4><p>在创建新用户之后，必须接着分配访问权限，新账户没有访问权限，他们能够登陆mysql但是不能看到任何数据，不能执行任何数据操作。为了查看账户权限可以使用关键字<code>show grants for</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-11.png" alt="image-20200324204323504"></p>
<p>输出的结果显示yunqing账户有一个权限<code>USAGE ON  *.*</code>  .USAGE表示没有任何权限。所以此结果表示的是任意数据库任意表上对任何数据没有权限。</p>
<p>如果想要赋予用户权限，请使用<code>grant</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给yunqing账户赋予查询student的权限</span><br><span class="line">GRANT SELECT ON student.* TO yunqing;</span><br></pre></td></tr></table></figure>

<p><code>grant</code>的反操作是 <code>revoke</code>他用来撤销特定用户的特定权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给yunqing账户撤销查询student的权限</span><br><span class="line">REVOKE SELECT ON kls.* FROM yunqing;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>grant</code>和<code>revoke</code>可以在几个层次上控制访问权限</li>
</ul>
<ol>
<li>整个服务器，使用<code>GRANT ALL</code>和<code>REVOKE ALL</code>;</li>
<li>整个数据库，使用<code>on database.*</code>;</li>
<li>特定的表，使用<code>on database.table</code>;</li>
<li>特定的列；</li>
<li>特定的存储过程</li>
</ol>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-12.png" alt="image-20200324210645930"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-13.png" alt="image-20200324210727050"></p>
<h4 id="2-3更改口令"><a href="#2-3更改口令" class="headerlink" title="2.3更改口令"></a>2.3更改口令</h4><p>为了更改用户密码，可以使用<code>set password</code>关键字，新的口令必须做如下加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 设置账户新密码，必须使用password()函数进行加密</span><br><span class="line">SET PASSWORD FOR yunqing &#x3D; PASSWORD(&#39;1234&#39;);</span><br></pre></td></tr></table></figure>

<ul>
<li>在不指定账户名时候，上面的语句可以更新当前登录用户的密码</li>
</ul>
<h2 id="29-数据库维护"><a href="#29-数据库维护" class="headerlink" title="29.数据库维护"></a>29.数据库维护</h2><h3 id="1-备份数据"><a href="#1-备份数据" class="headerlink" title="1.备份数据"></a>1.备份数据</h3><p>废话不多说，备份很重要，mysql基于磁盘文件，普通的备份系统和里程就能备份mysql的数据，但是由于这些文件总是处于打开和使用的状态，普通的文件副本备份不一定总是有效。</p>
<p>下面列出这个问题的可能解决方案：</p>
<ul>
<li>使用命令行实用程序mysqkdump转储所有数据库内容到某个外部文件。</li>
<li>可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）</li>
<li>可以使用mysql的BACKUP TABLE和select into outfile转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，这个文件必须存在，否则会出错，数据可以用restore table复原。</li>
</ul>
<blockquote>
<p>为了保证所有数据被写到磁盘，包括索引，可能需要在进行备份之前使用<code>flush tables</code>语句</p>
</blockquote>
<h3 id="2-进行数据库维护"><a href="#2-进行数据库维护" class="headerlink" title="2.进行数据库维护"></a>2.进行数据库维护</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 检查博鳌键是否正确</span><br><span class="line">analyze table student;</span><br><span class="line">-- 发现和修复表问题</span><br><span class="line">check table student,school;</span><br><span class="line">-- 检查子最后一次检查以来改动过的表</span><br><span class="line">changed</span><br><span class="line">-- 执行最彻底的检查</span><br><span class="line">extended</span><br><span class="line">-- 只检查未正常关闭的表</span><br><span class="line">fast</span><br><span class="line">-- 检查所有被删除的链接并进行键检查</span><br><span class="line">medium</span><br><span class="line">-- 只进行快速扫描</span><br><span class="line">quick</span><br><span class="line">-- 如果myISAM表访问产生不正确或不一致的结果，可以如下修复表,这个语句不应该经常使用，如果经常使用，可能会产生更大的问题需要解决</span><br><span class="line">repair table student;</span><br><span class="line">-- 如果一个表删除了大量数据，需要回收空间，优化表的性能</span><br><span class="line">optimize table student;</span><br></pre></td></tr></table></figure>

<h3 id="3-诊断启动问题"><a href="#3-诊断启动问题" class="headerlink" title="3.诊断启动问题"></a>3.诊断启动问题</h3><p>mysql服务器自身通过在命令行上执行<code>mysqld</code>启动，下面是几个重要的<code>mysqld</code>参数</p>
<ul>
<li>–help 显示帮助</li>
<li>–safe-mode装在减去某些最佳配置的服务器</li>
<li>–verbose显示全文本纤细（为了获取更详细的帮助信息与–help一起使用）</li>
<li>–version显示版本信息然后退出</li>
</ul>
<h3 id="4-查看日志文件"><a href="#4-查看日志文件" class="headerlink" title="4.查看日志文件"></a>4.查看日志文件</h3><ul>
<li>错误日志：它包含启动和关闭问题以及任意关键错误的细节，此日志通常名为hostname.err位于data目录中，此日志名可用–log-error命令行选项更改</li>
<li>查询日志：他记录所有mysql活动，在诊断问题时候非常有用。此日志很快会变得非常大，因此不应该长期使用它。此日志通常名为hostname.log位于data目录中，可用–log命令行选项更改</li>
<li>二进制日志：他记录更新过数据的所有语句，名为hostname.bin位于data目录，–log-bin进行更改。</li>
<li>缓慢查询日志：此日志记录执行缓慢的任何查询，这个日志对mysql优化有很大作用，通常名为<code>hostname-slow.log</code>位于data目录，可用<code>--log-slow-queries</code>命令行选项更改。</li>
<li>在使用日志时，可使用<code>flush logs</code>来刷新和重新开始所有日志文件。</li>
</ul>
<h2 id="30-改善性能"><a href="#30-改善性能" class="headerlink" title="30.改善性能"></a>30.改善性能</h2><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-14.png" alt="image-20200324213946593"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-15.png" alt="image-20200324214032975"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会读书笔记（2）</title>
    <url>/article/2fb0ac38.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="11-使用数据处理函数"><a href="#11-使用数据处理函数" class="headerlink" title="11.使用数据处理函数"></a>11.使用数据处理函数</h2><h3 id="常用的文本处理函数"><a href="#常用的文本处理函数" class="headerlink" title="常用的文本处理函数"></a>常用的文本处理函数</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-1.png" alt="22-2fb0ac38-1"></p>
<a id="more"></a>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-2.png" alt="22-2fb0ac38-2"></p>
<blockquote>
<p>对Soundex()做一个解释：此函数是对任意文本串转化成其发音的算法。所以只要是发音类似的结果都会被查询出来。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如学生名字为 Y.Lee录入的时候录入错误，录成 Y.Lie 这时候如下查找会查找不到。</span><br><span class="line">select name from student where name &#x3D; &#39;Y.Lee&#39;;</span><br><span class="line">#如下使用Soundex()函数就能查找出来</span><br><span class="line">select name from student where Soundex(name) &#x3D; Soundex(&#39;Y.Lee&#39;);</span><br></pre></td></tr></table></figure>
<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-3.png" alt="image.png"></p>
<blockquote>
<p>注意：当使用where条件搜索日期为某一天的记录时候，通常这样写…where date = ‘2020-02-02’;但是这种写法并不严谨，因为如果当数据库date类型为datetime的时候，表中数据会有时间值00:00:00则此时上面的写法就不严谨了，需要用时间处理函数取日期部分，我们可以这样写：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... where Date(date) &#x3D; &#39;2020-02-02&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例如：我们需要获取2020年2月份的所有订单？如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第一种解法：需要知道2月份有多少天，比如2020年闰年29天</span><br><span class="line">...where Date(order_date) between &#39;2020-02-01&#39;  and &#39;2020-02-29&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面用到between关键字，可以查询2月1到29号的2月份区间的订单，缺点是必须知道2月有多少天，所以我们可以如下写，根本不用关心2月份有多少天。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 注意用到了Year()函数和Month()函数</span><br><span class="line">...where Year(order_date) &#x3D; 2020 and Month(order_date) &#x3D; 2;</span><br></pre></td></tr></table></figure>
<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-4.png" alt="image.png"></p>
<h2 id="12-汇总数据"><a href="#12-汇总数据" class="headerlink" title="12.汇总数据"></a>12.汇总数据</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-5.png" alt="image.png"></p>
<blockquote>
<p>注意： AVG()函数只能求特定一列的平均值并且会忽略列值为NULL的行</p>
</blockquote>
<blockquote>
<p>COUNT(<em>)返回总行数，包含NULL值； COUNT(列名)返回总行数，不含NULL值； DISTINCT COUNT(</em>)返回总行数，去除重复且不含NULL值,COUNT(1)和count(*)返回结果一致。</p>
</blockquote>
<blockquote>
<p>Max()函数、Min()函数、Sum()函数都忽略列值为NULL的行</p>
</blockquote>
<h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><blockquote>
<p>正如标题字面意思聚集不同值即为把<code>distinct</code>关键字用于聚集函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 求不同价格商品的平均值</span><br><span class="line">select avg(distinct prod_price) from products;</span><br></pre></td></tr></table></figure>
<h2 id="13-分组数据"><a href="#13-分组数据" class="headerlink" title="13.分组数据"></a>13.分组数据</h2><p>关于Group by 分组的一些规定：<br>①group by 字句可以包含任意数量的列，这使得能对分组进行嵌套，为分组提供更细致的控制。<br>②如果在Group By子句中嵌套了分组,数据将在最后指定的分组上进行汇总。换句话说,在建立分组时，指定的所有列都一起计算(不能从个别的列中取回数据)。<br>③Group By子句中列出的每一列都必须是检索列(或者有效的表达式,注意不能是聚集函数)。如果在SELECT中使用了检索列(或者表达式),则在Group By子句中使用相同的表达式,不能使用别名。<br>④除聚集计算语句外,SELECT语句中的每一列都必须在Group By中给出。<br>⑤如果分组列中包含具有Null值的行,则Null将作为一个分组返回,如果列中有多行Null，他们将作为一个分组返回<br>⑥Group By必须出现在Where子句之后,Order By子句之前。</p>
<h3 id="WITH-ROLLUP-关键字进行分组汇总"><a href="#WITH-ROLLUP-关键字进行分组汇总" class="headerlink" title="WITH ROLLUP 关键字进行分组汇总"></a>WITH ROLLUP 关键字进行分组汇总</h3><blockquote>
<p>使用<code>with ROLLUP</code>关键字，可以得到每个分组以及每个分组汇总级别(针对每个分组)的值。如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	&#96;name&#96;,</span><br><span class="line">	count( * ) AS num </span><br><span class="line">FROM</span><br><span class="line">	student </span><br><span class="line">GROUP BY</span><br><span class="line">	&#96;name&#96; WITH ROLLUP;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-6.png" alt="image.png"></p>
<h3 id="对分组进行过滤-Having"><a href="#对分组进行过滤-Having" class="headerlink" title="对分组进行过滤 Having"></a>对分组进行过滤 Having</h3><blockquote>
<p>having是对分组后的数据进行过滤，而where是对分组之前的数据进行过滤。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	&#96;name&#96;,</span><br><span class="line">	count( * ) AS num </span><br><span class="line">FROM</span><br><span class="line">	student </span><br><span class="line">WHERE</span><br><span class="line">	&#96;name&#96; &lt;&gt; &#39;xm&#39; </span><br><span class="line">GROUP BY</span><br><span class="line">&#96;name&#96; </span><br><span class="line">HAVING</span><br><span class="line">	count( * ) &gt; 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>where过滤掉name=’xm’的数据，然后having再过滤掉出满足数量大于1的分组。</p>
</blockquote>
<blockquote>
<p>注意在使用<code>group by</code>进行分组的时候，也使用<code>order by</code>进行排序，这是保证数据正确排序的唯一方法，千万不要仅仅依赖<code>group by</code>排序数据。</p>
</blockquote>
<p>小结：列出select子句的顺序：<br><code>select</code><br><code>from</code><br><code>where</code><br><code>group by</code><br><code>having</code><br><code>order by</code><br><code>limit</code></p>
<h2 id="14-使用子查询"><a href="#14-使用子查询" class="headerlink" title="14.使用子查询"></a>14.使用子查询</h2><p>例如：从<code>customers</code>客户表中检索客户列表<br>对于检索出的每个客户，统计其在<code>orders</code>订单表中的订单数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#96;name&#96;，state,</span><br><span class="line">(select count(*) from orders where orders.cust_id &#x3D; customers.cust_id) as orders</span><br><span class="line">from customers </span><br><span class="line">order by &#96;name&#96;;</span><br></pre></td></tr></table></figure>
<h2 id="15-联表查询"><a href="#15-联表查询" class="headerlink" title="15.联表查询"></a>15.联表查询</h2><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>创建联结非常简单，规定要联结的表以及他们如何关联即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	t1.id,</span><br><span class="line">	t1.&#96;name&#96; className,</span><br><span class="line">	t2.&#96;name&#96; AS studentName,</span><br><span class="line">	t2.score </span><br><span class="line">FROM</span><br><span class="line">	t_class t1,</span><br><span class="line">	student t2 </span><br><span class="line">WHERE</span><br><span class="line">	t1.id &#x3D; t2.class_id </span><br><span class="line">ORDER BY</span><br><span class="line">	t1.id,</span><br><span class="line">	t2.score</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-7.png" alt="image.png"></p>
<blockquote>
<p>注意：联结表查询的联结条件很重要，上面这段sql的联结条件是where 班级表的id = 学生表的班级id<br>如果不写联结条件的话，就会生成<code>笛卡尔积</code>。<br><code>笛卡尔积</code>就是联结的两张表，用第一张表每一行去联结第二张表每一行，因为没有联结条件，所以就会生成<code>笛卡尔积</code><br>例如：上面的联结查询如果不写where联结条件的话,就会得到<code>笛卡尔积</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	t1.id,</span><br><span class="line">	t1.&#96;name&#96; className,</span><br><span class="line">	t2.&#96;name&#96; AS studentName,</span><br><span class="line">	t2.score </span><br><span class="line">FROM</span><br><span class="line">	t_class t1,</span><br><span class="line">	student t2 </span><br><span class="line">ORDER BY</span><br><span class="line">	t1.id,</span><br><span class="line">	t2.score</span><br></pre></td></tr></table></figure>
<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>目前为止所用的联结称为<code>等值联结</code>，它基于两个表之间的相等进行联结，这种联结也称为<code>内联</code>，对于这种联结可以使用一种新的推荐语法来写，就是<code>inner join ...  on</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 两个表的联结条件是ON</span><br><span class="line">SELECT</span><br><span class="line">	t1.id,</span><br><span class="line">	t1.&#96;name&#96; className,</span><br><span class="line">	t2.&#96;name&#96; AS studentName,</span><br><span class="line">	t2.score </span><br><span class="line">FROM</span><br><span class="line">	t_class t1</span><br><span class="line">	INNER JOIN student t2 ON t1.id &#x3D; t2.class_id </span><br><span class="line">ORDER BY</span><br><span class="line">	t1.id,</span><br><span class="line">	t2.score</span><br></pre></td></tr></table></figure>
<h3 id="联结多张表"><a href="#联结多张表" class="headerlink" title="联结多张表"></a>联结多张表</h3><blockquote>
<p>注意：mysql对于一条select 语句中可以联结的表的数量没有限制，但是联结的表越多，性能下降越厉害，所以我们应该考虑必要的表进行联结，尽量减少联结的表的个数，阿里巴巴java开发手册中也写到，超过3张表禁止join.</p>
</blockquote>
<h2 id="16-创建高级联结"><a href="#16-创建高级联结" class="headerlink" title="16.创建高级联结"></a>16.创建高级联结</h2><h3 id="使用别名是一种很好的习惯（表别名、列别名）"><a href="#使用别名是一种很好的习惯（表别名、列别名）" class="headerlink" title="使用别名是一种很好的习惯（表别名、列别名）"></a>使用别名是一种很好的习惯（表别名、列别名）</h3><h3 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h3><p><strong>1.自联结</strong></p>
<blockquote>
<p>例如：你的id为a的货品有质量问题，所以你想知道a货品的供货商的其他商品是否也有问题，查询出货品a所属供货商的所有货品。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用子查询</span><br><span class="line">SELECT</span><br><span class="line">	t1.prod_id,</span><br><span class="line">	t1.prod_name </span><br><span class="line">FROM</span><br><span class="line">	products t1 </span><br><span class="line">WHERE</span><br><span class="line">	t1.ghs_id &#x3D; ( SELECT t2.ghs.id FROM products t2 WHERE t2.prod_id &#x3D; &#39;a&#39;; )</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用自联结查询</span><br><span class="line">SELECT</span><br><span class="line">	t1.prod_id,</span><br><span class="line">	t1.prod_name </span><br><span class="line">FROM</span><br><span class="line">	products t1,</span><br><span class="line">	products t2 </span><br><span class="line">WHERE</span><br><span class="line">	t1.ghs_id &#x3D; t2.ghs_id </span><br><span class="line">	AND t1.prod_id &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用自联结而不是子查询？自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句，虽然查询结果是相同的，但是有时候处理联结的速度比子查询快得多。</p>
</blockquote>
<p><strong>2.外联结(左外联结、右外联结)</strong></p>
<blockquote>
<p>在使用<code>outer join</code>语法时候必须指定<code>left</code> 或者  <code>right</code> 关键字来确定包括其所有行的表，实际上外连接经常被我们简写成<code>left join... on</code>和<code>right join...on</code></p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>①注意所使用的联结类型。一般我们使用内部联结，但是使用外联结也是有效的。<br>②保证使用正确的联结条件，否则将返回不正确的数据。<br>③应该总是提供联结条件on….不然会得出<code>笛卡尔积</code><br>④在一个联结中可以包含多个表，甚至对于每个联结可以使用不同的联结类型，虽然是合法的，但是应该在一起测试前，分别测试每个联结，这将使故障排除更简单。</p>
</blockquote>
<h2 id="17-组合查询UNION"><a href="#17-组合查询UNION" class="headerlink" title="17.组合查询UNION"></a>17.组合查询UNION</h2><blockquote>
<p>有两种情况需要用到组合查询：<br>①在单个查询中从不同的表返回类似结构的数据<br>②对单个表执行多个查询，按单个查询返回结果</p>
</blockquote>
<p><code>union相当于拼接两个select的结果，每一个where ....or ...都能拆成union组合查询</code></p>
<blockquote>
<p><code>union</code>使用规则：<br>①union必须由两条或以上的select语句组成<br>②union中的每个查询必须包含相同的列、表达式或聚集函数<code>（注意：列的顺序也必须相同）</code><br>③列数据类型必须兼容，类型不必完全相同，但是必须DBMS可以隐式转换的类型。</p>
</blockquote>
<h3 id="UNION默认取消重复行（保留一条），如果返回所有即使重复可以用UNION-ALL"><a href="#UNION默认取消重复行（保留一条），如果返回所有即使重复可以用UNION-ALL" class="headerlink" title="UNION默认取消重复行（保留一条），如果返回所有即使重复可以用UNION ALL"></a>UNION默认取消重复行（保留一条），如果返回所有即使重复可以用UNION ALL</h3><blockquote>
<p>union排序只需要在最后一个select上写order by 即可对整体union后的结果进行排序。</p>
</blockquote>
<h2 id="18-全文本搜索"><a href="#18-全文本搜索" class="headerlink" title="18.全文本搜索"></a>18.全文本搜索</h2><blockquote>
<p>简介：早期mysql只有MyISAM搜索引擎支持全文本搜索，而InnoDB搜索引擎不支持<br>——-mysql 5.6.4之后InnoDB也开始支持全文搜索<br>——-在MySQL 5.7.6之前，全文索引只支持英文全文索引，不支持中文全文索引<br>——-从MySQL 5.7.6开始，MySQL内置了ngram全文解析器，用来支持中文、日文、韩文分词。<br>——-我这里使用的版本是mysql5.7.28</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询表状态，搜索引擎一般默认Innodb</span><br><span class="line">show table status;</span><br><span class="line"></span><br><span class="line">-- 修改表address的搜索引擎为MyISAM或InnoDB</span><br><span class="line">ALTER TABLE &#96;address&#96; ENGINE&#x3D;INNODB;</span><br><span class="line"></span><br><span class="line">-- 查询mysql是否开启全文搜索,ft_min_word_len&#x3D;1为开启</span><br><span class="line">SHOW VARIABLES LIKE &#39;ft%&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询mysql中文分词的词语最少，默认ngram_token_size &#x3D; 2，即一个中文词语两个字</span><br><span class="line">-- 如果需要搜索单字，就要把ngram_token_size设置为1</span><br><span class="line">SHOW VARIABLES LIKE &#39;ngram%&#39;;</span><br><span class="line"></span><br><span class="line">#查询address表的索引</span><br><span class="line">show index from address;</span><br><span class="line"></span><br><span class="line">-- 给address表的address字段添加全文索引，使用中文分词ngram</span><br><span class="line">CREATE FULLTEXT INDEX ft_address ON &#96;address&#96; ( &#96;address&#96; ) WITH PARSER ngram;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在100万数据里全文检索，中文分词搜索 青州</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	address t </span><br><span class="line">WHERE</span><br><span class="line">	MATCH ( address ) Against ( &quot;青州&quot; );</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-8.png" alt="image.png"></p>
<h3 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h3><blockquote>
<p>例如，我是用全文搜索<code>not</code>,得到如下一条结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	address t </span><br><span class="line">WHERE</span><br><span class="line">	MATCH ( address ) Against ( &quot;not&quot; );</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-9.png" alt="image.png"></p>
<blockquote>
<p>使用查询扩展之后，可得到如下3条结果，第一行包括<code>not</code>所以等级最高，因为第二条和第三条都有第一条存在的rabbit所以也被搜索出来了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	address t </span><br><span class="line">WHERE</span><br><span class="line">	MATCH ( address ) Against ( &quot;not&quot; with query expansion);</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-10.png" alt="image.png"></p>
<h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><blockquote>
<p>常用的全文检索模式有两种：<br>1、自然语言模式(NATURAL LANGUAGE MODE) ，<br>自然语言模式是MySQL 默认的全文检索模式。自然语言模式不能使用操作符，不能指定关键词必须出现或者必须不能出现等复杂查询。<br>2、BOOLEAN模式(BOOLEAN MODE)<br>BOOLEAN模式可以使用操作符，可以支持指定关键词必须出现或者必须不能出现或者关键词的权重高还是低等复杂查询。</p>
</blockquote>
<blockquote>
<p>例如，使用布尔模式查询包括rabbit但是不能包括not的结果,只有两条，包含rabbit和not的那条被过滤掉了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	address t </span><br><span class="line">WHERE</span><br><span class="line">	MATCH ( address ) Against (&#39;+rabbit -not&#39; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-11.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;apple banana&#39; </span><br><span class="line">无操作符，表示或，要么包含apple，要么包含banana</span><br><span class="line"></span><br><span class="line">&#39;+apple +juice&#39;</span><br><span class="line">必须同时包含两个词</span><br><span class="line"></span><br><span class="line">&#39;+apple macintosh&#39;</span><br><span class="line">必须包含apple，但是如果也包含macintosh的话，相关性会更高。</span><br><span class="line"></span><br><span class="line">&#39;+apple -macintosh&#39;</span><br><span class="line">必须包含apple，同时不能包含macintosh。</span><br><span class="line"></span><br><span class="line">&#39;+apple ~macintosh&#39;</span><br><span class="line">必须包含apple，但是如果也包含macintosh的话，相关性要比不包含macintosh的记录低。</span><br><span class="line"></span><br><span class="line">&#39;+apple +(&gt;juice &lt;pie)&#39;</span><br><span class="line">查询必须包含apple和juice或者apple和pie的记录，但是apple juice的相关性要比apple pie高。</span><br><span class="line"></span><br><span class="line">&#39;apple*&#39;</span><br><span class="line">查询包含以apple开头的单词的记录，如apple、apples、applet。</span><br><span class="line"></span><br><span class="line">&#39;&quot;some words&quot;&#39;</span><br><span class="line">使用双引号把要搜素的词括起来，效果类似于like &#39;%some words%&#39;，</span><br><span class="line">例如“some words of wisdom”会被匹配到，而“some noise words”就不会被匹配。</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-12.png" alt="image.png"></p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><blockquote>
<p>①只能在类型为CHAR、VARCHAR或者TEXT的字段上创建全文索引。<br>②全文索引只支持InnoDB和MyISAM引擎。<br>③MATCH (columnName) AGAINST (‘keywords’)。MATCH()函数使用的字段名，必须要与创建全文索引时指定的字段名一致。如上面的示例，MATCH (title,body)使用的字段名与全文索引ft_articles(title,body)定义的字段名一致。如果要对title或者body字段分别进行查询，就需要在title和body字段上分别创建新的全文索引。<br>④MATCH()函数使用的字段名只能是同一个表的字段，因为全文索引不能够跨多个表进行检索。<br>⑤如果要导入大数据集，使用先导入数据再在表上创建全文索引的方式要比先在表上创建全文索引再导入数据的方式快很多，所以全文索引是很影响TPS的。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/miracle-luna/p/11147859.html" target="_blank" rel="noopener external nofollow noreferrer"><a href="https://www.cnblogs.com/miracle-luna/" target="_blank" rel="noopener external nofollow noreferrer">龙凌云端</a></a></p>
<h2 id="19-插入数据"><a href="#19-插入数据" class="headerlink" title="19.插入数据"></a>19.插入数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给学生表插入一条记录，标准插入语句</span><br><span class="line">INSERT INTO student (id,&#96;name&#96;,kemu,score,class_id) VALUES(11,&#39;小明&#39;,&#39;体育&#39;,100,4);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>①id自增的话可以省略<br>②表后边的明确的给出列名及对应的顺序是安全的做法，即使表结构发生变化，此insert语句依然能够正常工作。<br>③如果表的定义允许，可以insert语句中省略某些列，省略的列必须满足以下某个条件，（一、该列定义允许为NULL。二、在标的定义中给出了默认值）<br>④可以使用<code>insert low_priority into</code> 降低insert语句的优先级，也适用于<code>update</code>和<code>delete</code></p>
</blockquote>
<h3 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 注意：这种方法比一个一个insert快</span><br><span class="line">INSERT INTO student ( id, &#96;name&#96;, kemu, score, class_id )</span><br><span class="line">VALUES</span><br><span class="line">	( 12, &#39;小a&#39;, &#39;体育&#39;, 11, 1 ),</span><br><span class="line">	( 13, &#39;小b&#39;, &#39;体育&#39;, 22, 2 ),</span><br><span class="line">	( 14, &#39;小c&#39;, &#39;体育&#39;, 33, 3 );</span><br></pre></td></tr></table></figure>
<h2 id="20-更新和删除数据"><a href="#20-更新和删除数据" class="headerlink" title="20.更新和删除数据"></a>20.更新和删除数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 更改id&#x3D;11的数据的name&#x3D;小李</span><br><span class="line">UPDATE student </span><br><span class="line">SET NAME &#x3D; &#39;小李&#39; </span><br><span class="line">WHERE</span><br><span class="line">	id &#x3D; 11;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除第id&#x3D;10的那一行</span><br><span class="line">DELETE </span><br><span class="line">FROM</span><br><span class="line">	student </span><br><span class="line">WHERE</span><br><span class="line">	id &#x3D; 10;</span><br></pre></td></tr></table></figure>
<h3 id="更快的删除"><a href="#更快的删除" class="headerlink" title="更快的删除"></a>更快的删除</h3><blockquote>
<p>如果你想删除表中的所有数据，你可以使用<code>Truncate Table</code>,实际上他的意思是删除表，再重新创建一张表，而不是逐行删除表中的数据，所以速度较快。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE student;</span><br></pre></td></tr></table></figure>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE &#96;t_class&#96;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会读书笔记（1）</title>
    <url>/article/3d0503d6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mysql命令行客户端登录"><a href="#mysql命令行客户端登录" class="headerlink" title="mysql命令行客户端登录"></a>mysql命令行客户端登录</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 默认端口3306 主机本地localhost</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment">-- 写全的话</span></span><br><span class="line">mysql -u root -p -h localhost -P 3307</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<blockquote>
<p>解释一下：-u 用户名为root     -p 密码待输入   -h 主机名localhost   -P 注意大写P ，意思是端口号3307</p>
</blockquote>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 展示所有数据库</span><br><span class="line">show databases;</span><br><span class="line">-- 使用数据库</span><br><span class="line">use kls;</span><br><span class="line">-- 展示数据库中所有的表</span><br><span class="line">show tables;</span><br><span class="line">-- 展示person表的字段</span><br><span class="line">show columns from person;</span><br><span class="line">-- show columns from 可以用describe代替</span><br><span class="line">describe person;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-1.png" alt="22-3d0503d6-1.png"></p>
<blockquote>
<p>mysql不区分大小写，但是为了易于阅读，开发人员经常把关键字大写，列和表名小写。(反正我是遵守不了，看大写的英文难受)</p>
</blockquote>
<h2 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h2><blockquote>
<p>如果查询学生表的年龄，每个年龄只出现一次</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct age from student;</span><br></pre></td></tr></table></figure>
<h2 id="限制返回结果数"><a href="#限制返回结果数" class="headerlink" title="限制返回结果数"></a>限制返回结果数</h2><blockquote>
<p>limit 5 表示从第1行开始，返回5条记录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from student limit 5;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>limit 5, 5表示从第5行开始，返回5条数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from student limit 5,5;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一种写法：limit 2 offset 3  代表从行3（也就是第四行）开始取2行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from student limit 2 offset 3;</span><br></pre></td></tr></table></figure>
<h2 id="排序order-by"><a href="#排序order-by" class="headerlink" title="排序order by"></a>排序order by</h2><blockquote>
<p>注意：order by 不仅可以按照检索的列排序，用非检索的列排序也是合法的。<br>注意：在多个列进行降序排序，需要在每个列指定DESC关键字，因为不指定的都默认ASC升序排列。<br>注意：order by 和 limit连用的时候，limit放在order by的后面。</p>
</blockquote>
<h2 id="between操作符"><a href="#between操作符" class="headerlink" title="between操作符"></a>between操作符</h2><blockquote>
<p>用来检索在两个数值之间的记录，例如查询在18-20岁之间的学生</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student t where t.age between 18 and 20;</span><br></pre></td></tr></table></figure>
<h2 id="通配符-和"><a href="#通配符-和" class="headerlink" title="通配符 % 和 _"></a>通配符 % 和 _</h2><blockquote>
<p>mysql使用LIKE操作符跟%通配符进行模糊搜索。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询姓李的学生</span><br><span class="line">select name from student where name like &#39;李%&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>①注意：根据mysql的配置方式，搜索是要区分大小写的，例如模糊搜索中’jet%’是不会匹配JetPack的。<br>②注意’%jet%’表示匹配任何位置包括jet文本的值，而不论他之前或之后出现什么值。<br>③%表示搜索模式指定位置有0到多个任意字符。<br>④注意通配符_下划线，只能匹配1个字符，不能多也不能少。<br>⑤%不会匹配NULL行，即使是like ‘%’也不会匹配NULL行。<br>⑥通配符一般处理时间比其他搜索要长，其他操作能达到尽量不要使用，使用通配符时候除非有绝对必要，否则不要把通配符用在开始处，因为放在开始处，搜索会最慢。</p>
</blockquote>
<h2 id="使用mysql正则表达式"><a href="#使用mysql正则表达式" class="headerlink" title="使用mysql正则表达式"></a>使用mysql正则表达式</h2><blockquote>
<p>mysql使用 <code>regexp</code> 表示后面跟的内容为正则表达式</p>
<p>###基本字符匹配</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正则匹配姓名为小刚的行</span><br><span class="line">select * from student where name regexp &#39;小刚&#39;；</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>.</code>点号是正则表达式中的一个重要字符，表示匹配任意一个字符。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正则匹配0前面有任意一个字符的行,例如10、20等</span><br><span class="line">select * from student where age regexp &#39;.0&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正则表达式不区分大小写，为了区分大小写可以使用binary关键字</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 下面例子则匹配jet 1000 或者 jet a000等</span><br><span class="line">... where name regexp binary &#39;jet .000&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h3><blockquote>
<p>正则表达式利用<code>|</code>来表示or操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 匹配名字中包括小明或小李的</span><br><span class="line">... where name regexp &#39;小明|小李&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h3><blockquote>
<p>使用<code>[]</code>包裹的字符，表示匹配其中之一</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正则匹配包括1或2或3的学号</span><br><span class="line">... where id regexp &#39;[123]&#39;；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释：<code>[123]</code>是<code>[1|2|3]</code>的缩写，其实<code>[]</code>就是正则中另一种形式的or语句，为什么加<code>[]</code>是因为如下：</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-2.png" alt="22-3d0503d6-2.png"></p>
<blockquote>
<p>字符集合也可以被否定，即匹配除指定字符之外的任何东西，即<code>[^123]</code>匹配除123这三个字符之外的任何东西。</p>
</blockquote>
<h2 id="正则匹配范围"><a href="#正则匹配范围" class="headerlink" title="正则匹配范围"></a>正则匹配范围</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如</span><br><span class="line">[0-9]</span><br><span class="line">[a-z]</span><br><span class="line">[1-3]</span><br><span class="line">[a-e]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将会匹配到1 Ton anvil 或 .5 ton anvil等 </span><br><span class="line">... where name regexp &#39;[1-5] Ton&#39;；</span><br></pre></td></tr></table></figure>
<h3 id="正则匹配特殊字符-转义"><a href="#正则匹配特殊字符-转义" class="headerlink" title="正则匹配特殊字符\\转义"></a>正则匹配特殊字符<code>\\</code>转义</h3><blockquote>
<p>如果需要转义<code>\</code>本身，需要使用<code>\\\</code><br>为什么正则表达式用两个<code>\\</code>呢？因为在mysql当中，mysql自己解释一个，正则表达式库解释一个。</p>
</blockquote>
<h3 id="正则匹配字符类"><a href="#正则匹配字符类" class="headerlink" title="正则匹配字符类"></a>正则匹配字符类</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-3.png" alt="22-3d0503d6-3"></p>
<h3 id="正则匹配多个实例"><a href="#正则匹配多个实例" class="headerlink" title="正则匹配多个实例"></a>正则匹配多个实例</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-4.png" alt="22-3d0503d6-4"><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-5.png" alt="22-3d0503d6-5.png"></p>
<h3 id="正则定位符"><a href="#正则定位符" class="headerlink" title="正则定位符"></a>正则定位符</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-6.png" alt="22-3d0503d6-6"></p>
<blockquote>
<p>例如我们想搜索一个以<code>.</code>点号或者数字开头的结果，怎么办？<br>[0-9\.]是不行的，因为他会在文本的任意位置开始查找，解决办法就是使用定位符^从文本开始位置查找。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... where name regexp &#39;^[0-9\\.]&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><blockquote>
<p>简单来说，数据库中存储的结果不是我们最终想要的，例如省市区分别存储在3列中，我们需要连在一列显示。</p>
</blockquote>
<h3 id="拼接字段Concat-函数"><a href="#拼接字段Concat-函数" class="headerlink" title="拼接字段Concat()函数"></a>拼接字段Concat()函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将first_name、 ( 、last_name、和）这四个字符串拼接起来，例如: 李 （小明）</span><br><span class="line">select Concat(first_name, &#39; (&#39; , last_name, &#39;)&#39;) as name from student;</span><br></pre></td></tr></table></figure>
<h3 id="Trim-、LTrim-、RTrim-函数"><a href="#Trim-、LTrim-、RTrim-函数" class="headerlink" title="Trim()、LTrim() 、RTrim()函数"></a><code>Trim()</code>、<code>LTrim()</code> 、<code>RTrim()</code>函数</h3><blockquote>
<p>分别为去掉左右两边的空格、去掉左边空格、去掉右边空格</p>
</blockquote>
<h2 id="如何测试计算？"><a href="#如何测试计算？" class="headerlink" title="如何测试计算？"></a>如何测试计算？</h2><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-7.png" alt="22-3d0503d6-7"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如查询当前时间</span><br><span class="line">select  now();</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-8.png" alt="22-3d0503d6-8"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>第二篇文章致敬梦想</title>
    <url>/article/6b624713.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>毫无疑问，首篇文章祭给Hello World！</del></p>
<p><a href="http://52chang.wang" target="_blank" rel="noopener external nofollow noreferrer" class="LinkCard">卡片链接感谢–&gt;长弓不是弓长</a></p>
<a id="more"></a>

<blockquote>
<p>超喜欢Nike这个视频，谨以此献给我的读者们，我们以此共勉，向着心中的“乌托邦”，未来的康庄大道，前进！</p>
<p>梦想还是要有的，万一实现了呢？</p>
<p>梦想是一定要有的，我们肯定能实现！</p>
<p>问题不是自己的梦想是否疯狂，而是够不够疯狂！</p>
</blockquote>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://yunqing-img.oss-cn-beijing.aliyuncs.com/video/dream-crazy.mp4","pic":"https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexovideo-logo.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>











]]></content>
      <tags>
        <tag>梦想</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/article/4a17b156.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener external nofollow noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener external nofollow noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener external nofollow noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener external nofollow noreferrer">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener external nofollow noreferrer">Writing</a> </p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener external nofollow noreferrer">Server</a> </p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener external nofollow noreferrer">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener external nofollow noreferrer">Deployment</a></p>
]]></content>
  </entry>
</search>
