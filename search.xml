<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL查询性能优化</title>
    <url>/article/42812f47.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-为什么查询速度会慢？"><a href="#1-为什么查询速度会慢？" class="headerlink" title="1.为什么查询速度会慢？"></a>1.为什么查询速度会慢？</h3><p>​        首先对一个查询的生命周期简化分析，大致可以按照顺序分为：从客户端、到服务器、然后在服务器进行解析、生成执行计划、执行、并返回结果给客户端。其中的<code>执行</code>可以被认为是查询的生命周期中最重要的部分，执行主要包括了大量为了检索数据到存储引擎的调用以及调用后数据的排序、分组等处理。</p>
<p>​        在完成生命周期的这些任务的时候，查询需要在不用的地方消耗时间，包括网络、CPU计算、生成执行计划、锁等待等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用操作需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间，根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用小号的时间。所有的这些任务消耗的时间共同构成了响应时间，在每一个消耗大量时间的查询操作中，我们都能看到一些不必要的额外操作，某些操作被额外的重复了很多次，某些操作执行太慢等，优化查询的目的就是减少和消除这些额外操作所花费的时间。</p>
<a id="more"></a>

<h3 id="2-慢查询基础：优化数据访问"><a href="#2-慢查询基础：优化数据访问" class="headerlink" title="2.慢查询基础：优化数据访问"></a>2.慢查询基础：优化数据访问</h3><p>​        查询性能低下的最根本原因就是访问的数据太多。虽然某些查询可能不可避免的需要筛选大量的数据，但这并不常见。大部分性能低下的查询都可以通过减少访问数据量的方式进行优化。可以通过以下两步进行分析：</p>
<p>​        1.确认是否存在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是因为访问了太多的列。</p>
<p>​        2.确认MySQL服务器层是否存在分析大量超过需要的数据行。</p>
<h4 id="2-1是否向数据库请求了不需要的数据？"><a href="#2-1是否向数据库请求了不需要的数据？" class="headerlink" title="2.1是否向数据库请求了不需要的数据？"></a>2.1是否向数据库请求了不需要的数据？</h4><ul>
<li>查询不需要的记录</li>
<li>多表关联时返回全部的列</li>
<li>总是取出全部列</li>
</ul>
<p>针对以上三点我这里试举几个典型案例：</p>
<p>​        1.查询不需要的记录</p>
<p>​        前端分页就是经典例子，查询实际需求显示第一页10条， 却返回100万条数据，性能低下显而易见，建议后端分页 <code>LIMIT 0, 10</code></p>
<p>​        2.多表关联时返回全部的列</p>
<p>​        假如你想查询所在电影<code>大话西游</code>中出现的演员，千万不能按照如下的方式查询，这将返回这三个表全部的列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM actor</span><br><span class="line">	INNER JOIN film_actor USING(actor_id)</span><br><span class="line">	INNER JOIN film USING(film_id)</span><br><span class="line">	WHERE film.title &#x3D; &#39;大话西游&#39;;</span><br></pre></td></tr></table></figure>

<p>​        正确的做法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 规定只查询 actor 表的列</span><br><span class="line">SELECT actor.* from actor ...</span><br></pre></td></tr></table></figure>

<p>​        3.总是取出全部的列</p>
<p>​        每次看到 <code>SELECT *</code> 的时候都要用怀疑的眼光审视，是不是真的需要返回全部的列？很可能是不必须的，取出全部列，会让优化器无法完成索引扫描这类优化，还会为服务器带来额外的 I/O、内存和CPU消耗。</p>
<h4 id="2-2-MySQL是否在扫描额外的记录？"><a href="#2-2-MySQL是否在扫描额外的记录？" class="headerlink" title="2.2 MySQL是否在扫描额外的记录？"></a>2.2 MySQL是否在扫描额外的记录？</h4><p>​        在确定查询只返回需要的数据后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL而言，最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p>​        没有哪个指标能够完美的衡量查询的开销，但是他们大致反映了MySQL内部执行查询时候需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。</p>
<p><strong>下面通过一个例子来查看一下慢日志：</strong></p>
<ul>
<li>存在一个部门表<code>t_dept</code>，包括100万条部门记录，现在查询部门名称为<code>事询部</code>的所有部门</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 没建立索引的情况下，100万条数据中查询大概0.8秒</span><br><span class="line">SELECT t.id, t.department</span><br><span class="line">	FROM t_dept t</span><br><span class="line">	WHERE t.department &#x3D; &#39;事询部&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先我将慢日志记录时间设置为0.5秒，然后指定了慢日志位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将慢日志时间设置为0.5</span><br><span class="line">set long_query_time&#x3D;0.5;</span><br><span class="line"></span><br><span class="line">-- 设置慢日志位置</span><br><span class="line">set global slow_query_log_file&#x3D;&#39;E:\mysql_slow_query.log&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行上面的查询操作，之后查看慢日志</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-1.png" alt="图1"></p>
<ul>
<li><p>从慢日志中可以看到上面说到的主要指标：查询事件、返回行数、扫描行数</p>
</li>
<li><p>问题来了，返回行数899行，却扫描了整个表100万条数据，当然效率低下了，明显用到了全表扫描，EXPLAIN执行计划中的type列说明了访问类型。执行看一下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 执行查询计划</span><br><span class="line">EXPLAIN SELECT t.id, t.department</span><br><span class="line">	FROM t_dept t</span><br><span class="line">	WHERE t.department &#x3D; &#39;事询部&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-2.png" alt="图2"></p>
<p>​        可以看到type访问类型ALL全表扫描，预估访问97万行数据，<code>Using Where</code>代表MySQL将通过<code>WHERE</code>条件来筛选存储引擎返回的记录。</p>
<ul>
<li><p>一般MySQL通过如下三种方式应用WHERE条件，从好到坏依次是：</p>
<p>1.在索引中使用WHERE条件来过滤不匹配的记录，这是在存储引擎层完成的</p>
<p>2.使用索引覆盖扫描（在Extra中出现Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中结果，这是在MySQL服务器层完成的。</p>
<p>3.从表中返回数据，然后过滤不满足条件的记录（在Extra中显示Using Where）再试在MySQL服务器层完成，MySQL需要先从数据表读出数据然后过滤。</p>
</li>
</ul>
<h4 id="2-3-加一个索引试试"><a href="#2-3-加一个索引试试" class="headerlink" title="2.3 加一个索引试试"></a>2.3 加一个索引试试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给部门表的部门名添加一条索引</span><br><span class="line">ALTER TABLE t_dept ADD INDEX index_department(department);</span><br><span class="line">-- 将慢sql记录时间调整成0秒</span><br><span class="line">set long_query_time&#x3D;0</span><br><span class="line">-- 再次执行前面的查询</span><br><span class="line">SELECT t.id, t.department</span><br><span class="line">	FROM t_dept t</span><br><span class="line">	WHERE t.department &#x3D; &#39;事询部&#39;;</span><br><span class="line">-- 查看执行计划</span><br><span class="line">EXPLAIN SELECT t.id, t.department</span><br><span class="line">	FROM t_dept t</span><br><span class="line">	WHERE t.department &#x3D; &#39;事询部&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-3.png" alt="图3"></p>
<ul>
<li>可以看到访问类型已经从全表扫描ALL变成了非唯一性索引扫描ref,预计访问行数由97万行变成了899行，Extra显示了WHERE条件使用了索引覆盖扫描。</li>
<li>下面看一下慢日志，注意要将慢日志记录时限改成0秒，不然记录不下来：</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-4.png" alt="图4"></p>
<ul>
<li>由原来的的0.8秒变成了0.000562秒，正确合适的使用索引优化速度显而易见。</li>
</ul>
<blockquote>
<p>总结：</p>
<p>如果发现查询需要扫描大量的数据行，而只返回其中少量的数据行，这样就可以尝试这样优化：</p>
<p>1.使用索引覆盖扫描，把所有需要用的列放到索引中，这样存储引擎无需会标获取对应的行就可以返回结果</p>
<p>2.改变表结构，例如使用单独的汇总表</p>
<p>3.重写这个复杂查询，让MySQL优化器能够以更优化的方式执行这个查询</p>
</blockquote>
<h3 id="3-重构查询的方式"><a href="#3-重构查询的方式" class="headerlink" title="3.重构查询的方式"></a>3.重构查询的方式</h3><h4 id="3-1-一个复杂查询还是多个简单查询？"><a href="#3-1-一个复杂查询还是多个简单查询？" class="headerlink" title="3.1 一个复杂查询还是多个简单查询？"></a>3.1 一个复杂查询还是多个简单查询？</h4><p>​        在传统的实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。但是MySQL从设计上让连接和断开都很轻量级，现代网络和速度比以前快很多，所以无论是带宽还是延迟，都支持MySQL在必要时可以将一个大的复杂查询转换成多个小的查询。</p>
<p>​        虽然在其他条件都相同的情况下，使用尽可能少的查询当然是更好的，但是有时候，将一个大的查询分解成多个小的查询是很有必要的。</p>
<h4 id="3-2-切分查询"><a href="#3-2-切分查询" class="headerlink" title="3.2 切分查询"></a>3.2 切分查询</h4><p>​        有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，没个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p>
<p>例如：</p>
<p>​        删除旧的数据就是一个很好的例子，定期的清除大量数据的时候，如果一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的重要的查询。因此切分成很多小的查询多次完成，则可以尽可能小的影响MySQL的性能，同时还可以减少MySQL复制的延迟。例如：我们需要每个月运行一次下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 从messages表中删除3个月之前创建的数据</span><br><span class="line">DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br></pre></td></tr></table></figure>

<p>​        我们可以将这个查询分成每次删除10000条数据，然后暂停一会再做下次删除，这样可以将服务器上原本一次性的压力分散到一个很长的时间段中，可以降低对服务器的影响，减少删除时锁的持有时间。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 分成多次执行</span><br><span class="line">DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000;</span><br></pre></td></tr></table></figure>



<h4 id="3-3分解关联查询"><a href="#3-3分解关联查询" class="headerlink" title="3.3分解关联查询"></a>3.3分解关联查询</h4><p>​        很多高性能应用都会对关联查询进行分解。简单来说，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，例如下面这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	t_user t1</span><br><span class="line">	JOIN t_dept t2 USING ( id )</span><br><span class="line">	JOIN t_address t3 USING ( id ) </span><br><span class="line">WHERE</span><br><span class="line">	t1.fname &#x3D; &#39;6Yn&#39;</span><br><span class="line"></span><br><span class="line">-- 可以分解成下面这些查询来代替：</span><br><span class="line">SELECT * FROM t_user t WHERE t.fname &#x3D; &#39;6YN&#39;;</span><br><span class="line">SELECT * FROM t_dept t WHERE t.id &#x3D; 23456;</span><br><span class="line">SELECT * FROM t_address t WHERE t.id in (12, 234, 23456, 100000);</span><br></pre></td></tr></table></figure>

<p>这么做的优势是什么呢？</p>
<ul>
<li><p>1.让缓存更高效。许多应用程序可以方便的缓存单表查询对应的结果对象。例如，上面的查询中<code>fname</code>已经被缓存了，那么应用程序就可以跳过第一个查询。再例如，应用中已经缓存了ID为12， 34的内容，那么第三个查询的<code>IN()</code>中就可以少几个ID。</p>
</li>
<li><p>2.将查询分解后，执行单个查询可以减少锁的竞争。</p>
</li>
<li><p>3.在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</p>
</li>
<li><p>4.查询本身效率也可能会有所提升。</p>
</li>
<li><p>5.可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复的访问一部分数据。从这点看，这样的重构还可能会减少网络和内存消耗。</p>
</li>
<li><p>6.这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。</p>
</li>
</ul>
<h3 id="4-查询执行的基础"><a href="#4-查询执行的基础" class="headerlink" title="4.查询执行的基础"></a>4.查询执行的基础</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-5.png" alt="图5"></p>
<h4 id="4-1查询缓存"><a href="#4-1查询缓存" class="headerlink" title="4.1查询缓存"></a>4.1查询缓存</h4><ul>
<li>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。</li>
<li>这个检查是通过一个对大小写敏感的哈希查找的。查询和缓存中的查询即使只有一个不同，也不会匹配缓存结果。</li>
<li>如果命中缓存，那么在返回结果前MySQL会检查一次用户权限，有权限则跳过其他步骤直接返回数据。</li>
</ul>
<p>缓存何时失效？</p>
<p>​        在表的结构或数据发生改变时，查询缓存中的数据不再有效。有这些INSERT、UPDATE、 DELETE、TRUNCATE、ALTER TABLE、DROP TABLE或DROP DATABASE会导致缓存数据失效。所以查询缓存适合有大量相同查询的应用，不适合有大量数据更新的应用。</p>
<p>如何清理查询缓存？</p>
<ul>
<li>FLUSH QUERY CACHE;  // 清理查询缓存内存碎片。</li>
<li>RESET QUERY CACHE;  // 从查询缓存中移出所有查询。</li>
<li>FLUSH TABLES;  //关闭所有打开的表，同时该操作将会清空查询缓存中的内容。</li>
</ul>
<h4 id="4-2-查询优化器"><a href="#4-2-查询优化器" class="headerlink" title="4.2 查询优化器"></a>4.2 查询优化器</h4><p>​        MySQL的查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划。下面是一些MySQL能够处理的优化类型：</p>
<ul>
<li>重新定义关联表的顺序</li>
<li>将外连接转化成内连接</li>
<li>使用等价变换规则</li>
<li>优化COUNT()、MIN()和MAX()</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询</li>
<li>等值查询</li>
<li>列表IN()的比较</li>
</ul>
<p>上面列举的并不是MySQL优化器的全部，MySQL还会做大量其他的优化，列举这些主要是让大家明白优化器的复杂性和智能型。如果说从上面这也例子中我们应该学到些什么，那就是不要自认为比优化器更聪明，你可能会占点便宜，但是更有可能会使查询变得更加复杂而难以维护，而最终受益为零。作为开发人员而不是DBA来说，让优化器按照他的方式工作就可以了。</p>
<h4 id="4-3-排序优化"><a href="#4-3-排序优化" class="headerlink" title="4.3 排序优化"></a>4.3 排序优化</h4><p>​        无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序。但是通常情况下，排序是不可避免的，所以就要考虑如何优化排序了。</p>
<p>​        这里给出的建议是通过索引进行排序。</p>
<p>​        当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中，数据量大则需要使用磁盘，不管是内存还是磁盘中进行排序都统称为文件排序（filesort）。MySQL文件排序的时候需要使用临时存储空间可能会比想象的大得多。原因是：在MySQL进行排序的时候，对于每一个排序记录都会分配一个足够长的定长空间来存放，这个定长空间必须足够长以容纳其中最长的字符串，例如，如果是VARCHAR列则需要分配其完整长度；如果使用UTF-8字符集，那么MySQL将会为每个字符预留三个字节。</p>
<h3 id="5-关于MySQL层面优化的一些建议"><a href="#5-关于MySQL层面优化的一些建议" class="headerlink" title="5.关于MySQL层面优化的一些建议"></a>5.关于MySQL层面优化的一些建议</h3><p><strong>总结到 SQL 优化中，就如下三点：</strong></p>
<ul>
<li>最大化利用索引。</li>
<li>尽可能避免全表扫描。</li>
<li>减少无效数据的查询。</li>
</ul>
<p>理解 SQL 优化原理 ，首先要搞清楚 SQL 执行顺序。</p>
<h4 id="5-1-MySQL的执行顺序"><a href="#5-1-MySQL的执行顺序" class="headerlink" title="5.1 MySQL的执行顺序"></a>5.1 MySQL的执行顺序</h4><p>MySQL的语法顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">DISTINCT &lt;select_list&gt;</span><br><span class="line">FROM &lt;left_table&gt;</span><br><span class="line">&lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line">WHERE &lt;where_condition&gt;</span><br><span class="line">GROUP bY &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line">ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">LIMIT &lt;limit_condition&gt;</span><br></pre></td></tr></table></figure>

<p>MySQL的执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM</span><br><span class="line">&lt;表名&gt; #选取表，将多个表数据通过笛卡尔积变成一个表</span><br><span class="line">ON</span><br><span class="line">&lt;筛选条件&gt; #对笛卡尔积的虚表进行筛选</span><br><span class="line">JOIN #指定join类型</span><br><span class="line">&lt;join表&gt; #用于添加数据到on之后的虚表中</span><br><span class="line">WHERE </span><br><span class="line">&lt;where条件&gt; #对上述虚表进行筛选</span><br><span class="line">GROUP BY</span><br><span class="line">&lt;分组条件&gt; #分组</span><br><span class="line">&lt;SUM()等聚合函数&gt; #用于having进行判断，在书写上这类聚合函数是写在having判断里面的</span><br><span class="line">HAVING</span><br><span class="line">&lt;分组筛选&gt; #对分组后的结果进行聚合筛选</span><br><span class="line">SELECT</span><br><span class="line">&lt;返回数据列表&gt; #返回的单列必须在group by子句中，聚合函数除外</span><br><span class="line">DISTINCT</span><br><span class="line">#数据去重</span><br><span class="line">ORDER BY</span><br><span class="line">&lt;排序条件&gt; #排序</span><br><span class="line">LIMIT</span><br><span class="line">&lt;行数限制&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-优化建议"><a href="#5-2-优化建议" class="headerlink" title="5.2 优化建议"></a>5.2 优化建议</h4><p><strong>注意：以下 SQL 优化策略适用于数据量较大的场景下，如果数据量较小一共几百几千条，属实没有必要考虑。</strong></p>
<h4 id="5-2-1-避免不走索引的场景"><a href="#5-2-1-避免不走索引的场景" class="headerlink" title="5.2.1 避免不走索引的场景"></a>5.2.1 避免不走索引的场景</h4><ul>
<li>尽量避免字段开头的模糊查询，会导致数据库引擎放弃索引进行全表扫描</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看执行计划</span><br><span class="line">EXPLAIN SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	t_user </span><br><span class="line">WHERE</span><br><span class="line">	fname LIKE &#39;%a%&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-6.png" alt="图6"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看执行计划</span><br><span class="line">EXPLAIN SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	t_user </span><br><span class="line">WHERE</span><br><span class="line">	fname LIKE &#39;a%&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/04-mysql-select-7.png" alt="图7"></p>
<p><strong>如果需求是要在前面使用模糊查询：</strong></p>
<p>1.使用 MySQL 内置函数 INSTR（str，substr）来匹配，作用类似于 Java 中的 indexOf()，查询字符串出现的角标位置。</p>
<p>2.使用 FullText 全文索引，用 match against 检索。</p>
<p>3.数据量较大的情况，建议引用 ElasticSearch 亿级数据量检索速度秒级。</p>
<p>4.当表数据量较少（几千条儿那种），别整花里胡哨的，直接用 like ‘%xx%’。</p>
<ul>
<li>使用 or 必须 全部有索引，否则全表扫描，建议使用 union all 代替</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#前提：fname带索引，lname不带索引</span><br><span class="line">-- 因为lname没有索引，会造成全表扫描</span><br><span class="line">select * from t_user where fname &#x3D; &#39;a&#39; or lname &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">-- 由于id和fname都有索引，所以不会全表扫描</span><br><span class="line">select * from t_user where id &#x3D; 1 or fname &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最佳左前缀原则</p>
<p>例如我给<code>t_user</code> 表创建了联合索引 <code>index_fname_lname_age</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 不走索引，全表扫描</span><br><span class="line">select * from t_user where lname &#x3D; &#39;v&#39;;</span><br><span class="line">select * from t_user where age &#x3D; &#39;3&#39;;</span><br><span class="line">select * from t_user where lname &#x3D; &#39;b&#39; and age &#x3D; 3;</span><br><span class="line">-- 走索引</span><br><span class="line">select * from t_user where fname &#x3D; &#39;v&#39;;</span><br><span class="line">select * from t_user where fname &#x3D; &#39;b&#39; and lname &#x3D; &#39;b&#39; and age &#x3D; 3;</span><br><span class="line">-- 仅fname字段走索引</span><br><span class="line">select * from t_user where fname &#x3D; &#39;b&#39; and age &#x3D; 3;</span><br></pre></td></tr></table></figure>

<p>实际上相当于创建了<code>fname索引</code>、<code>fname_lname索引</code> 、<code>fname_lname_age索引</code></p>
<p>总结：联合索引必须保证有最左索引字段，中间字段不能断，直到最后字段，才能全部用上索引。</p>
<ul>
<li><p>索引值不会包含有NULL值的列</p>
<p>​        只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p>
</li>
<li><p>不要在列上进行运算</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将在每个行上进行运算，导致扫描</span><br><span class="line">select * from t_user where YEAR(create_time) &lt; 2020;</span><br><span class="line">-- 可以改写成</span><br><span class="line">select * from t_user where create_time &lt; &#39;2020-01-01&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不使用<code>not in</code>和 <code>&lt;&gt;</code>操作</p>
<p>​        NOT IN 和 &lt;&gt;都将导致不使用索引而全表扫描。NOT IN可以使用NOT EXISTS代替，id&lt;&gt;3可以使用id&gt;3 or id&lt;3代替</p>
</li>
</ul>
<h4 id="5-2-2-UNION和UNION-ALL的区别"><a href="#5-2-2-UNION和UNION-ALL的区别" class="headerlink" title="5.2.2 UNION和UNION ALL的区别"></a>5.2.2 UNION和UNION ALL的区别</h4><ul>
<li>UNION 对两个结果集进行并集操作，会过滤掉重复的行，并且会进行默认规则的排序；</li>
<li>UNION ALL 对两个结果集进行并集操作，不过滤重复的行，也不排序。</li>
</ul>
<p>如果你想取两个结果集的前20条操作，mysql会把两个结果集都放到临时表中，再取前20条，你可以分别取出两个结果集的前20条进行并集操作，然后再LIMIT 20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 注意，这里没有考虑排序问题，主要讲的是减少临时表中的数据</span><br><span class="line">(select fname, lname</span><br><span class="line">from t_user </span><br><span class="line">limit 20)</span><br><span class="line">union all</span><br><span class="line">(select fname, lname</span><br><span class="line">from t_student</span><br><span class="line">limit 20</span><br><span class="line">) limit 20</span><br></pre></td></tr></table></figure>

<p>​        实际上，MySQL总是使用创建并填充临时表的方式来执行UNION查询，因此很多优化策略在UNION中没法很好的使用，经常需要手工的将where、limit、order by等子句下推到UNION的各个子查询中，以便优化器可以充分的利用这些条件进行优化。</p>
<p>​        除非确实需要服务器消除重复的行，否则一定要使用UNION ALL,这一点很重要，如果没有All关键字，MySQL会给临时表加上distinct，这会导致对真个临时表做唯一数据检查，之后进行排序，这样做的代价非常高。即使有ALL关键字，mysql仍会使用临时表存储结果。</p>
<h4 id="5-2-3-COUNT的使用"><a href="#5-2-3-COUNT的使用" class="headerlink" title="5.2.3 COUNT的使用"></a>5.2.3 COUNT的使用</h4><ul>
<li>例如：业务中需要根据一个或者多个条件查询是否存在记录，不关心有多少条记录的时候，有人会这么写：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 这条sql的确定是，不管有多少条满足，会查出所有的行数，</span><br><span class="line">-- 而前提是我们并不关心行数，只关心是否存在</span><br><span class="line">select count(*) from table where a &#x3D; &quot;param1&quot; and b &#x3D; &quot;param2&quot;;</span><br><span class="line"></span><br><span class="line">-- 优化之后的写法</span><br><span class="line">-- sql不使用count而是使用limit 1限制查到一条就返回，不在继续查找了，业务直接判断是否非空即可</span><br><span class="line">select 1 from table where a &#x3D; param1 and b &#x3D; param2 limit 1;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>COUNT(*) / COUNT(1) / COUNT(列名) / COUNT(DISTINCT 列名)</code> 的区别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 返回表中的记录数（包括所有列），相当于统计行数(不会忽略列值为NULL的记录)</span><br><span class="line">count(*) </span><br><span class="line"></span><br><span class="line">-- 忽略所有列，1表示一个固定值，也可以用count(2)、count(3)代替(不会忽略列值为NULL的记录)</span><br><span class="line">count(1) </span><br><span class="line"></span><br><span class="line">-- 返回列名指定列的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内</span><br><span class="line">count(列名)</span><br><span class="line"></span><br><span class="line">-- 只包括列名指定列，返回指定列的不同值的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内。</span><br><span class="line">count(distinct 列名)</span><br></pre></td></tr></table></figure>

<h4 id="count-amp-count-1-amp-count-列名-执行效率比较："><a href="#count-amp-count-1-amp-count-列名-执行效率比较：" class="headerlink" title="count(*)&amp;count(1)&amp;count(列名)执行效率比较："></a>count(*)&amp;count(1)&amp;count(列名)执行效率比较：</h4><ul>
<li>如果列为主键，count(列名)效率优于count(1)</li>
<li>如果列不为主键，count(1)效率优于count(列名)</li>
<li>如果表中存在主键，count(主键列名)效率最优</li>
<li>如果表中只有一列，则count(*)效率最优</li>
<li>如果表有多列，且不存在主键，则count(1)效率优于count(*)</li>
</ul>
<h4 id="5-2-4-Limit的优化使用"><a href="#5-2-4-Limit的优化使用" class="headerlink" title="5.2.4 Limit的优化使用"></a>5.2.4 Limit的优化使用</h4><p>​        在系统中需要进行分页的时候，通常会使用LIMIT加上偏移量的方式实现，同时加上ORDER BY子句。如果有对应的索引，通常效率会不错，否则，MYSQL需要进行大量的文件排序操作。</p>
<p>​        一个非常典型的问题是，在偏移量非常大的情况下，可能需要 limit 2000000,10 需要查询两百万加20条数据然后丢弃两百万，只返回20条，这样做的代价非常高。</p>
<ul>
<li>优化方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如原本的sql是</span><br><span class="line">select * from t_user order by fname limit 2000000, 20;</span><br><span class="line"></span><br><span class="line">-- 使用延迟关联优化</span><br><span class="line">-- 原理是：通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获取需要的行。这可以减少mysql扫描那些需要丢弃的行。</span><br><span class="line">select * from t_user</span><br><span class="line">inner join (</span><br><span class="line">    select id from t_user order by fname limit 2000000, 20</span><br><span class="line">) as t1 USING (id)</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装redis</title>
    <url>/article/e5086296.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="直接用中间大佬给的那条命令即可"><a href="#直接用中间大佬给的那条命令即可" class="headerlink" title="直接用中间大佬给的那条命令即可"></a>直接用中间大佬给的那条命令即可</h3><ul>
<li><p>拉取redis镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></li>
<li><p>从官网获取 <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener external nofollow noreferrer">redis.conf</a> 配置文件,放到挂载目录/usr/local/docker/redis/redis.conf并修改以下前2项。</p>
</li>
<li><p>注意下面3项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1 #注释掉这部分，因为不注释掉的话限制redis只能本地访问</span><br><span class="line">protected-mode no #改成no, 默认yes开启保护模式，限制为只能本地访问，所以改成no</span><br><span class="line">daemonize no #不修改，就用默认no值，如果改为yes意为以守护进程方式启动，可后台运行，除非kill进程（可选），改为yes会使配置文件方式启动redis失败，所以不修改</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>docker启动redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis -v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">*************大佬给的方法，不用配置redis.config************************</span></span><br><span class="line">docker run -d --privileged=true --restart=always -p 6379:6379 -v /usr/local/docker/redis/data:/data --name redis redis:latest redis-server --appendonly yes</span><br></pre></td></tr></table></figure></li>
<li><p>解释：</p>
<blockquote>
<p>-p 6379:6379 映射本地6379端口 ：容器6379端口<br>–name redis 给容器命名redis<br>-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf 挂载目录，冒号前是本地linux目录，冒号后是容器内目录<br>-d redis 表示后台启动redis<br>redis-server /etc/redis/redis.conf  以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/docker/redis/redis.conf<br>–appendonly yes 开启redis 持久化</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>查看容器运行状况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-redis-1.png" alt="图1"></p>
</li>
<li><p>使用 docker exec -it redis /bin/bash进入redis</p>
</li>
<li><p>使用 redis-cli 可以测试连接<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-redis-2.png" alt="图2"></p>
</li>
</ul>
<p>#记录遇到的错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker ps</span></span><br><span class="line">查看容器状态的时候redis的状态一直是restarting一直重启</span><br><span class="line"><span class="comment">#查看redis的日志</span></span><br><span class="line">docker logs redis</span><br><span class="line"><span class="comment">#发现这么一行Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;，理解的意思是aof文件损坏，想了一下原因，昨晚更新windows了...八成这个原因</span></span><br><span class="line"><span class="comment">#解决办法：直接删除容器，删除镜像，重新下载镜像重启</span></span><br><span class="line">docker stop redis</span><br><span class="line">docker rm redis</span><br><span class="line">docker rmi redis:latest</span><br><span class="line">docker pull redis</span><br><span class="line">docker run -d --privileged=<span class="literal">true</span> --restart=always -p 6379:6379 -v d:\docker\redis\data:/data --name redis redis:latest redis-server --appendonly yes</span><br><span class="line"><span class="comment">#注意要删除d:/docker/redis/data目录下的aof文件，估计只删除这个文件重新run容器就行，但是没再尝试</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建容器的时候报错WARNING: IPv4 forwarding is disabled. Networking will not work.</span></span><br><span class="line"><span class="comment">#这个错导致连接不上redis，但是在容器内部docker exec -it redis bash     redis-cli能够使用</span></span><br><span class="line"><span class="comment">#我启动redis容器的命令</span></span><br><span class="line">docker run -d --privileged=<span class="literal">true</span> --restart=always -p 6379:6379 -v /usr/docker/redis/data:/data --name redis redis:latest redis-server --appendonly yes</span><br><span class="line"><span class="comment">#解决办法</span></span><br><span class="line">vim  /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment">#添加下面这行</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"><span class="comment">#重启network</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="comment">#删除错误的重启重新执行启动redis的命令</span></span><br><span class="line">docker stop redis</span><br><span class="line">docker rm redis</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装mysql</title>
    <url>/article/b0daabb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>去dockerhub 查找mysql的镜像版本<a href="https://hub.docker.com/" target="_blank" rel="noopener external nofollow noreferrer">https://hub.docker.com/</a><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-mysql-1.png" alt="图1"><a id="more"></a><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-mysql-1-1.png" alt="图1.1"></p>
</li>
<li><p>拉取镜像mysql5.7.28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7.28</span><br></pre></td></tr></table></figure>
<h1 id="Linux内使用docker安装一样，就是挂载目录的时候把数据文件挂载到Linux内的目录即可。"><a href="#Linux内使用docker安装一样，就是挂载目录的时候把数据文件挂载到Linux内的目录即可。" class="headerlink" title="Linux内使用docker安装一样，就是挂载目录的时候把数据文件挂载到Linux内的目录即可。"></a>Linux内使用docker安装一样，就是挂载目录的时候把数据文件挂载到Linux内的目录即可。</h1></li>
<li><p>因为我是windows下用docker操作的，所以我这里挂载到了windows的D:\java\docker\mysql\data</p>
</li>
<li><p>启动mysql容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#我的windows上的docker映射mysql数据文件到D盘D:\java\docker\mysql\data</span><br><span class="line">docker run -p 3308:3306 --name mysql -v D:\java\docker\mysql\data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d --privileged&#x3D;true --restart&#x3D;always mysql:5.7.28</span><br><span class="line"></span><br><span class="line">#我的Linux上的docker映射mysql数据data文件到&#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql5.7&#x2F;data</span><br><span class="line">docker run -p 3306:3306 --name mysql5.7 -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql5.7&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d --privileged&#x3D;true --restart&#x3D;always mysql:5.7.28</span><br></pre></td></tr></table></figure></li>
<li><p>解释</p>
<blockquote>
<p>-p 3308:3306 端口映射，因为我本地3306/3307都被我占用了，所以我把这个版本mysql映射到本地3308 ：容器内3306端口<br>–name mysql 容器命名mysql<br>-v D:\java\docker\mysql\data:/var/lib/mysql 挂载本地磁盘路径D:\java\docker\mysql\data：对应容器路径/var/lib/mysql<br>-e MYSQL_ROOT_PASSWORD=123456 设置密码123456<br>-d 后台启动，即开机自启<br>–privileged=true  <code>container</code>内的root拥有真正的root权限,有了root权限则不用再去打开相应端口。<strong>加了此参数可以使容器内的操作拥有root权限</strong><br>mysql:5.7.28 针对此镜像启动容器<br>–restart=always 自动重启</p>
</blockquote>
</li>
<li><p>查看容器运行状况<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-mysql-2.png" alt="图2"></p>
</li>
<li><p>连接<br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202009/02-docker-mysql-3.png" alt="图3"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴开发手册为什么这么规定？</title>
    <url>/article/e7c4a452.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202008/20200812210827.png" alt="12-e7c4a452-0"></p>
<a id="more"></a>

<ul>
<li>首先我尝试写了一下这段代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForeachAddOrRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> s : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"2"</span>.equals(s)) &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用结果：异常ConcurrentModificationException如下：</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202008/12-e7c4a452-1.png" alt="12-e7c4a452-1"></p>
<ul>
<li>如图所示提示ArrayList.java 1043行抛出异常，我用的JDK11，马上点进去看了源码，正是如下这行抛出的异常，原因是modCount != expectedModCount那么这两个变量什么意思呢？继续读源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>modCount是在抽象类AbstractList中被定义，是集合结构修改的次数，例如添加元素、删除元素等结构调整都会使modCount++,下面列举add()和删除的源码，其他结构化修改也会modCount++，这里不做列举。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    found: &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                    <span class="keyword">break</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fastRemove(es, i);<span class="comment">//-----------重点重点重点------------------</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(Object[] es, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//---------------重点重点重点------------------</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newSize;</span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    es[size = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//-------重点重点重点----------</span></span><br><span class="line">        add(e, elementData, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>expectedModCount是在ArrayList的内部类Itr中声明的，Itr实现类迭代器接口，这里做了下精简只保留了变量声明和next()方法、remove()方法，可以看到迭代器的实现里声明了expectedModCount = modCount；这里理解成预期结构化调整次数 = 结构化调整次数，为什么每次迭代next()和remove()之前都要检查是否相等呢？可以理解成如果没有这个校验，某个线程删除了list的一个元素，此时next方法不知道size变更了，依然去取数组里的数据，会导致数据为null或ArrayIndexOutOfBoundsException异常等问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//-------------重点重点重点---------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();<span class="comment">//-------------重点重点重点------------------</span></span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();<span class="comment">//-----------重点重点重点---------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;<span class="comment">//------------重点重点重点-------------------</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)<span class="comment">//-----------重点重点重点---------------------</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>这里串起来就好理解了，由于增强for循环底层反编译之后是迭代器实现的，所以在iterator初始化的时候（也就是for循环开始处），expectedModCount = modCount之后for循环内部进行remove实际上用的是ArrayList的remove()方法，执行了modCount++，而进行for循环底层进行next()迭代的时候进行了checkForComodification()方法判断，modCount++了next()并不知道，所以造成不相等抛出异常。</li>
<li>那为什么使用迭代器可以进行删除而不抛出异常呢？因为看上面的源码，迭代器内部的remove()方法的实现在调用ArrayList.this.remove()进行删除之后，expectedModCount = modCount;及时同步了这两个变量的值。所以使用迭代器删除不会造成问题，写法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForeachAddOrRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    <span class="comment">/*for (var s : list) &#123;</span></span><br><span class="line"><span class="comment">        if ("2".equals(s)) &#123;</span></span><br><span class="line"><span class="comment">            list.remove(s);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">var</span> iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"2"</span>.equals(str)) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建议：如果是JDK8或者以上版本，推荐使用removeIf进行删除，这也是IDEA推荐写法"><a href="#建议：如果是JDK8或者以上版本，推荐使用removeIf进行删除，这也是IDEA推荐写法" class="headerlink" title="建议：如果是JDK8或者以上版本，推荐使用removeIf进行删除，这也是IDEA推荐写法"></a>建议：如果是JDK8或者以上版本，推荐使用removeIf进行删除，这也是IDEA推荐写法</h4><p>写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testForeachAddOrRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    <span class="comment">/*for (var s : list) &#123;</span></span><br><span class="line"><span class="comment">            if ("2".equals(s)) &#123;</span></span><br><span class="line"><span class="comment">                list.remove(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*var iterator = list.iterator();</span></span><br><span class="line"><span class="comment">    while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">        var str = iterator.next();</span></span><br><span class="line"><span class="comment">        if ("2".equals(str)) &#123;</span></span><br><span class="line"><span class="comment">            iterator.remove();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    list.removeIf(<span class="string">"2"</span>::equals);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样可以阅读一下removeIf()的源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeIf(filter, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all elements satisfying the given predicate, from index</span></span><br><span class="line"><span class="comment">     * i (inclusive) to index end (exclusive).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter, <span class="keyword">int</span> i, <span class="keyword">final</span> <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//-----------重点重点重点--------------</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="comment">// Optimize for initial run of survivors</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; end &amp;&amp; !filter.test(elementAt(es, i)); i++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// Tolerate predicates that reentrantly access the collection for</span></span><br><span class="line">    <span class="comment">// read (but writers still get CME), so traverse once to find</span></span><br><span class="line">    <span class="comment">// elements to delete, a second pass to physically expunge.</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; end) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> beg = i;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span>[] deathRow = nBits(end - beg);</span><br><span class="line">        deathRow[<span class="number">0</span>] = <span class="number">1L</span>;   <span class="comment">// set bit 0</span></span><br><span class="line">        <span class="keyword">for</span> (i = beg + <span class="number">1</span>; i &lt; end; i++)</span><br><span class="line">            <span class="keyword">if</span> (filter.test(elementAt(es, i)))</span><br><span class="line">                setBit(deathRow, i - beg);</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        modCount++;<span class="comment">//-------------重点重点重点------------</span></span><br><span class="line">        <span class="keyword">int</span> w = beg;</span><br><span class="line">        <span class="keyword">for</span> (i = beg; i &lt; end; i++)</span><br><span class="line">            <span class="keyword">if</span> (isClear(deathRow, i - beg))</span><br><span class="line">                es[w++] = es[i];</span><br><span class="line">        shiftTailOverGap(es, w, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基础</title>
    <url>/article/53471b9a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-创建线程的方式"><a href="#1-创建线程的方式" class="headerlink" title="1.创建线程的方式"></a>1.创建线程的方式</h2><p>从多线程的基础上来讲，创建线程可以继承 <code>Thread</code> 因为java是单继承的，所以还可以实现 <code>Runnable</code>来创建多线程，下面分别举例子：</p>
<h3 id="1-1继承Thread"><a href="#1-1继承Thread" class="headerlink" title="1.1继承Thread"></a>1.1继承Thread</h3><a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 继承Thread实现多线程，demo1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/6 23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结论：</span></span><br><span class="line"><span class="comment">     * 多线程中，代码的执行结果与代码的执行顺序或者调用顺序无关。</span></span><br><span class="line"><span class="comment">     * 原因线程是一个子任务，CPU会以一种不确定的方式随机调用线程中的run()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo1Thread t = <span class="keyword">new</span> Demo1Thread();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行main()方法"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1Thread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.继承Thread类</span></span><br><span class="line"><span class="comment">     * 2.重写run方法</span></span><br><span class="line"><span class="comment">     * 3.实例化</span></span><br><span class="line"><span class="comment">     * 4.调用start()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行run()方法"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2实现Runnable"><a href="#1-2实现Runnable" class="headerlink" title="1.2实现Runnable"></a>1.2实现Runnable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 多线程第二种方法，实现Runnable接口</span></span><br><span class="line"><span class="comment"> * 1.类实现Runnable</span></span><br><span class="line"><span class="comment"> * 2.重写Run()方法</span></span><br><span class="line"><span class="comment"> * 3.实例化创建的类</span></span><br><span class="line"><span class="comment"> * 4.实例化Thread，构造函数传值上面声明的实例</span></span><br><span class="line"><span class="comment"> * 5.调用start()方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/7 20:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo3Runnable d = <span class="keyword">new</span> Demo3Runnable();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(d);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行main()方法"</span> + i);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo3Runnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行run()方法"</span> + i);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用join-控制线程的执行顺序"><a href="#2-使用join-控制线程的执行顺序" class="headerlink" title="2.使用join()控制线程的执行顺序"></a>2.使用<code>join()</code>控制线程的执行顺序</h2><p>线程的执行是随机的，由CPU控制，但是我们可以通过以下的方法对多线程进行可控顺序的执行：</p>
<p>###2.1使用join()方法：让主线程等待子线程的执行完成</p>
<p>工作原理是：在当前线程调用其它线程的join会让当前线程阻塞等待join线程的执行完成，不停检查thread是否存活，如果存活则让当前线程一直wait，直到thread线程终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 使用join()控制线程的执行顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/7 22:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Demo4Thread(<span class="number">1</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Demo4Thread(<span class="number">2</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Demo4Thread(<span class="number">3</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t3.join();</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo4Thread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo4Thread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行run()方法"</span> + i);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2使用CountDownLatch，它与join效果是一样的"><a href="#2-2使用CountDownLatch，它与join效果是一样的" class="headerlink" title="2.2使用CountDownLatch，它与join效果是一样的"></a>2.2使用<code>CountDownLatch</code>，它与join效果是一样的</h3><p>原理：<code>CountDownLatch</code> 定义了一个计数器，和一个阻塞队列， 当计数器的值递减为0之前，阻塞队列里面的线程处于挂起状态，当计数器递减到0时会唤醒阻塞队列所有线程，这里的计数器是一个标志，可以表示一个任务一个线程，也可以表示一个倒计时器，<code>CountDownLatch</code>可以解决那些一个或者多个线程在执行之前必须依赖于某些必要的前提业务先执行的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/9 22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数2</span></span><br><span class="line"><span class="comment">         * 最大线程数10</span></span><br><span class="line"><span class="comment">         * 线程池中超过corePoolSize数目的空闲线程最大存活时间 30秒</span></span><br><span class="line"><span class="comment">         * 阻塞队列----new ArrayBlockingQueue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">100</span>, <span class="number">30L</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Runnable runnable = () -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();<span class="comment">//执行减一操作</span></span><br><span class="line">            &#125;;</span><br><span class="line">            executor.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+Thread.currentThread().getName()+<span class="string">"等待子线程执行完成..."</span>);</span><br><span class="line">            latch.await();<span class="comment">//阻塞当前线程，直到计数器的值为0</span></span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+Thread.currentThread().getName()+<span class="string">"开始执行..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-停止线程"><a href="#3-停止线程" class="headerlink" title="3.停止线程"></a>3.停止线程</h3><h3 id="3-1使用自定义标记"><a href="#3-1使用自定义标记" class="headerlink" title="3.1使用自定义标记"></a>3.1使用自定义标记</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StopThread1 t = <span class="keyword">new</span> StopThread1();</span><br><span class="line">        t.start();</span><br><span class="line">        t.stopMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停止线程的两种方法</span></span><br><span class="line"><span class="comment"> * 1.自己设置一个标记位</span></span><br><span class="line"><span class="comment"> * 2.利用interrupt()做停止标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行run()方法"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用此自定义方法停止线程"</span>);</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2使用中断标记interrupt"><a href="#3-2使用中断标记interrupt" class="headerlink" title="3.2使用中断标记interrupt()"></a>3.2使用中断标记interrupt()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StopThread2 stopThread2 = <span class="keyword">new</span> StopThread2();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(stopThread2);</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Someone interrupted me."</span>);</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"中断标志位没被清除"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"this thread is running..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-暂停线程"><a href="#4-暂停线程" class="headerlink" title="4.暂停线程"></a>4.暂停线程</h2><p>###4.1<del>暂停suspend() 恢复resume()</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 暂停线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Data</span> 2020/7/8 22:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuspendThreadService test = <span class="keyword">new</span> SuspendThreadService();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test::method);</span><br><span class="line">        t1.setName(<span class="string">"A"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test::method);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暂停线程服务，演示为什么suspend()方法被弃用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuspendThreadService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上同步锁之后，暂停线程就不能释放锁，导致一直处于线程暂停状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程开始"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"A"</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程被暂停"</span>);</span><br><span class="line">            Thread.currentThread().suspend();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Java8 Stream()流处理集合</title>
    <url>/article/67ce2364.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
<a id="more"></a>

<h2 id="下面通过代码了解下"><a href="#下面通过代码了解下" class="headerlink" title="下面通过代码了解下"></a>下面通过代码了解下</h2><h3 id="创建学生类、精英学生类"><a href="#创建学生类、精英学生类" class="headerlink" title="创建学生类、精英学生类"></a>创建学生类、精英学生类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Double score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义精英学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EliteStudent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建两个集合，用于Stream-流处理"><a href="#构建两个集合，用于Stream-流处理" class="headerlink" title="构建两个集合，用于Stream()流处理"></a>构建两个集合，用于Stream()流处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Student&gt;&gt; listFlat;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span><span class="comment">//注解在非静态方法上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"盖伦1"</span>, <span class="number">200</span>, <span class="number">66.0</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"赵信"</span>, <span class="number">21</span>, <span class="number">90.0</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"乐芙兰1"</span>, <span class="number">21</span>, <span class="number">90.0</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">4</span>, <span class="string">"李青"</span>, <span class="number">50</span>, <span class="number">100</span>d),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">"泰达米尔"</span>, <span class="number">600</span>, <span class="number">90</span>d)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        listFlat = Arrays.asList(</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"盖伦1"</span>, <span class="number">200</span>, <span class="number">66.0</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"赵信"</span>, <span class="number">21</span>, <span class="number">90.0</span>)</span><br><span class="line">                ),</span><br><span class="line">                Arrays.asList(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"乐芙兰1"</span>, <span class="number">21</span>, <span class="number">90.0</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">4</span>, <span class="string">"李青"</span>, <span class="number">50</span>, <span class="number">100</span>d)</span><br><span class="line">                ),</span><br><span class="line">                Collections.singletonList(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">"泰达米尔"</span>, <span class="number">600</span>, <span class="number">90</span>d)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//各种流处理方法---------filter</span></span><br><span class="line">    <span class="comment">//----------------------map</span></span><br><span class="line">    <span class="comment">//--------------------reduce等等</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-filter"><a href="#1-filter" class="headerlink" title="1.filter"></a>1.filter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * filter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 过滤出list中学生名字中包括 "1" 的学生集合，</span></span><br><span class="line"><span class="comment">     *       并使用peek()利用其返回Stream&lt;Student&gt;直接以流的方式实现打印过滤出的学生</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *       peek() 和 ForEach() 的区别：</span></span><br><span class="line"><span class="comment">     *       前者返回Stream&lt;T&gt; 可在流的基础上继续流操作</span></span><br><span class="line"><span class="comment">     *       后者返回void,想要继续流操作需要进行二次流处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">filterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Student&gt; collect = list.stream().filter(item -&gt; item.getName().contains(<span class="string">"1"</span>))</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="number">2</span>, collect.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取过滤的第一条数据，如果包含则打印</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list.stream().filter(item -&gt; item.getName().contains(<span class="string">"1"</span>))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-map"><a href="#2-map" class="headerlink" title="2.map"></a>2.map</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 可以将List里面的对象转化成新的对象</span></span><br><span class="line"><span class="comment">     * 1.将学生集合里不小于90分的作为精英学生过滤出来,并打印</span></span><br><span class="line"><span class="comment">     * 2.获取所有学生的 name 集合,并打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;EliteStudent&gt; collect = list.stream().filter(item -&gt; item.getScore() &gt;= <span class="number">90</span>)</span><br><span class="line">                .map(student -&gt; &#123;</span><br><span class="line">                    EliteStudent eliteStudent = <span class="keyword">new</span> EliteStudent();</span><br><span class="line">                    BeanUtils.copyProperties(student, eliteStudent);</span><br><span class="line">                    <span class="keyword">return</span> eliteStudent;</span><br><span class="line">                &#125;).peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="number">3</span>, collect.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; nameList = list.stream().map(Student::getName)</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="number">5</span>, nameList.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-flatMap"><a href="#3-flatMap" class="headerlink" title="3.flatMap"></a>3.flatMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flatMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 将嵌套列表转换为普通列表，例如 List&lt;List&lt;Student&gt;&gt; 转化为 List&lt;Student&gt;</span></span><br><span class="line"><span class="comment">     * 1.将嵌套列表转化成普通列表，断言转化结果 = list</span></span><br><span class="line"><span class="comment">     * 2.转化后获取列表的 id 集合并打印</span></span><br><span class="line"><span class="comment">     * 3.转化后再提取集合的分数，求平均值，打印平均值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatMapTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; collect = listFlat.stream().flatMap(Collection::stream)</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(collect, list);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; idList = listFlat.stream().flatMap(Collection::stream)</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .flatMapToInt(student -&gt; IntStream.of(student.getId()))</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .boxed()</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(idList.size(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        listFlat.stream().flatMap(Collection::stream)</span><br><span class="line">                .mapToDouble(Student::getScore)</span><br><span class="line">                .average()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-sorted"><a href="#4-sorted" class="headerlink" title="4.sorted"></a>4.sorted</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 排序</span></span><br><span class="line"><span class="comment">     * 1.先按照分数倒叙排列，如果分数相同按照年龄正序排列，如果年龄相同按照 id 正序排列，打印</span></span><br><span class="line"><span class="comment">     * 2.如果 reversed() 写在最后，则全部按照倒叙排列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortedTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; collect = list.stream().sorted(Comparator.comparing(Student::getScore).reversed()</span><br><span class="line">                .thenComparing(Student::getAge)</span><br><span class="line">                .thenComparing(Student::getId))</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="string">"李青"</span>, collect.get(<span class="number">0</span>).getName());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"-------------------------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; collect2 = list.stream().sorted(Comparator.comparing(Student::getScore)</span><br><span class="line">                .thenComparing(Student::getAge)</span><br><span class="line">                .thenComparing(Student::getId).reversed())</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="string">"李青"</span>, collect2.get(<span class="number">0</span>).getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-match"><a href="#5-match" class="headerlink" title="5.match"></a>5.match</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * match</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 验证list中的每一项是否匹配我们的条件</span></span><br><span class="line"><span class="comment">     * allMatch 全都匹配</span></span><br><span class="line"><span class="comment">     * anyMatch 任意匹配</span></span><br><span class="line"><span class="comment">     * noneMatch 全不匹配</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 设置匹配条件为正则表达式 ^[1-9]\\d*$ 正整数</span></span><br><span class="line"><span class="comment">     * 1.验证list的id是否全都匹配条件</span></span><br><span class="line"><span class="comment">     * 2.临时改变list的第一个年龄为 -1 验证是否年龄任意一个匹配条件</span></span><br><span class="line"><span class="comment">     * 3.验证分数是否全不匹配条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">matchTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = list.stream().allMatch(item -&gt; ReUtil.isMatch(<span class="string">"^[1-9]\\d*$"</span>, item.getId().toString()));</span><br><span class="line">        log.info(<span class="string">"输出list的id是否全部匹配条件,结果：----------[&#123;&#125;]"</span>, b);</span><br><span class="line"></span><br><span class="line">        list.get(<span class="number">0</span>).setAge(-<span class="number">1</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">        <span class="keyword">boolean</span> b1 = list.stream().anyMatch(item -&gt; ReUtil.isMatch(<span class="string">"^[1-9]\\d*$"</span>, item.getAge().toString()));</span><br><span class="line">        log.info(<span class="string">"输出list的年龄是否任意匹配条件,结果：----------[&#123;&#125;]"</span>, b1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b2 = list.stream().noneMatch(item -&gt; ReUtil.isMatch(<span class="string">"^[1-9]\\d*$"</span>, item.getScore().toString()));</span><br><span class="line">        log.info(<span class="string">"输出list的年龄是否都不匹配条件,结果：----------[&#123;&#125;]"</span>, b2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-reduce"><a href="#6-reduce" class="headerlink" title="6.reduce"></a>6.reduce</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reduce</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 合并流元素产生单个值</span></span><br><span class="line"><span class="comment">     * 1.计算list中所有学生年龄的总和，存在则打印</span></span><br><span class="line"><span class="comment">     * 2.计算list中所有学生年龄的总和，存在则打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.stream().map(Student::getAge)</span><br><span class="line">                .reduce(Integer::sum)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        list.stream().map(Student::getScore)</span><br><span class="line">                .reduce(Double::sum)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-collertor"><a href="#7-collertor" class="headerlink" title="7.collertor"></a>7.collertor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * collector</span></span><br><span class="line"><span class="comment">     * 收集器，主要用于toList() / toSet() / toMap() / joining()连接字符串</span></span><br><span class="line"><span class="comment">     * 1.把list中的id作为key, name作为value转化成Map</span></span><br><span class="line"><span class="comment">     * 2.把学生名字用逗号拼接，并且第一个逗号用星号替换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">collectorTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, String&gt; map = list.stream().collect(Collectors.toMap(Student::getId, Student::getName));</span><br><span class="line">        map.forEach((k, v) -&gt; log.info(<span class="string">"key = &#123;&#125; , value = &#123;&#125;"</span>, k, v));</span><br><span class="line"></span><br><span class="line">        String s = list.stream().map(Student::getName)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">","</span>))</span><br><span class="line">                .replaceFirst(<span class="string">","</span>, <span class="string">"*"</span>);</span><br><span class="line">        log.info(<span class="string">"输出逗号拼接的字符串--&gt;&#123;&#125;"</span>, s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-summarizingDouble"><a href="#8-summarizingDouble" class="headerlink" title="8.summarizingDouble"></a>8.summarizingDouble</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * summarizingDouble</span></span><br><span class="line"><span class="comment">     * 1.计算集合中某个元素的 count / sum / avg / min / max</span></span><br><span class="line"><span class="comment">     * 2.第二种写法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">summarizingDoubleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DoubleSummaryStatistics collect = list.stream()</span><br><span class="line">                .collect(Collectors.summarizingDouble(Student::getScore));</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        DoubleSummaryStatistics doubleSummaryStatistics = list.stream()</span><br><span class="line">                .mapToDouble(Student::getScore)</span><br><span class="line">                .summaryStatistics();</span><br><span class="line">        System.out.println(doubleSummaryStatistics);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-partitioningBy"><a href="#9-partitioningBy" class="headerlink" title="9.partitioningBy"></a>9.partitioningBy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * partitioningBy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 用于分割列表</span></span><br><span class="line"><span class="comment">     * 把学生列表中年龄大于100的放进key为true的Map中</span></span><br><span class="line"><span class="comment">     * 小于等于100的放进key为false的Map中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partitioningByTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Boolean, List&lt;Student&gt;&gt; map = list.stream()</span><br><span class="line">                .collect(Collectors.partitioningBy(e -&gt; e.getAge() &gt; <span class="number">100</span>));</span><br><span class="line">        log.info(<span class="string">"true列表 = &#123;&#125;"</span>, map.get(Boolean.TRUE));</span><br><span class="line">        log.info(<span class="string">"false列表 = &#123;&#125;"</span>, map.get(Boolean.FALSE));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-groupingBy"><a href="#10-groupingBy" class="headerlink" title="10.groupingBy"></a>10.groupingBy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * groupingBy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 分组</span></span><br><span class="line"><span class="comment">     * 1.根据成绩分组</span></span><br><span class="line"><span class="comment">     * 2.获取每个分数的人数</span></span><br><span class="line"><span class="comment">     * 3.根据成绩获取取得每个成绩的学生的总分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">groupingByTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Double, List&lt;Student&gt;&gt; map1 = list.stream().collect(Collectors.groupingBy(Student::getScore));</span><br><span class="line">        map1.forEach((k, v) -&gt; System.out.println(k + <span class="string">"\t"</span> + v));</span><br><span class="line"></span><br><span class="line">        Map&lt;Double, Long&gt; map2 = list.stream().collect(Collectors.groupingBy(Student::getScore, Collectors.counting()));</span><br><span class="line">        map2.forEach((k,v) -&gt; System.out.println(k + <span class="string">"\t"</span> + v));</span><br><span class="line"></span><br><span class="line">        Map&lt;Double, Double&gt; map3 = list.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Student::getScore, Collectors.summingDouble(Student::getScore)));</span><br><span class="line">        map3.forEach((k, v) -&gt; System.out.println(k + <span class="string">"\t"</span> + v));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-parallel"><a href="#11-parallel" class="headerlink" title="11.parallel"></a>11.parallel</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * parallel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 并发</span></span><br><span class="line"><span class="comment">     * 延迟一秒后，并发的打印出学生的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parallel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.stream().parallel().forEach(<span class="keyword">this</span>::print);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"学生的名字是 ： &#123;&#125;"</span>, student.getName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-读写文件"><a href="#12-读写文件" class="headerlink" title="12.读写文件"></a>12.读写文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DESC</span> 读写文件</span></span><br><span class="line"><span class="comment">     * 先把list中的数据写到student.txt中</span></span><br><span class="line"><span class="comment">     * 再读取出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fileTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(Files.newBufferedWriter(Paths.get(<span class="string">"D://student.txt"</span>)));</span><br><span class="line">        <span class="comment">//list列表写出到文件student.txt中</span></span><br><span class="line">        list.forEach(printWriter::println);</span><br><span class="line">        printWriter.close();</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        List&lt;String&gt; collect = Files.lines(Paths.get(<span class="string">"D://student.txt"</span>))</span><br><span class="line">                .peek(System.out::println)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        Assertions.assertEquals(<span class="number">5</span>, collect.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Stream()流</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman使用的几个小技巧</title>
    <url>/article/b811dc66.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Postman使用的几个小技巧"><a href="#Postman使用的几个小技巧" class="headerlink" title="Postman使用的几个小技巧"></a>Postman使用的几个小技巧</h2><h3 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1.环境变量"></a>1.环境变量</h3><ul>
<li>调用方式 </li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-1.png" alt="image-20200611212208754"></p>
<a id="more"></a>

<p>如上图标注位置，可以切换、查看、管理环境，在环境中可以指定环境变量，供Postman进行相应环境下的全局调用。</p>
<p>真正的不分环境的全局变量可设置成全局变量。</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-2.png" alt="image-20200611212530159"></p>
<ul>
<li><p>例如我在环境 变量中设置了一个变量 <code>url_base</code> 值为 <code>localhost:8080</code>之后每次测试接口就直接调用<code></code>就可以了。</p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-3.png" alt="image-20200611215620570"></p>
</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-4.png" alt="image-20200611222906182"></p>
<h3 id="2-设置接口调用前执行脚本"><a href="#2-设置接口调用前执行脚本" class="headerlink" title="2.设置接口调用前执行脚本"></a>2.设置接口调用前执行脚本</h3><ul>
<li>例如：登录之前需要执行一个接口获取验证码，</li>
<li>然后将返回结果中的验证码设置到环境中</li>
<li>供登录接口作为参数调用</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/image-20200611221039122.png" alt="image-20200611221039122"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送一个Get请求</span></span><br><span class="line">pm.sendRequest(<span class="string">"http://127.0.0.1:8080/api/account/getverifycode"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//打印返回的json结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(response.json());</span><br><span class="line">    <span class="comment">//从返回的结果中设置变量到环境中</span></span><br><span class="line">    pm.environment.set(<span class="string">"text"</span>, response.json().data.text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-6.png" alt="image-20200611221333496"></p>
<h3 id="3-设置调用之后的Test脚本"><a href="#3-设置调用之后的Test脚本" class="headerlink" title="3.设置调用之后的Test脚本"></a>3.设置调用之后的<code>Test</code>脚本</h3><ul>
<li>我们可以在Tests中书写捷空运调用之后执行的脚本，可以进行结果断言、控制台打印、设置变量等等</li>
<li>例如登录成功之后，打印返回token到控制台，postman控制台在软件左下角，并把token设置为环境变量</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-7.png" alt="image-20200611220545705"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取返回结果</span></span><br><span class="line"><span class="keyword">var</span> jsonData = <span class="built_in">JSON</span>.parse(responseBody);</span><br><span class="line"><span class="comment">//打印返回结果中的token到控制台</span></span><br><span class="line"><span class="built_in">console</span>.log(jsonData.data);</span><br><span class="line"><span class="comment">//设置返回结果的token为变量到环境中</span></span><br><span class="line">pm.environment.set(<span class="string">"token"</span>, jsonData.data);</span><br></pre></td></tr></table></figure>

<h3 id="4-登录成功的Token的使用"><a href="#4-登录成功的Token的使用" class="headerlink" title="4.登录成功的Token的使用"></a>4.登录成功的Token的使用</h3><ul>
<li>登录成功之后的Token被我们使用脚本存储到环境中，在之后测试需要登录的接口的时候，我们需要将这个token加到Headers请求头中，但是每个接口都要设置一次太麻烦</li>
<li>找了很久没有发现设置一次性解决方案</li>
<li>最后发现了一个提前设置好，一键添加的方案</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-8.png" alt="image-20200611222149293"></p>
<ul>
<li>之后测试接口的时候可以直接点击这里，一键设置token到请求头</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-9.png" alt="image-20200611222316152"></p>
<ul>
<li>效果：</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202006/11-b811dc66-10.png" alt="image-20200611222359442"></p>
]]></content>
      <tags>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>java链接Lettuce客户端操作</title>
    <url>/article/dc5eed37.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="java使用Lettuce客户端连接redis学习基本redis指令"><a href="#java使用Lettuce客户端连接redis学习基本redis指令" class="headerlink" title="java使用Lettuce客户端连接redis学习基本redis指令"></a>java使用Lettuce客户端连接redis学习基本redis指令</h2><ul>
<li><p>参考try.redis.io进行以下几种存储类型的指令学习</p>
</li>
<li><p>string、list、set、zset、hash</p>
</li>
</ul>
<p>由于Springboot 2.0 中redis客户端使用了Lettue,所以没使用jedis进行学习，依赖由于项目中引入了以下依赖，所以就不用别的了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--因为Springboot 2.0 中redis客户端使用了Lettue, 其依赖于commons--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>操作基本指令代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yunqing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 参考 try.redis.io</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/3 16:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisClient redisClient;</span><br><span class="line">    StatefulRedisConnection&lt;String, String&gt; redisConnection;</span><br><span class="line">    RedisCommands&lt;String, String&gt; sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@BeforeEach</span> 注解在非静态方法上，所有测试方法之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@BeforeAll</span> 注解在静态方法上，所有测试方法之前执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connRedisByLettuce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisURI redisUri = RedisURI.builder()</span><br><span class="line">            .withHost(<span class="string">"127.0.0.1"</span>)</span><br><span class="line">            .withPort(<span class="number">6379</span>)</span><br><span class="line">            .withTimeout(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS))</span><br><span class="line">            .build();</span><br><span class="line">        redisClient = RedisClient.create(redisUri);</span><br><span class="line">        redisConnection = redisClient.connect();</span><br><span class="line">        sync = redisConnection.sync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closeConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisConnection.close();</span><br><span class="line">        redisClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string类型set get</span></span><br><span class="line"><span class="comment">     * ttl 返回-1永不超时</span></span><br><span class="line"><span class="comment">     * ttl 返回-2不存在此key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(sync.set(<span class="string">"k1"</span>, <span class="string">"v1"</span>));</span><br><span class="line">        sync.expire(<span class="string">"k1"</span>, <span class="number">1000</span>); <span class="comment">//设置1000秒超时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(sync.ttl(<span class="string">"k1"</span>).toString()); <span class="comment">//获取剩余超时时间</span></span><br><span class="line">        log.info(sync.get(<span class="string">"k1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis 列表，相当于链表</span></span><br><span class="line"><span class="comment">     * lpush 左侧添加，是可变参数，可同时追加多个</span></span><br><span class="line"><span class="comment">     * rpush 右侧添加，是可变参数，可同时追加多个</span></span><br><span class="line"><span class="comment">     * lrange key 0 -1 获取列表第一到最后一个</span></span><br><span class="line"><span class="comment">     * lpop key 删除列表左侧第一个</span></span><br><span class="line"><span class="comment">     * rpop key 删除列表右侧第一个</span></span><br><span class="line"><span class="comment">     * llen key 获取当前列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.rpush(<span class="string">"friends"</span>, <span class="string">"Tom"</span>, <span class="string">"yunqing"</span>);</span><br><span class="line">        sync.rpush(<span class="string">"friends"</span>, <span class="string">"Bob"</span>, <span class="string">"kkk"</span>);</span><br><span class="line">        sync.lpush(<span class="string">"friends"</span>, <span class="string">"peter"</span>);</span><br><span class="line">        log.info(sync.llen(<span class="string">"friends"</span>).toString());</span><br><span class="line">        List&lt;String&gt; friends = sync.lrange(<span class="string">"friends"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        friends.forEach(System.out::println);</span><br><span class="line">        sync.lpop(<span class="string">"friends"</span>);</span><br><span class="line">        sync.rpop(<span class="string">"friends"</span>);</span><br><span class="line">        List&lt;String&gt; friends2 = sync.lrange(<span class="string">"friends"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        friends2.forEach(System.out::println);</span><br><span class="line">        log.info(sync.llen(<span class="string">"friends"</span>).toString());</span><br><span class="line">        sync.expire(<span class="string">"friends"</span>, <span class="number">10</span>);<span class="comment">//设置1000秒过期</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis  set集合</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.sadd(<span class="string">"names"</span>, <span class="string">"yunqing"</span>, <span class="string">"kkk"</span>, <span class="string">"tom"</span>, <span class="string">"tom"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>);</span><br><span class="line">        log.info(<span class="string">"输出set集合[&#123;&#125;]"</span>, String.valueOf(sync.smembers(<span class="string">"names"</span>)));</span><br><span class="line">        log.info(<span class="string">"测试是否存在---------[&#123;&#125;]"</span>, sync.sismember(<span class="string">"names"</span>, <span class="string">"yunqing"</span>));</span><br><span class="line">        log.info(<span class="string">"删除结果1成功，0失败---------[&#123;&#125;&#125;]"</span>, sync.srem(<span class="string">"names"</span>, <span class="string">"tom"</span>));</span><br><span class="line">        log.info(<span class="string">"输出集合[&#123;&#125;]"</span>, sync.smembers(<span class="string">"names"</span>));</span><br><span class="line">        sync.expire(<span class="string">"names"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带排序的set集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisZSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">1</span>, <span class="string">"yunqing"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">3</span>, <span class="string">"tom"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">2</span>, <span class="string">"kkk"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">10</span>, <span class="string">"tom"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">5</span>, <span class="string">"peter"</span>);</span><br><span class="line">        sync.zadd(<span class="string">"names"</span>, <span class="number">5</span>, <span class="string">"bob"</span>);</span><br><span class="line">        log.info(<span class="string">"查看集合所有[&#123;&#125;]---------"</span>, sync.zrange(<span class="string">"names"</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        log.info(<span class="string">"删除一个-----[&#123;&#125;]"</span>, sync.zrem(<span class="string">"names"</span>, <span class="string">"peter"</span>));</span><br><span class="line">        log.info(<span class="string">"查看集合所有[&#123;&#125;]---------"</span>, sync.zrange(<span class="string">"names"</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">        sync.expire(<span class="string">"names"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash格式存储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.hset(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"yunqing"</span>);</span><br><span class="line">        sync.hset(<span class="string">"user"</span>, <span class="string">"age"</span>, <span class="string">"26"</span>);</span><br><span class="line">        log.info(<span class="string">"获取所有-----[&#123;&#125;]"</span>, sync.hgetall(<span class="string">"user"</span>));</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"sex"</span>, <span class="string">"男"</span>);</span><br><span class="line">        map.put(<span class="string">"email"</span>, <span class="string">"10001"</span>);</span><br><span class="line">        sync.hmset(<span class="string">"user"</span>, map);</span><br><span class="line">        log.info(<span class="string">"获取所有-----[&#123;&#125;]"</span>, sync.hgetall(<span class="string">"user"</span>));</span><br><span class="line">        log.info(<span class="string">"获取一个------[&#123;&#125;]"</span>, sync.hget(<span class="string">"user"</span>, <span class="string">"email"</span>));</span><br><span class="line">        sync.expire(<span class="string">"user"</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用redis特性来创建每日流水号</title>
    <url>/article/8f6dc9b4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这里需求是创建每日的流水号，例如：每向数据库中添加一条数据，其编号设置为yyyyMMdd0001、yyyyMMdd0002这样的格式，日期加后四位为当日流水号，也就是当日第几个添加的数据。</p>
</blockquote>
<a id="more"></a>

<ul>
<li>为什么考虑使用redis呢？</li>
</ul>
<p>额、redis的特性就不介绍了，反正本文也不是介绍redis怎么使用的…</p>
<p>简而言之，为了显示自己用过redis而用，哈哈哈</p>
<ul>
<li>这里docker启动redis遇到一个问题，记录一下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建容器的时候报错WARNING: IPv4 forwarding is disabled. Networking will not work.</span></span><br><span class="line"><span class="comment">#这个错导致连接不上redis，但是在容器内部docker exec -it redis bash     redis-cli能够使用</span></span><br><span class="line"><span class="comment">#我启动redis容器的命令</span></span><br><span class="line">docker run -d --privileged=<span class="literal">true</span> --restart=always -p 6379:6379 -v /usr/docker/redis/data:/data --name redis redis:latest redis-server --appendonly yes</span><br><span class="line"><span class="comment">#解决办法</span></span><br><span class="line">vim  /usr/lib/sysctl.d/00-system.conf</span><br><span class="line"><span class="comment">#添加下面这行</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"><span class="comment">#重启network</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="comment">#删除错误的重启重新执行启动redis的命令</span></span><br><span class="line">docker stop redis</span><br><span class="line">docker rm redis</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个spring boot项目，在pom.xml中引入如下依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--因为Springboot 2.0 中redis客户端使用了Lettue, 其依赖于commons--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置application.yml连接redis</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.16</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># 连接超时时间（记得添加单位，Duration）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10000ms</span></span><br><span class="line">    <span class="comment"># Redis默认情况下有16个分片，这里配置具体使用的分片</span></span><br><span class="line">    <span class="comment"># database: 0</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接 默认 8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接 默认 0</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建redis操作类，这里主要利用的redis自增操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Title</span>: incr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 获取redis自增序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis的 key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 自增的增量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> l = redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"redis获取"</span> + key + <span class="string">"失败"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Title</span>: expire</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 设置过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"redis设置"</span> + key + <span class="string">"过期时间失败"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>把获取到的redis自增的序号格式化成指定格式0001/0002/…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将传入的数 seq 格式化成 length 位，不够前边补 0</span></span><br><span class="line"><span class="comment">     * 如果 length &lt; 3 则按照 3 算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSequence</span><span class="params">(<span class="keyword">long</span> seq, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(seq);</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        length = Math.max(length, DEFAULT_LENGTH);</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= length) &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rest = length - len;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试获取到的yyyyMMdd0001格式的每日流水号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoRedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String  SERIAL_NUM= <span class="string">"redis:serialNumber:"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RedisCacheTemplate redisCacheTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String currentDate = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">		String key = SERIAL_NUM + currentDate;</span><br><span class="line">		<span class="keyword">long</span> incr = redisCacheTemplate.incr(key, <span class="number">1</span>, <span class="number">86400</span>);</span><br><span class="line">		<span class="comment">//移位运算符&lt;&lt;，左移几位相当于乘以2的几次方, 1 &lt;&lt; 2 = 4</span></span><br><span class="line">		String code = SequenceUtil.getSequence(incr, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">		log.info(currentDate + code);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释一下：用redis:serialNumber:20200409这个作为redis的key去查找自增值，每次执行加1</p>
<p>redis中的key-value将是这样：</p>
<p>key                                                               value</p>
<p>redis:serialNumber:20200409                0001</p>
<p>redis:serialNumber:20200409                0002</p>
<p>…</p>
<p>直到下一天key变成了redis:serialNumber:20200410,value则会从0001开始递增</p>
<p>又因为我设置了redis的过期时间是86400秒 = 1天，所以过期的数据会自动删除</p>
</blockquote>
<ul>
<li>看一下控制台的log日志</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/09-8f6dc9b4-1.png" alt="09-8f6dc9b4-1"></p>
<ul>
<li>在执行一次</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/09-8f6dc9b4-2.png" alt="09-8f6dc9b4-2"></p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>基于mybatis plus讲解一些知识点</title>
    <url>/article/cf7f7e62.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mybatis-plus之主键生成策略"><a href="#mybatis-plus之主键生成策略" class="headerlink" title="mybatis plus之主键生成策略"></a>mybatis plus之主键生成策略</h2><h3 id="1-自增策略"><a href="#1-自增策略" class="headerlink" title="1.自增策略"></a>1.自增策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.AUTO)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure>

<h3 id="2-雪花生成器（推）"><a href="#2-雪花生成器（推）" class="headerlink" title="2.雪花生成器（推）"></a>2.雪花生成器（推）</h3>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.ASSIGN_ID)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="3-UUID"><a href="#3-UUID" class="headerlink" title="3.UUID"></a>3.UUID</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.ASSIGN_UUID)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>自3.3.0开始,默认使用雪花算法+UUID(不含中划线)</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th>主键生成策略</th>
<th>主键类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nextId</td>
<td>ASSIGN_ID，<del>ID_WORKER，ID_WORKER_STR</del></td>
<td>Long,Integer,String</td>
<td>支持自动转换为String类型，但数值类型不支持自动转换，需精准匹配，例如返回Long，实体主键就不支持定义为Integer</td>
</tr>
<tr>
<td align="center">nextUUID</td>
<td>ASSIGN_UUID，<del>UUID</del></td>
<td>String</td>
<td>默认不含中划线的UUID生成</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-Sequence主键"><a href="#4-Sequence主键" class="headerlink" title="4.Sequence主键"></a>4.Sequence主键</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@KeySequence</span>(value = <span class="string">"SEQ_ORACLE_STRING_KEY"</span>, clazz = String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">YourEntity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"ID_STR"</span>, type = IdType.INPUT)</span><br><span class="line">    <span class="keyword">private</span> String idStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>主键生成策略必须使用INPUT</strong></p>
</blockquote>
<blockquote>
<p>支持父类定义@KeySequence子类继承使用</p>
</blockquote>
<p>内置支持：</p>
<ul>
<li>DB2KeyGenerator</li>
<li>H2KeyGenerator</li>
<li>KingbaseKeyGenerator</li>
<li>OracleKeyGenerator</li>
<li>PostgreKeyGenerator</li>
</ul>
<blockquote>
<p>如果内置支持不满足你的需求，可实现IKeyGenerator接口来进行扩展.</p>
</blockquote>
<h4 id="SpringBoot方式一：配置类"><a href="#SpringBoot方式一：配置类" class="headerlink" title="SpringBoot方式一：配置类"></a>SpringBoot方式一：配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IKeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> H2KeyGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SpringBoot方式二：通过MybatisPlusPropertiesCustomizer自定义"><a href="#SpringBoot方式二：通过MybatisPlusPropertiesCustomizer自定义" class="headerlink" title="SpringBoot方式二：通过MybatisPlusPropertiesCustomizer自定义"></a>SpringBoot方式二：通过MybatisPlusPropertiesCustomizer自定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MybatisPlusPropertiesCustomizer <span class="title">plusPropertiesCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plusProperties -&gt; plusProperties.getGlobalConfig().getDbConfig().setKeyGenerator(<span class="keyword">new</span> H2KeyGenerator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatis-plus之自动填充字段功能"><a href="#mybatis-plus之自动填充字段功能" class="headerlink" title="mybatis plus之自动填充字段功能"></a>mybatis plus之自动填充字段功能</h2><ul>
<li>个人比较喜欢这个功能，尤其是用于<code>create_time</code>和<code>update_time</code>两个字段的自动填充。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注意：设置此字段为自动填充字段，即添加记录的时候自动添加创建时间</span></span><br><span class="line"><span class="comment">    * 需要配置实现接口 MetaObjectHandler</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@TableField</span>(fill = FieldFill.INSERT)</span><br><span class="line">   <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注意：设置此字段为自动填充字段，添加或更新记录时候，此字段自动填充</span></span><br><span class="line"><span class="comment">    * 需要配置实现接口 MetaObjectHandler</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@TableField</span>(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line">   <span class="keyword">private</span> LocalDateTime updateTime;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要实现接口<code>MetaObjectHandler</code>元数据处理器接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现添加的时候自动填充的字段</span></span><br><span class="line"><span class="comment">     * 添加记录的时候自动设置创建时间和修改时间为当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"createTime"</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改的时候自动填充的字段, 填充为当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatis-plus之乐观锁"><a href="#mybatis-plus之乐观锁" class="headerlink" title="mybatis plus之乐观锁"></a>mybatis plus之乐观锁</h2><ul>
<li>首先了解一下什么是乐观锁？什么是悲观锁？</li>
</ul>
<blockquote>
<p>乐观锁与悲观锁都是用来解决并发情况下写操作可能会导致的<strong>丢失更新</strong>的问题。</p>
</blockquote>
<ul>
<li>什么是并发操作下造成的读的问题 ？</li>
</ul>
<blockquote>
<p>首先来说如果不考虑事务的隔离性，会产生几个读的问题，<strong>脏读、不可重复读、幻读</strong></p>
<p><strong>脏读</strong>：读到未提交的数据，也就是事务A读到事务B更改后的数据，事务B异常回滚了，所以事务A读到的是脏数据。</p>
<p><strong>不可重复读</strong>：例如事务A读到小李30岁，这时候事务B把小李改成20岁提交了，事务A未结束又读了一遍，发现小李变成了20岁。</p>
<p><strong>幻读</strong>：例如事务A读员工数量200人，这时候事务B添加了5条员工数据并提交，这时候事务A未结束，又读取了一遍员工数量，发现变成了205条。</p>
</blockquote>
<ul>
<li><p>额、上面简单总结一下，不考虑事务的隔离级别的情况下可能造成的读的问题。</p>
</li>
<li><p>事务的隔离级别有什么呢？</p>
</li>
</ul>
<blockquote>
<p>1、Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大；</p>
</blockquote>
<blockquote>
<p>2、REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。</p>
</blockquote>
<blockquote>
<p>3、READ COMMITTED （读提交）：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。</p>
</blockquote>
<blockquote>
<p>4、Read Uncommitted（读未提交） ：事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。</p>
</blockquote>
<ul>
<li>mysql默认的事务隔离级别是：可重复读</li>
</ul>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong>可重复读（repeatable-read）</strong></td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
<td><strong>是</strong></td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li>什么是并发写操作造成的丢失更新？</li>
</ul>
<blockquote>
<p>例如事务A和事务B同时修改小明的工资，他们两个读取到的小明工资都是2000然后事务A更改了小明工资为3000后提交，这时候事务B更改了小明的工资为5000，提交之后事务A对工资的更新就丢失了。结果为5000</p>
</blockquote>
<blockquote>
<p>悲观锁和乐观锁就是为了解决并发操作造成的丢失更新问题:</p>
<p><strong>悲观锁：</strong>顾名思义，就是悲观的认为并发问题一定会出现，所以在对一个数据进行操作的时候一定会加锁，因为他认为不加锁一定会产并发问题。</p>
<p><strong>乐观锁：</strong>顾名思义，就是乐观的认为读取数据的时候不会有其他事务进行修改，所以不会加锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用<strong>版本号机制</strong>或<strong>CAS操作</strong>实现。这里mybatis plus使用的就是版本号机制实现的乐观锁。</p>
</blockquote>
<ul>
<li>先介绍一下CAS操作：Compare and Swap，即比较再交换。</li>
</ul>
<blockquote>
<p>java中有一个并发包<code>java.util.concurrent.*</code>,这个包中的类就是使用CAS算法实现了乐观锁。之前java语言靠<code>synchronized</code>关键字保证同步，使用<code>synchronized</code>关键字是一种独占锁，属于悲观锁。</p>
</blockquote>
<ul>
<li>CAS的功能是判断内存中的某个位置的值是否为预期值，如果是则改变为新的值，这个过程是原子的。</li>
</ul>
<blockquote>
<p>CAS算法实现的一个前提是需要取出内存中某时刻的数据，并在当前时间进行比较并替换，那么在这个时间差内，如果线程A从内存V处取出值为1，这时候另一个线程B也在内存V处取出值为1，并且线程B经过一些操作将值改成了2，然后线程B又经过操作将值改回1，这时候线程A操作CAS发现内存中的值仍为1，然后线程A操作成功改了V处的值为3。</p>
<p>尽管这个线程A的CAS操作执行成功，但是并不代表这个过程是没有问题的。这就是著名的<code>ABA问题</code>。</p>
</blockquote>
<ul>
<li>如何解决ABA问题？使用版本号！mybatis plus就是使用版本号来实现乐观锁的。</li>
</ul>
<blockquote>
<p>可以使用版本号来解决，例如:数据库中添加一个版本号，取出记录的时候，获取当前的版本号，更新数据的时候，带上这个版本号，即 update set version = newVersion where version = oldVersion,如果版本号不等于之前的版本号，说明已经被更改过了，即本次更新失败。</p>
</blockquote>
<ul>
<li>使用mybatis plus实现乐观锁</li>
</ul>
<ol>
<li>表中添加字段，作为乐观锁的版本号</li>
<li>对应实体类添加属性version</li>
<li>在实体类版本号属性上添加@Version注解</li>
<li>配置mybatis plus乐观锁的插件</li>
<li>（可选）可以利用之前讲的自动填充在添加记录的时候给Version一个默认值1</li>
</ol>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-1.png" alt="image-20200406185428516"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 版本号属性</span></span><br><span class="line"><span class="comment"> * 设置此字段在添加的时候自动设置version值为 1</span></span><br><span class="line"><span class="comment"> * 需要配置实现接口 MetaObjectHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="meta">@TableField</span>(fill = FieldFill.INSERT)</span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.yunqing.demomybatisplus.mapper"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//配置乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现添加的时候自动填充的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置添加role记录的时候自动填充版本号为1</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"version"</span>, <span class="string">"1"</span>, metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试使用乐观锁进行更新数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ActiveRecord修改</span></span><br><span class="line"><span class="comment">     * UPDATE t_role SET role_code=?, role_name=?, update_time=?, version=? WHERE id=? AND version=?</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * UPDATE t_role SET create_time=? WHERE (id = ?)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 测试乐观锁更新Role,先查询获取版本号，在更新，之后再获取版本号</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Role role = <span class="keyword">new</span> Role().selectById(<span class="number">2L</span>);</span><br><span class="line">        log.info(<span class="string">"更新之前获取版本号 = &#123;&#125;"</span>, role.getVersion());</span><br><span class="line">        role.setRoleName(<span class="string">"管理员1234"</span>);</span><br><span class="line">        Assertions.assertTrue(role.updateById());</span><br><span class="line">        Role role2 = <span class="keyword">new</span> Role().selectById(<span class="number">2L</span>);</span><br><span class="line">        log.info(<span class="string">"更新之后获取版本号 = &#123;&#125;"</span>, role2.getVersion());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 非乐观锁更新，直接更新</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Assertions.assertTrue(<span class="keyword">new</span> Role().update(<span class="keyword">new</span> UpdateWrapper&lt;Role&gt;().lambda()</span><br><span class="line">                .set(Role::getCreateTime, LocalDateTime.now()).eq(Role::getId, <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到控制台如下输出：</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-2.png" alt="image-20200406191834047"></p>
<ul>
<li><strong>适用场景：读取频繁使用乐观锁，写入频繁使用悲观锁</strong></li>
</ul>
<h2 id="mybatis之逻辑删除"><a href="#mybatis之逻辑删除" class="headerlink" title="mybatis之逻辑删除"></a>mybatis之逻辑删除</h2><ul>
<li>之前我们做逻辑删除，需要先在数据库创建标志位，之后删除语句也成修改，修改标志位的值，查询的时候还要添加where deleted = 0 来查询没被删除的。</li>
<li>mybatis 提供了一个注解<code>@TableLogic</code>来让我们不再需要关注这个标志位。</li>
<li>只需要给实体类中的逻辑删除字段加上此注解即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逻辑删除标志位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行删除操作，默认就是逻辑删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试逻辑删除</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ljDeleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Assertions.assertTrue(<span class="keyword">new</span> Role().setId(<span class="number">2L</span>).deleteById());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看到上面测试代码执行的是mybatis plus的删除操作，看一下控制行输出代码，执行的却是update</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-3.png" alt="05-cf7f7e62-3"></p>
<ul>
<li>由下图可以看到，id为2的这条数据被逻辑删除了 deleted = 1</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-4.png" alt="05-cf7f7e62-4"></p>
<ul>
<li>之后执行查询的时候也不用关注这个逻辑删除标志位了，默认查询未被删除的数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试查询，看看逻辑删除的数据是否还在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Role&gt; roles = <span class="keyword">new</span> Role().selectAll();</span><br><span class="line">    roles.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看控制台输出的sql 自动帮我们加上了<code>where deleted = 0</code>并且遍历结果集，没有被逻辑删除的id = 2的数据。</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202004/05-cf7f7e62-5.png" alt="05-cf7f7e62-5"></p>
<blockquote>
<p>以后再写查询再也不用关注是否被逻辑删除了，但是这也造成了另一个问题，假如我们想要查询被逻辑删除的数据怎么办？？？</p>
<p>这就要通过在<code>mapper.xml</code>中手写sql来完成啦，也很方便，毕竟查询被逻辑删除的数据的业务需求几乎没有。</p>
</blockquote>
<p><a href="https://mybatis.plus/guide/logic-delete.html" target="_blank" rel="noopener external nofollow noreferrer" class="LinkCard">更多自定义配置☞官方文档</a></p>
<p><a href="https://github.com/kangqing/boot-demos/tree/master/demo-mybatis-plus" target="_blank" rel="noopener external nofollow noreferrer" class="LinkCard">以上代码地址☞见github</a></p>
]]></content>
      <tags>
        <tag>mybatis plus</tag>
        <tag>乐观锁</tag>
        <tag>悲观锁</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo之next主题美化</title>
    <url>/article/29e1e123.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>安装<code>nodejs/git/hexo</code>初始化这些基本就不讲了，网上一找一大堆，直接从入手<code>next</code>主题开始.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入博客根目录，从git拉取next主题到themes目录下重命名为next</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.启用主题，博客根目录，`_config.yml`中找theme</span></span><br><span class="line"><span class="string">theme</span> <span class="string">:next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.next包含四套主题，进入next目录下的`_config.yml`查找scheme,选择哪个自己取消注释</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.设置语言，根目录`_config.yml`中language</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.设置菜单及对应页面，next下`_config.yml`中查找menu</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.1上面新建菜单如果要翻译成中文去next-language-zh-CN.yml中自定义</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">资源</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>头像优化</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># next/_config.yml中查找avatar</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">http://xxxxxxxxxx</span>  <span class="comment">#你的头像地址</span></span><br><span class="line"><span class="comment"># 站点内地址	图片放至themes/next/source/images/配置为：avatar: /images/图片名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网站图标设置，查找favicon</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span>  <span class="comment">#你的网站图标16x16</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span> <span class="comment">#你的网站图标32x32</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文章时候自动打开Typora</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 在next/scripts下创建events.js文件</span><br><span class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"><span class="comment">// Hexo 3 用户复制这段</span></span><br><span class="line">hexo.on(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  spawn(<span class="string">'start  "D:/software/Typora/Typora.exe" '</span> + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给代码段更换成mac panel风格</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于使用的是next7主题，所以直接到hexo下_config.yml中设置高亮配置即可</span></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: </span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span></span><br><span class="line">  <span class="comment"># 添加复制按钮</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 显示文本复制结果。</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>使用<code>algolia搜索</code></p>
<p>去<a href="https://www.algolia.com/注册账号" target="_blank" rel="noopener external nofollow noreferrer">https://www.algolia.com/注册账号</a></p>
<p>[参考了此篇文章](<a href="http://www.werty.cn/2019/07/hexo/hexo" target="_blank" rel="noopener external nofollow noreferrer">http://www.werty.cn/2019/07/hexo/hexo</a> algolia命令执行失败解决方案/)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载插件</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-algolia</span> <span class="string">--save</span></span><br><span class="line"><span class="comment"># 配置环境变量windows参考上面那篇文章</span></span><br><span class="line"><span class="comment"># 根目录_config.yml配置</span></span><br><span class="line"><span class="comment"># Algolia Search API Key</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">applicationID:</span> <span class="string">你的applicationID</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">你的apiKey</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="string">你的索引名字</span></span><br><span class="line"><span class="comment"># hexo的_config.yml配置</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">搜索关键字文章</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">"我们没有找到任何搜索结果: $&#123;query&#125;"</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">"查找到 $&#123;hits&#125; 个结果，用时 $&#123;time&#125; ms"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>额不多说了，参照这两位大佬的吧，配置的很<code>nice</code></p>
<p><a href="https://tding.top/" target="_blank" rel="noopener external nofollow noreferrer">大佬博客：小丁的个人博客</a></p>
<p><a href="https://hasaik.com/" target="_blank" rel="noopener external nofollow noreferrer">大佬博客：Xu’s Blog</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo美化</tag>
      </tags>
  </entry>
  <entry>
    <title>用Docker安装nginx和vsftpd搭建文件服务器</title>
    <url>/article/11c2cd82.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="用Docker安装nginx和vsftpd搭建文件服务器"><a href="#用Docker安装nginx和vsftpd搭建文件服务器" class="headerlink" title="用Docker安装nginx和vsftpd搭建文件服务器"></a>用Docker安装nginx和vsftpd搭建文件服务器</h2><h3 id="讲真的我这辈子绝对不会学docker—————–能香，哈哈！"><a href="#讲真的我这辈子绝对不会学docker—————–能香，哈哈！" class="headerlink" title="讲真的我这辈子绝对不会学docker—————–能香，哈哈！"></a>讲真的我这辈子绝对不会学docker—————–能香，哈哈！</h3><p>docker在centos7的安装方式建议看官网教程，不然docker安装nginx很可能出错。</p>
<p><a href="https://www.jianshu.com/p/3b28f3416dda" target="_blank" rel="noopener external nofollow noreferrer">安装docker可以直接参照我简书上的安装过程</a></p>
<a id="more"></a>

<ul>
<li><p>用docker安装Nginx的过程又学到了很多，例如复制docker容器内的文件到宿主机上等等</p>
</li>
<li><p>使用nginx的很重要的一点是修改nginx.conf这个配置文件</p>
</li>
<li><p>首先从dockerhub上拉取nginx最新的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>先简单的启动一个nginx容器，为了从容器中复制nginx.conf文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker启动nginx容器，命名为test</span></span><br><span class="line">docker run --name <span class="built_in">test</span> -d nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看nginx容器id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h2 id="注意：docker启动nginx需要两个配置文件"><a href="#注意：docker启动nginx需要两个配置文件" class="headerlink" title="注意：docker启动nginx需要两个配置文件"></a>注意：docker启动nginx需要两个配置文件</h2></li>
</ul>
<p>  <a href="https://blog.csdn.net/weixin_42880943/article/details/100777093?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener external nofollow noreferrer" class="LinkCard">此处参考☛迷彩诱惑的青春</a></p>
<ul>
<li><p>一个是位于容器内部的<code>/etc/nginx/nginx.conf</code></p>
</li>
<li><p>另一个是位于容器内部的<code>/etc/nginx/conf.d/default.conf</code></p>
</li>
<li><p><code>default.conf</code>配置的是<code>server { }</code>的内容</p>
<h2 id="所以在这里我们需要把这两个配置文件复制到宿主机用于挂载"><a href="#所以在这里我们需要把这两个配置文件复制到宿主机用于挂载" class="headerlink" title="所以在这里我们需要把这两个配置文件复制到宿主机用于挂载"></a>所以在这里我们需要把这两个配置文件复制到宿主机用于挂载</h2></li>
</ul>
<ul>
<li><p>创建目录用于存放nginx.conf 和 default.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -p创建多级目录</span></span><br><span class="line">mkdir /usr/docker/nginx -p</span><br><span class="line">mkdir /usr/docker/nginx/conf.d/ -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>从nginx容器中复制出nginx文件到刚才新建的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker复制容器id为e9bf057b53bb的/etc/nginx/nginx.conf路径的nginx.conf文件到容器外宿主机的/docker/nginx/目录</span></span><br><span class="line">docker cp e9bf057b53bb:/etc/nginx/nginx.conf /usr/docker/nginx/</span><br><span class="line"><span class="comment"># 复制default.conf,含义参考上条注释</span></span><br><span class="line">docker cp e9bf057b53bb:/etc/nginx/conf.d/default.conf /usr/docker/nginx/conf.d/</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制出来之后删除刚才临时启动的test的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#停止名为test的容器</span></span><br><span class="line">docker stop <span class="built_in">test</span></span><br><span class="line"><span class="comment">#删除名为test的容器</span></span><br><span class="line">docker rm <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动一个完整的nginx容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 \</span><br><span class="line">--name nginx --net host \</span><br><span class="line">-v /usr/docker/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /usr/docker/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \</span><br><span class="line">-v /usr/docker/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /usr/docker/vsftpd/root:/mnt/data \</span><br><span class="line">-v /usr/docker/nginx/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">--privileged=<span class="literal">true</span> --restart=always nginx</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="下面的配置解释很重要-结合我default-conf的配置看"><a href="#下面的配置解释很重要-结合我default-conf的配置看" class="headerlink" title="下面的配置解释很重要****结合我default.conf的配置看"></a>下面的配置解释很重要<code>****</code>结合我default.conf的配置看</h2><blockquote>
<p>解释：</p>
<p>-p 宿主机的80端口映射到容器的80端口</p>
<p>–name nginx 容器命名为nginx</p>
<p>–net host 容器和宿主机公用网络</p>
<p><strong>-v 映射宿主机和容器内的路径，首先是把两个配置文件nginx.conf和default.conf从容器目录映射到宿主机的/usr/docker/nginx下的相应目录中，之后只要改宿主机的配置就相当于改了容器中的配置文件。</strong></p>
<p><strong>其次看下面图片中的配置全是去找的容器相应位置的文件，没错，就是找容器相应位置，但是这些位置我也做了映射，例如把nginx的主页位置映射到了/usr/docker/nginx/html最重要的是把静态资源的位置映射到了宿主机的vsftpd静态资源服务器/usr/docker/vsftpd/root目录下，结合default.conf中的配置，就能通过nginx访问vsftpd下的静态图片文件了。</strong></p>
<p>-v 还做了日志文件目录的映射</p>
<p>–privileged=true 给容器内root权限</p>
<p>–restart=always 随docker自启动</p>
<p>启动nginx:latest镜像</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-0.png" alt="image-20200402213717324"></p>
<ul>
<li>开启防火墙相关端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启宿主机防火墙80端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="comment">#重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment">#查看防火墙已经启动的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这时候打开浏览器访问宿主机ip我这里是192.168.137.100就应该访问调到nginx欢迎页，<strong>这里会报错403因为/usr/docker/nginx/html路径下并没有index.html这个欢迎页</strong></p>
</li>
<li><p>额，但是准确的说nginx已经作为docker容器启动了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单的自己写一个欢迎页吧，最起码访问宿主机ip我这是192.168.137.100要看到效果啊</span></span><br><span class="line"><span class="built_in">cd</span> /usr/docker/nginx/html</span><br><span class="line"><span class="comment"># 添加一个index.html文件写入hello nginx</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello nginx"</span> &gt; index.html</span><br><span class="line"><span class="comment"># 容器中的nginx热更新</span></span><br><span class="line">docker <span class="built_in">exec</span> -it nginx  nginx -s reload</span><br><span class="line"><span class="comment"># 不管用就直接重启ngixn容器</span></span><br><span class="line">docker restart nginx</span><br><span class="line"><span class="comment"># 强迫症非要nginx首页如我的话，我直接拷贝windows中nginx的index页到/usr/docker/nginx/html中了</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-1.png" alt="image-20200402204959612"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-2.png" alt="image-20200402205847973"></p>
<h3 id="到这nginx容器启动好了，下面启动vsftpd容器"><a href="#到这nginx容器启动好了，下面启动vsftpd容器" class="headerlink" title="到这nginx容器启动好了，下面启动vsftpd容器"></a>到这nginx容器启动好了，下面启动vsftpd容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取vsftpd镜像</span></span><br><span class="line">docker pull fauria/vsftpd</span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">docker run -d -v /usr/docker/vsftpd:/home/vsftpd \</span><br><span class="line">-p 20:20 -p 21:21 -p 21100-21110:21100-21110 \</span><br><span class="line">-e FTP_USER=root -e FTP_PASS=123456 \</span><br><span class="line">-e PASV_ADDRESS=192.168.137.100 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 \</span><br><span class="line">--name vsftpd --privileged=<span class="literal">true</span> --restart=always fauria/vsftpd</span><br><span class="line"><span class="comment">#开启20防火墙端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=20/tcp --permanent</span><br><span class="line"><span class="comment">#开启21防火墙端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=21/tcp --permanent</span><br><span class="line"><span class="comment">#开启21100-21110防火墙端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=21100-21110/tcp --permanent</span><br><span class="line"><span class="comment">#重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment">#查看防火墙已经启动的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker启动命令解释：</p>
<p>-v挂载目录，相当于把容器内目录挂载到本地</p>
<p>-p 端口映射本地20容器20   ….等等</p>
<p>-e 分别设置用户名、密码、宿主机地址、最小最大端口</p>
<p>–name 命名容器为vsftpd</p>
<p>–privileged=true 给容器root权限</p>
<p>–restart=always 随docker开启而自启动</p>
<p>fauria/vsftpd  运行的run的这个名字的镜像</p>
</blockquote>
<ul>
<li><p>打开浏览器访问<code>ftp://192.168.137.100</code></p>
</li>
<li><p>至此文件服务器搭建成功</p>
</li>
<li><p>将新的FTP用户添加到现有容器中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it vsftpd bash</span><br><span class="line"><span class="comment"># 新建myuser用户的文件夹</span></span><br><span class="line">mkdir /home/vsftpd/myuser</span><br><span class="line"><span class="comment"># 添加新用户myuser换行密码5678写入文件中</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"myuser\n5678"</span> &gt;&gt; /etc/vsftpd/virtual_users.txt</span><br><span class="line"><span class="comment"># 密码写入数据库</span></span><br><span class="line">/usr/bin/db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/virtual_users.txt /etc/vsftpd/virtual_users.db</span><br><span class="line"><span class="comment"># 退出容器内部</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 重启vsftpd</span></span><br><span class="line">docker restart vsftpd</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>通过nginx访问到静态资源服务器中的图片了<code>http://192.168.16.128/images/test.png</code></li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-3.png" alt="image-20200402211508955"></p>
<ul>
<li><p>用nginx是方便我们使用http协议访问静态资源服务器</p>
</li>
<li><p>其实只需要安装vsftpd就能ftp协议上传图片了，浏览器访问<code>ftp://192.168.16.128</code>,填写我们之前设置的用户名<code>root</code> 密码<code>5678</code></p>
</li>
</ul>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/26-11c2cd82-4.png" alt="image-20200402211957464"></p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>nginx</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会读书笔记（3）</title>
    <url>/article/970ccb5d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="21-创建和操纵表"><a href="#21-创建和操纵表" class="headerlink" title="21.创建和操纵表"></a>21.创建和操纵表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t_class&#96; </span><br><span class="line">(</span><br><span class="line">	&#96;id&#96; INT NOT NULL Auto_Increment, </span><br><span class="line">	&#96;name&#96; VARCHAR ( 20 ) NOT NULL, </span><br><span class="line">	PRIMARY KEY ( &#96;id&#96; ) </span><br><span class="line">) ENGINE &#x3D; INNODB;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>创建表的时候，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有表，mysql要求先手动删除该表，然后再重建他，而不是用简单的创建表语句覆盖它。<br>如果你仅仅想在一个表不存在时创建他，应该在表名后给出<code>IF NOT EXISTS</code></p>
</blockquote>
<h3 id="理解NULL值"><a href="#理解NULL值" class="headerlink" title="理解NULL值"></a>理解NULL值</h3><blockquote>
<p>NULL值是没有值，不是空字符串<code>&#39;&#39;</code>,空字符串代表有值，空字符串会被NOT NULL接收。</p>
</blockquote>
<h3 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h3><blockquote>
<p>①AUTO_INCREMENT 每个表只允许一个自增列，而且他必须被索引（如，通过使它成为主键）<br>②如果一个列被指定为自增，那么他需要特殊的值吗？你可以在insert语句中指定任意一个值，只要他是唯一的且至今未被使用过的即可，该值将被用于代替自动生成的值。后续的增量将开始使用该收工插入的值。<br>③如何在插入之后获取自增的值呢？<code>select last_insert_id()</code>函数将获取最后一个自增的值。</p>
</blockquote>
<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><blockquote>
<p>为了更新表定义，可以使用<code>ALTER  TABLE</code>语句。但是理想的状态下，当表中存储数据以后，该表就不应该再被更新定义，在表的设计过程中需要花费大量时间来考虑，一边后期不对该表进行大的更改。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给表添加一个列</span><br><span class="line">ALTER TABLE &#96;t_class&#96; ADD &#96;create_time&#96; datetime;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除刚才添加的列</span><br><span class="line">ALTER TABLE &#96;t_class&#96; DROP COLUMN &#96;create_time&#96;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给&#96;name&#96;列添加一个索引</span><br><span class="line">ALTER TABLE &#96;t_class&#96; ADD INDEX index_name ( &#96;name&#96; );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意小心使用ALTER TABLE,应该在进行改动前进行完整的备份，数据库表的更改不能插销，如果增加了不必要的列，可能不能删除他们，相应的如果删除了不应该删除的列，可能会丢失该列的全部数据。</p>
</blockquote>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE   &#96;表名&#96;;</span><br></pre></td></tr></table></figure>
<h3 id="重命名表-多个表用逗号隔开"><a href="#重命名表-多个表用逗号隔开" class="headerlink" title="重命名表(多个表用逗号隔开)"></a>重命名表(多个表用逗号隔开)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RENAME TABLE &#96;t_class&#96; TO &#96;my_class&#96;;</span><br></pre></td></tr></table></figure>

<h2 id="22-使用视图"><a href="#22-使用视图" class="headerlink" title="22.使用视图"></a>22.使用视图</h2><h3 id="理解视图"><a href="#理解视图" class="headerlink" title="理解视图"></a>理解视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 首先来看一个sql,查询学生，班级名称，成绩等字段</span><br><span class="line">SELECT</span><br><span class="line">	t1.name,</span><br><span class="line">	t1.score,</span><br><span class="line">	t2.name className</span><br><span class="line"></span><br><span class="line">FROM</span><br><span class="line">	student t1</span><br><span class="line">	LEFT JOIN t_class t2 ON t1.class_id &#x3D; t2.id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在把整个查询包装成一个名为studentclass的虚拟表，则可以如下轻松的检索出相同的数据.<br>这就是视图的作用，studentclass是一个视图，作为视图它不包含表中应该有的任何列或数据，它包含的是一个SQL查询。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name, score, className from studentclass;</span><br></pre></td></tr></table></figure>

<h3 id="为什么使用视图？"><a href="#为什么使用视图？" class="headerlink" title="为什么使用视图？"></a>为什么使用视图？</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-0.png" alt="图片"></p>
<h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><blockquote>
<p>①与表一样，视图必须唯一命名，不能跟已有的表或视图重名。<br>②对于可以创建的视图的数量没有限制。<br>③为了创建视图必须具有足够的权限。<br>④视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。<br>⑤order by可以用在视图中，但是如果从该视图检索数据select语句中也有order by，会覆盖视图中的order by<br>⑥视图不能索引，也不能有关联的触发器或默认值。<br>⑦视图可以和表一起使用，例如编写一条联结表和视图的select 语句。</p>
</blockquote>
<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><blockquote>
<p>①视图用<code>create view</code>语句来创建<br>②使用<code>show create view viewname;</code> 来查看创建视图的语句；<br>③用<code>drop</code>删除视图，可以先drop 再create,也可以直接使用<code>create or replace view</code>,如果更新的视图不存在则创建一个，存在则替换原来的视图。</p>
</blockquote>
<h3 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如，本章开始理解视图的那个sql可以如下，创建或更新视图studentclass</span><br><span class="line">CREATE </span><br><span class="line">	OR REPLACE VIEW studentclass AS SELECT</span><br><span class="line">	t1.&#96;name&#96;,</span><br><span class="line">	t1.score,</span><br><span class="line">	t2.&#96;name&#96; className </span><br><span class="line">FROM</span><br><span class="line">	student t1</span><br><span class="line">	LEFT JOIN t_class t2 ON t1.class_id &#x3D; t2.id;</span><br><span class="line"></span><br><span class="line">-- 然后从创建的视图中查询结果</span><br><span class="line">SELECT</span><br><span class="line">	&#96;name&#96;,</span><br><span class="line">	score,</span><br><span class="line">	className </span><br><span class="line">FROM</span><br><span class="line">	studentclass;</span><br></pre></td></tr></table></figure>
<h3 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如我们需要得到&#96;姓名-班级名-分数&#96;这样格式的数据，可以如下实现</span><br><span class="line">SELECT</span><br><span class="line">	CONCAT( t1.&#96;name&#96;, &#39;-&#39;, t2.&#96;name&#96;, &#39;-&#39;, t1.score ) AS &#96;data&#96; </span><br><span class="line">FROM</span><br><span class="line">	student t1</span><br><span class="line">	LEFT JOIN t_class t2 ON t1.class_id &#x3D; t2.id;</span><br><span class="line"></span><br><span class="line">-- 假如我们经常需要这个格式的结果，则可以创建一个视图，需要的时候使用它即可。</span><br><span class="line">CREATE </span><br><span class="line">	OR REPLACE VIEW &#96;my_format&#96; AS SELECT</span><br><span class="line">	CONCAT( t1.&#96;name&#96;, &#39;-&#39;, t2.&#96;name&#96;, &#39;-&#39;, t1.score ) AS &#96;data&#96; </span><br><span class="line">FROM</span><br><span class="line">	student t1</span><br><span class="line">	LEFT JOIN t_class t2 ON t1.class_id &#x3D; t2.id;</span><br><span class="line"></span><br><span class="line">-- 之后在查询这个格式的数据的时候就可以在试图中查询了</span><br><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	my_format;</span><br></pre></td></tr></table></figure>
<h3 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h3><blockquote>
<p>如果从视图检索数据时候使用了一条where子句，而视图中也有一个where子句，则两个子句将自动组合。</p>
</blockquote>
<h3 id="使用时突与计算字段"><a href="#使用时突与计算字段" class="headerlink" title="使用时突与计算字段"></a>使用时突与计算字段</h3><blockquote>
<p>例如查询购物车每种商品的总价，个数*单价，则可以先创建求购物车的每种商品总价视图，再用where过滤具体哪个购物车。</p>
</blockquote>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><blockquote>
<p>mysql允许更新视图，实际上是对基表增加或删除行，但是当视图中有以下操作，则不能进行视图的更新<br>①分组<code>group by ...having</code><br>②联结<br>③子查询<br>④并<br>⑤聚集函数<br>⑥distinct<br>⑦导出列<br>看起来很多试图都是不可更新的，像是一个很严重的限制，实际上就是，因为视图主要适用于数据检索的</p>
</blockquote>
<h2 id="23-使用存储过程"><a href="#23-使用存储过程" class="headerlink" title="23.使用存储过程"></a>23.使用存储过程</h2><blockquote>
<p>###调用存储过程<br>mysql称存储过程的执行为调用，mysql调用存储过程需要用到<code>CALL</code>关键字。<br><code>CALL</code>接受存储过程的名字以及需要传递给他的任意参数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如，调用存储过程studentscore,它计算返回学生表所有行成绩的最低分、最高分、平均分</span><br><span class="line">CALL studentscore (@scorelow, @scorehigh, @scoreavg);</span><br></pre></td></tr></table></figure>

<h3 id="创建及调用存储过程"><a href="#创建及调用存储过程" class="headerlink" title="创建及调用存储过程"></a>创建及调用存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- mysql默认分隔符为分号 ; 这里修改成 $（注意不能修改为 \ ）</span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储过程studentscore()，不带输入输出参数</span><br><span class="line">CREATE PROCEDURE studentscore ( ) </span><br><span class="line">-- 存储过程开始</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT</span><br><span class="line">		AVG( score ) AS scoreavg </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line">-- 存储过程结束	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">-- 把mysql默认分隔符改回 ;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用刚才新建的存储过程studentscore()</span><br><span class="line">CALL studentscore();</span><br></pre></td></tr></table></figure>

<h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除存储过程</span><br><span class="line">DROP PROCEDURE studentscore;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 更严谨一点，仅当存在时候删除存储过程studentscore</span><br><span class="line">DROP PROCEDURE</span><br><span class="line">IF</span><br><span class="line">	EXISTS studentscore;</span><br></pre></td></tr></table></figure>

<h3 id="使用存储过程参数"><a href="#使用存储过程参数" class="headerlink" title="使用存储过程参数"></a>使用存储过程参数</h3><blockquote>
<p>关键字<code>out</code>用来指定从存储过程传出一个值（返回给调用者）<br>关键字<code>in</code>用来传递给存储过程一个参数<br>关键字<code>inout</code>用来指定对存储过程传入和传出类型的参数<br>存储过程的代码位于<code>begin</code>和<code>end</code>之间<br>存储过程可以是一个select语句然后把检索的值通过<code>into</code>关键字指定到相应变量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储并返回sl,sh,sa三个参数</span><br><span class="line">CREATE PROCEDURE studentscore (</span><br><span class="line">	OUT sl DECIMAL ( 8, 2 ),</span><br><span class="line">	OUT sh DECIMAL ( 8, 2 ),</span><br><span class="line">	OUT sa DECIMAL ( 8, 2 ) </span><br><span class="line">	) </span><br><span class="line">	-- 开始存储过程</span><br><span class="line">	BEGIN</span><br><span class="line">	</span><br><span class="line">	-- 查询成绩最低的存到sl参数</span><br><span class="line">	SELECT</span><br><span class="line">		MIN( score ) INTO sl </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line">	-- 查询成绩最高的存到sh参数</span><br><span class="line">	SELECT</span><br><span class="line">		max( score ) INTO sh </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line">	-- 查询成绩平均值的存到sa参数</span><br><span class="line">	SELECT</span><br><span class="line">		avg( score ) INTO sa </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line"></span><br><span class="line">-- 存储过程结束</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">delimiter;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程，用@开始的三个变量接收存储过程返回的三个值，在调用时，这条语句并不显示任何数据，为了显示这几个变量需要进行如下查询</span><br><span class="line">CALL studentscore(@sl, @sh, @sa);</span><br><span class="line"></span><br><span class="line">-- 为了显示三个存储过程返回的变量需要执行的查询</span><br><span class="line">SELECT</span><br><span class="line">	@sl AS scorelow,</span><br><span class="line">	@sh AS scorehigh,</span><br><span class="line">	@sa AS scoreavg;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-1.png" alt="查询结果"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储过程接收inid参数，返回outscore参数</span><br><span class="line">CREATE PROCEDURE queryscorebyid ( </span><br><span class="line">	IN inid INT, </span><br><span class="line">	OUT outscore DECIMAL ( 8, 2 ) </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">-- 开始存储过程</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">-- 根据学生id查询学生成绩</span><br><span class="line">	SELECT</span><br><span class="line">		score </span><br><span class="line">	FROM</span><br><span class="line">		student </span><br><span class="line">	WHERE</span><br><span class="line">		id &#x3D; inid INTO outscore;</span><br><span class="line"></span><br><span class="line">-- 存储过程结束</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">delimiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 调用存储过程，输入参数1，返回参数@outscore,相当于查询id&#x3D;1的学生成绩</span><br><span class="line">CALL queryscorebyid(1, @outscore);</span><br><span class="line">-- 查询@outscore参数的值</span><br><span class="line">select @outscore;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-2.png" alt="返回结果"></p>
<h3 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h3><blockquote>
<p>迄今为止，上边介绍的存储过程全是简单查询的存储过程，实际上存储过程是为了实现更加复杂的业务规则处理使用的。<br>考虑这个场景。你需要获得与以前一样的订单合计，但需要对合计增加营业税，不过只针对某些顾客（或许是你所在州中那些顾客）。那么，你需要做下面几件事情：<br>1、获得合计（和以前一样）<br>2、把营业税有条件的添加到合计<br>3、返回合计（带或不带税的）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- Name: ordertotal        &#x2F;&#x2F;   添加注释</span><br><span class="line">-- Parameters: onumber &#x3D; order number</span><br><span class="line">--             taxable &#x3D; 0 if not taxable, 1 if taxtable</span><br><span class="line">--             ototal &#x3D; order total variable</span><br><span class="line"></span><br><span class="line">CREATE     PROCEDURE ordertotal (</span><br><span class="line">IN onumber INT,</span><br><span class="line">IN taxable BOOLEAN,</span><br><span class="line">OUT ototal DECIMAL(8,2)</span><br><span class="line">) COMMENT &#39;Obtain order total, optionally adding tax&#39;</span><br><span class="line">BEGIN</span><br><span class="line">    </span><br><span class="line">        -- Declare variable for total</span><br><span class="line">        DECLARE total DECIMAL(8,2);     &#x2F;&#x2F;   声明变量   </span><br><span class="line">        -- Declare tax percentage</span><br><span class="line">        DECLARE taxrate INT DEFAULT 6;</span><br><span class="line">        </span><br><span class="line">        -- Get the order total</span><br><span class="line">        SELECT Sum(item_price*quantity)</span><br><span class="line">        FROM orderitems</span><br><span class="line">        WHERE order_num &#x3D; onumber</span><br><span class="line">        INTO total;</span><br><span class="line">        </span><br><span class="line">        -- Is this taxable?</span><br><span class="line">        IF taxable THEN</span><br><span class="line">            -- yes,so add taxrate to the total</span><br><span class="line">            SELECT total+(total&#x2F;100*taxrate) INTO total;</span><br><span class="line">        END IF;</span><br><span class="line">        --  And finally, save to out variable</span><br><span class="line">        SELECT total INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此存储过程有很大的变动。首先，增加了注释（前面放置 –）。在存储过程复杂性增加时，这样做特别重要。<br>添加了另外一个参数 taxable，它是一个布尔值（如果要增加税则为真，否则为假）。<br>在存储过程体中，用 DECLARE语句定义了两个局部变量。 DECLARE要求指定变量名和数据类型，<br>它也支持可选的默认值（这个例子中的 taxrate的默认被设置为 6%）。SELECT 语句变，因此其结果存储到 total（局部变量）而不是 ototal。<br>IF 语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量 total。<br>最后，用另一SELECT语句将total（它增加或许不增加营业税）保存到 ototal。<br>注意：COMMENT关键字 ，本例子中的存储过程在 CREATE PROCEDURE语句中包含了一个 COMMENT值。<br>它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示。</p>
</blockquote>
<p>这显然是一个更高级，功能更强的存储过程。为试验它，请用以下两条语句：<br>第一条：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call ordertotal(20005, 0, @total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>
<p>第二条：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call ordertotal(20009, 1，@total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BOOLEAN值指定为1 表示真，指定为 0表示假（实际上，非零值都考虑为真，只有 0被视为假）。通过给中间的参数指定 0或1 ，可以有条件地将营业税加到订单合计上。</p>
</blockquote>
<blockquote>
<p>这个例子给出了 MySQL的IF 语句的基本用法。 IF语句还支持 ELSEIF和ELSE 子句（前者还使用 THEN子句，后者不使用）。在以后章节中我们将会看到 IF的其他用法（以及其他流控制语句）。</p>
</blockquote>
<h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 显示创建存储过程的语句</span><br><span class="line">SHOW CREATE PROCEDURE studentscore;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-3.png" alt="显示的结果"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 为了显示何时？ 由谁创建了存储过程？</span><br><span class="line">SHOW PROCEDURE STATUS;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-4.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 表比较多，用like过滤存储过程</span><br><span class="line">SHOW PROCEDURE STATUS LIKE &#39;studentscore&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-5.png" alt="image.png"></p>
<h2 id="24-使用游标"><a href="#24-使用游标" class="headerlink" title="24.使用游标"></a>24.使用游标</h2><blockquote>
<p>游标是一个存储在mysql服务器上的数据库查询，他不是一条select语句，而是被该语句检索出来的结果集，在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。<br><code>不像多数DBMS，mysql的游标只能用于存储过程和函数。</code></p>
</blockquote>
<h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><blockquote>
<p>使用游标涉及几个明确的步骤：<br>①在能够使用游标前，必须声明它，这个过程实际并没有检索数据，他只是定义要使用的select语句。<br>②一旦声明后，必须打开游标以供使用。这个过程用前面定义的select语句吧数据实际检索出来。<br>③对于填写有数据的游标，根据需要检索各行。<br>④在结束游标使用时，必须关闭游标。<br>⑤在声明游标后，可根据需要频繁的打开和关闭游标。在油表打开后，可根据需要频繁的执行取操作。</p>
</blockquote>
<h3 id="创建游标-打开和关闭游标"><a href="#创建游标-打开和关闭游标" class="headerlink" title="创建游标,打开和关闭游标"></a>创建游标,打开和关闭游标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储过程studentscore()</span><br><span class="line">CREATE PROCEDURE studentscore ( )</span><br><span class="line"></span><br><span class="line">-- 存储过程开始</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">	-- 声明游标queryscore从下面的select中</span><br><span class="line">	DECLARE</span><br><span class="line">		queryscore CURSOR FOR</span><br><span class="line">		</span><br><span class="line">	SELECT</span><br><span class="line">		score </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line"></span><br><span class="line">    -- 打开刚才声明的游标</span><br><span class="line">	OPEN queryscore;</span><br><span class="line">	</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE queryscore;</span><br><span class="line">		</span><br><span class="line">-- 存储过程结束	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">delimiter;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在一个游标关闭后，如果不重新打开，则无法使用它，声明过的游标不需要再次声明，打开它就可以使用了。</p>
</blockquote>
<h3 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line">-- 创建存储过程studentscore()</span><br><span class="line">CREATE PROCEDURE studentscore ( OUT abc INT) </span><br><span class="line"></span><br><span class="line">-- 存储过程开始</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">	-- 声明一个本地参数</span><br><span class="line">	DECLARE myscore INT;</span><br><span class="line"></span><br><span class="line">	-- 声明游标queryscore从下面的select中</span><br><span class="line">	DECLARE</span><br><span class="line">		queryscore CURSOR FOR</span><br><span class="line">		</span><br><span class="line">	SELECT</span><br><span class="line">		score </span><br><span class="line">	FROM</span><br><span class="line">		student;</span><br><span class="line">		</span><br><span class="line">	-- 打开刚才声明的游标</span><br><span class="line">	OPEN queryscore;</span><br><span class="line">	</span><br><span class="line">	-- 从游标中检索单个行，第一行</span><br><span class="line">	FETCH queryscore INTO myscore;</span><br><span class="line">	-- 设置返回参数 &#x3D; 本地参数myscore</span><br><span class="line">	SET abc :&#x3D; myscore;</span><br><span class="line">	</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE queryscore;</span><br><span class="line">		</span><br><span class="line">-- 存储过程结束</span><br><span class="line">	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">delimiter;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL studentscore(@abc);</span><br><span class="line"></span><br><span class="line">-- 查询返回值@abc</span><br><span class="line">SELECT @abc;</span><br></pre></td></tr></table></figure>
<h2 id="25-使用触发器"><a href="#25-使用触发器" class="headerlink" title="25.使用触发器"></a>25.使用触发器</h2><blockquote>
<p>mysql语句在需要被执行时执行，存储过程也是如此，但是如果你想要某条语句在事件发生时自动执行，例如：①用户订购一个产品，在库存中减少相应数量<br>②无论何时删除一行，都在存档表中保留一个副本<br>③每添加一个顾客，都检查他的手机号码格式时候正确</p>
</blockquote>
<p><strong>所有以上这些例子共同之处就是需要某个表发生更改时候自动处理，这确切的说就是触发器，触发器是相应增删改而自动执行的一条mysql语句，（或位于begin和end之间的一组语句）</strong></p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><blockquote>
<p>①唯一的触发器名<br>②触发器关联的表<br>③触发器应该相应的活动（delete/insert/update）<br>④触发器或是执行（处理之前或处理之后）</p>
</blockquote>
<blockquote>
<p>触发器在mysql5中是以表为分界触发器名在表中必须唯一，这一点在其他DBMS中是不允许的，而且以后的MySQL版本很可能会使命名规则更为严格。因此，现在最好是在数据库范围内使用唯一的触发器名。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 如书上这么写会报错1415 - Not allowed to return a result set from a trigger，</span><br><span class="line">-- 因为mysql5之后不支持mysql返回结果集</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER newclass AFTER INSERT ON t_class FOR EACH ROW</span><br><span class="line">SELECT</span><br><span class="line">	&#39;插入成功&#39;;</span><br><span class="line"></span><br><span class="line">-- 所以把如上写法加上into @ee把结果赋值给ee参数就可以了</span><br><span class="line">-- 解释：创建触发器名为newclass，触发器在t_class表每一行的插入之后执行查询 插入成功 赋值给 @ee</span><br><span class="line">CREATE TRIGGER newclass AFTER INSERT ON t_class FOR EACH ROW</span><br><span class="line">SELECT</span><br><span class="line">	&#39;插入成功&#39; into @ee;</span><br><span class="line"></span><br><span class="line">-- 插入</span><br><span class="line">INSERT INTO t_class ( id, &#96;name&#96; )</span><br><span class="line">VALUES</span><br><span class="line">	( 5, &#39;摄影班&#39; );</span><br><span class="line"></span><br><span class="line">-- 查询@ee看是否有值为 插入成功	</span><br><span class="line">select @ee;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-6.png" alt="image.png"></p>
<blockquote>
<p>仅支持表，只有表才支持触发器，视图不支持，临时表也不支持。触发器每个表每个事件每次只允许一个触发器，因此每个表最多支持6个触发器，insert之前之后、update之前之后、delete之前之后，并且单一触发器不能与多个事件和多个表关联。</p>
</blockquote>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p><strong>触发器不能更新或者覆盖，因此想要修改一个触发器，必须先删除它</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除刚才创建的触发器newclass</span><br><span class="line">drop trigger newclass;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-7.png" alt="image.png"></p>
<h3 id="删除触发器-1"><a href="#删除触发器-1" class="headerlink" title="删除触发器"></a>删除触发器</h3><blockquote>
<p>①在删除触发器代码内，亦可以引用一个名为OLD的虚拟表，访问将要被删除的行。<br>②OLD的值全部是只读的，不能更新。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建触发器deleteclass 在删除t_class表的每行之前执行，执行查询将要删除的t_class的name赋值给@deleteName变量</span><br><span class="line">CREATE TRIGGER deleteclass BEFORE DELETE ON t_class FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT</span><br><span class="line">		OLD.NAME INTO @deleteName;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 查询变量@deleteName为空</span><br><span class="line">SELECT @deleteName;</span><br><span class="line"></span><br><span class="line">-- 删除t_class表的一条数据</span><br><span class="line">DELETE FROM t_class where id&#x3D;5;</span><br><span class="line"></span><br><span class="line">-- 再次查询变量@deleteName</span><br><span class="line">SELECT @deleteName;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-8.png" alt="image.png"></p>
<h3 id="update触发器"><a href="#update触发器" class="headerlink" title="update触发器"></a>update触发器</h3><blockquote>
<p>①在update触发器中亦可以引用一个OLD的虚拟表，访问更新前的值，引用一个NEW的虚拟表访问更新后的值<br>②在BEFORE UPDATE触发器中，new中的值可能被更新（允许在触发器中更新将要用于更新的值）<br>③OLD中的值全部是只读的</p>
</blockquote>
<blockquote>
<p>mysql的触发器中不能调用存储过程，也就是不能用CALL，如果想要使用存储过程，需要复制存储过程代码到触发器内。</p>
</blockquote>
<h2 id="26-管理事务处理"><a href="#26-管理事务处理" class="headerlink" title="26.管理事务处理"></a>26.管理事务处理</h2><h3 id="1-事务处理"><a href="#1-事务处理" class="headerlink" title="1.事务处理"></a>1.事务处理</h3><blockquote>
<p>并非是所有的数据库引擎都支持数据处理，<code>MyISAM</code>和<code>InnoDB</code>是mysql中最常使用的两种引擎，前者不支持事务处理，而后者支持。事务处理用来维护数据库的完整性，他保证成批的mysql操作要么完全执行，要么完全不执行。</p>
</blockquote>
<h3 id="2-控制事务处理"><a href="#2-控制事务处理" class="headerlink" title="2.控制事务处理"></a>2.控制事务处理</h3><p>管理事务处理的关键在于将SQL语句组分解为逻辑块，病明确规定数据何时应该回退，何时不应该回退。</p>
<p>mysql使用下面的语句来标识事务的开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION</span><br></pre></td></tr></table></figure>

<p>mysql的<code>Rollback</code> 命令用来回退mysql语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询所有学生</span><br><span class="line">SELECT * FROM t_student;</span><br><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line">-- 删除所有学生</span><br><span class="line">delete from t_student;</span><br><span class="line">-- 查询所有学生（已删除）</span><br><span class="line">select * from t_student;</span><br><span class="line">-- 回退</span><br><span class="line">Rollback;</span><br><span class="line">-- 查询所有学生（删除的已经回来了）</span><br><span class="line">select * from t_student;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显然，<code>rollback</code>只能够在一个事务处理之内使用（在事务开始之后使用）</p>
</blockquote>
<p>哪些语句不能回退？</p>
<ul>
<li><code>select</code>回退查询没有意义</li>
<li><code>create</code>和<code>drop</code>这两个关键字执行完毕后不可以回退，即使执行回退，也不会被撤销。</li>
</ul>
<h3 id="3-使用commit"><a href="#3-使用commit" class="headerlink" title="3.使用commit"></a>3.使用<code>commit</code></h3><p>一般的sql语句都是默认执行隐式的提交的，但是在事务中，不会进行隐式的提交，为了明确提交操作，可以使用<code>commit</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 开始事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line">delete from student where id &#x3D; 1;</span><br><span class="line">delete from student where id &#x3D; 2;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例如上面的事务处理，首先如果两条数据都能够删除成功，则执行commit提交事务，如果任意一条删除失败则不会提交事务，会被自动撤销。</p>
<p>当执行<code>commit</code>和<code>rollback</code>之后，事务会自动关闭，之后的sql默认隐式的提交。</p>
</blockquote>
<h3 id="4-使用保留点"><a href="#4-使用保留点" class="headerlink" title="4.使用保留点"></a>4.使用保留点</h3><p>简单的事务处理可以使用<code>Rollback</code>或者<code>commit</code>回退或提交整个事务，但是复杂的事务操作往往需要我们只回退一部分事务，这就需要在事务处理块中合适的位置放置<code>占位符</code>这样如果需要回退操作，可以回退到某个占位符。这些占位符被称为<code>保留点</code>为了创建占位符，可使用<code>savepoint</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 每个保留点都取一个唯一的名字，以便回退的时候精准定位回退到何处</span><br><span class="line">savepoint &#96;delete-1&#96;;</span><br><span class="line">-- 回退到delete-1保留点</span><br><span class="line">rollback to &#96;delete-1&#96;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>保留点越多越好？</p>
<p>是这样的，因为保留点越多你越能够按照自己的意愿灵活的进行回退。</p>
<p>保留点在事务处理完成，执行一条Rollback或者commit之后自动释放。自mysql5以来，也可以使用<code>release savepoint</code>关键字明确的释放保留点。</p>
</blockquote>
<h3 id="5-更改默认的提交行为"><a href="#5-更改默认的提交行为" class="headerlink" title="5.更改默认的提交行为"></a>5.更改默认的提交行为</h3><p>正如上面所述：mysql默认行为是自动提交的，如果要修改不自动提交，可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">-- autocommit标志决定是否自动提交更改，设置为0之后，不自动提交，直到使用commit提交或者设置autocommit&#x3D;1</span><br></pre></td></tr></table></figure>

<h2 id="27-全球化和本地化"><a href="#27-全球化和本地化" class="headerlink" title="27.全球化和本地化"></a>27.全球化和本地化</h2><h3 id="1-字符集和校对顺序"><a href="#1-字符集和校对顺序" class="headerlink" title="1.字符集和校对顺序"></a>1.字符集和校对顺序</h3><p>数据库用来存储和检索数据，不同语言和字符集需要以不同的方式进行存储和检索，因此mysql需要适应不同的字符集。</p>
<ul>
<li>字符集：字母和符号的集合；</li>
<li>编码：为某个字符集成员的内部表示；</li>
<li>校对：为规定字符如何比较的指令。</li>
</ul>
<blockquote>
<p>简而言之，就是例如大小写，不同语言，日语、俄语、法语等等之间的排序问题，由字符集来控制。</p>
</blockquote>
<h3 id="2-使用字符集和校对顺序"><a href="#2-使用字符集和校对顺序" class="headerlink" title="2.使用字符集和校对顺序"></a>2.使用字符集和校对顺序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询mysql支持的所有字符集</span><br><span class="line">show character set;</span><br><span class="line">-- 查看所支持校对的完整列表</span><br><span class="line">show collation;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此语句显示所有可用校对，以及他们适用的字符集，例如：<code>latin1</code>对不同的欧洲语言有几种校对，而许多校对出现两次，一次区分大小写 <code>_cs</code> 表示，一次不区分大小写 <code>_ci</code> 表示</p>
</blockquote>
<p>为了查询所用的字符集和校对：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询所用字符集</span><br><span class="line">show variables like &#39;character%&#39;;</span><br><span class="line">-- 所用校对</span><br><span class="line">show variables like &#39;collation%&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，字符集很少是服务器或者数据库层面的设置，不同的表，甚至不同的列都有可能需要不同的字符集，而且两者都可以在创建表的时候指定。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table mytable</span><br><span class="line">(</span><br><span class="line">	column1 int,</span><br><span class="line">    column2 varchar(10) character set latin1 collate latin1_general_ci</span><br><span class="line">) default character set utf8</span><br><span class="line">collate utf8_general_ci;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面这个例子既指定了字符集，还指定了校对，</p>
<p>如果只指定字符集，则使用它的默认校对，如<code>show character set;</code>查询到的默认校对，</p>
<p>如果都不指定，则使用数据库的默认</p>
<p>上图还指定了column2这一列应该使用的字符集和校对。</p>
</blockquote>
<p>如前所述，校对在对用order by 的字句检索出来的数据排序其非常重要的作用，如果你需要用与创建表时候不同的校对排序特定的select语句，你可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在不区分大小写的表中临时区分大小写进行查询</span><br><span class="line">select * from student order by lastname, firstname Collate utf8_general_cs;</span><br></pre></td></tr></table></figure>

<ul>
<li>select 的其他collate字句， Collate临时在select中改变校对顺序还可以用于group by、having、聚合函数、别名等。</li>
<li>值得注意的是，如果绝对需要，串可以在字符集之间进行转换。为此，使用cast()或者convert()函数。</li>
</ul>
<h2 id="28-安全管理"><a href="#28-安全管理" class="headerlink" title="28.安全管理"></a>28.安全管理</h2><h3 id="1-访问控制"><a href="#1-访问控制" class="headerlink" title="1.访问控制"></a>1.访问控制</h3><p>MySQL的服务器的安全基础是，用户应该对他们需要的数据具有适当的访问权，既不能多，也不能少。我们都知道为了执行数据库操作，需要登录，一般我们总是习惯直接使用root用户进行操作，他对整个数据库具有完全控制权限，这在学习中是可以的，但是在现实生产环境中，绝对不能使用root,应该创建一系列账号，有的用于管理，有的用于用户使用，有的用于开发人员开发，等等。</p>
<h3 id="2-管理用户"><a href="#2-管理用户" class="headerlink" title="2.管理用户"></a>2.管理用户</h3><p>mysql的用户账号和信息存储在名为mysql的数据库表中，一般不需要直接访问，但是有时候需要直接访问，直接访问的契机之一是需要获得所有用户账号列表，为此可以写出下面的sql:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用mysql数据库</span><br><span class="line">USE &#96;mysql&#96;;</span><br><span class="line">-- 查询user字段从user表</span><br><span class="line">select user from &#96;user&#96;;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-9.png" alt="image-20200324202553530"></p>
<h4 id="2-1创建用户账号"><a href="#2-1创建用户账号" class="headerlink" title="2.1创建用户账号"></a>2.1创建用户账号</h4><p>创建用户账号可以使用<code>create user</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建新的用户yunqing密码是123456</span><br><span class="line">CREATE USER yunqing IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">-- 查询所用用户</span><br><span class="line">SELECT USER FROM USER;</span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-10.png" alt="image-20200324203210472"></p>
<p>修改账户名和删除账户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 重命名账户</span><br><span class="line">RENAME USER yunqing TO qing;</span><br><span class="line">-- 删除账户</span><br><span class="line">DROP USER qing;</span><br></pre></td></tr></table></figure>

<h4 id="2-2设置访问权限"><a href="#2-2设置访问权限" class="headerlink" title="2.2设置访问权限"></a>2.2设置访问权限</h4><p>在创建新用户之后，必须接着分配访问权限，新账户没有访问权限，他们能够登陆mysql但是不能看到任何数据，不能执行任何数据操作。为了查看账户权限可以使用关键字<code>show grants for</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-11.png" alt="image-20200324204323504"></p>
<p>输出的结果显示yunqing账户有一个权限<code>USAGE ON  *.*</code>  .USAGE表示没有任何权限。所以此结果表示的是任意数据库任意表上对任何数据没有权限。</p>
<p>如果想要赋予用户权限，请使用<code>grant</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给yunqing账户赋予查询student的权限</span><br><span class="line">GRANT SELECT ON student.* TO yunqing;</span><br></pre></td></tr></table></figure>

<p><code>grant</code>的反操作是 <code>revoke</code>他用来撤销特定用户的特定权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给yunqing账户撤销查询student的权限</span><br><span class="line">REVOKE SELECT ON kls.* FROM yunqing;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>grant</code>和<code>revoke</code>可以在几个层次上控制访问权限</li>
</ul>
<ol>
<li>整个服务器，使用<code>GRANT ALL</code>和<code>REVOKE ALL</code>;</li>
<li>整个数据库，使用<code>on database.*</code>;</li>
<li>特定的表，使用<code>on database.table</code>;</li>
<li>特定的列；</li>
<li>特定的存储过程</li>
</ol>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-12.png" alt="image-20200324210645930"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-13.png" alt="image-20200324210727050"></p>
<h4 id="2-3更改口令"><a href="#2-3更改口令" class="headerlink" title="2.3更改口令"></a>2.3更改口令</h4><p>为了更改用户密码，可以使用<code>set password</code>关键字，新的口令必须做如下加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 设置账户新密码，必须使用password()函数进行加密</span><br><span class="line">SET PASSWORD FOR yunqing &#x3D; PASSWORD(&#39;1234&#39;);</span><br></pre></td></tr></table></figure>

<ul>
<li>在不指定账户名时候，上面的语句可以更新当前登录用户的密码</li>
</ul>
<h2 id="29-数据库维护"><a href="#29-数据库维护" class="headerlink" title="29.数据库维护"></a>29.数据库维护</h2><h3 id="1-备份数据"><a href="#1-备份数据" class="headerlink" title="1.备份数据"></a>1.备份数据</h3><p>废话不多说，备份很重要，mysql基于磁盘文件，普通的备份系统和里程就能备份mysql的数据，但是由于这些文件总是处于打开和使用的状态，普通的文件副本备份不一定总是有效。</p>
<p>下面列出这个问题的可能解决方案：</p>
<ul>
<li>使用命令行实用程序mysqkdump转储所有数据库内容到某个外部文件。</li>
<li>可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）</li>
<li>可以使用mysql的BACKUP TABLE和select into outfile转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，这个文件必须存在，否则会出错，数据可以用restore table复原。</li>
</ul>
<blockquote>
<p>为了保证所有数据被写到磁盘，包括索引，可能需要在进行备份之前使用<code>flush tables</code>语句</p>
</blockquote>
<h3 id="2-进行数据库维护"><a href="#2-进行数据库维护" class="headerlink" title="2.进行数据库维护"></a>2.进行数据库维护</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 检查博鳌键是否正确</span><br><span class="line">analyze table student;</span><br><span class="line">-- 发现和修复表问题</span><br><span class="line">check table student,school;</span><br><span class="line">-- 检查子最后一次检查以来改动过的表</span><br><span class="line">changed</span><br><span class="line">-- 执行最彻底的检查</span><br><span class="line">extended</span><br><span class="line">-- 只检查未正常关闭的表</span><br><span class="line">fast</span><br><span class="line">-- 检查所有被删除的链接并进行键检查</span><br><span class="line">medium</span><br><span class="line">-- 只进行快速扫描</span><br><span class="line">quick</span><br><span class="line">-- 如果myISAM表访问产生不正确或不一致的结果，可以如下修复表,这个语句不应该经常使用，如果经常使用，可能会产生更大的问题需要解决</span><br><span class="line">repair table student;</span><br><span class="line">-- 如果一个表删除了大量数据，需要回收空间，优化表的性能</span><br><span class="line">optimize table student;</span><br></pre></td></tr></table></figure>

<h3 id="3-诊断启动问题"><a href="#3-诊断启动问题" class="headerlink" title="3.诊断启动问题"></a>3.诊断启动问题</h3><p>mysql服务器自身通过在命令行上执行<code>mysqld</code>启动，下面是几个重要的<code>mysqld</code>参数</p>
<ul>
<li>–help 显示帮助</li>
<li>–safe-mode装在减去某些最佳配置的服务器</li>
<li>–verbose显示全文本纤细（为了获取更详细的帮助信息与–help一起使用）</li>
<li>–version显示版本信息然后退出</li>
</ul>
<h3 id="4-查看日志文件"><a href="#4-查看日志文件" class="headerlink" title="4.查看日志文件"></a>4.查看日志文件</h3><ul>
<li>错误日志：它包含启动和关闭问题以及任意关键错误的细节，此日志通常名为hostname.err位于data目录中，此日志名可用–log-error命令行选项更改</li>
<li>查询日志：他记录所有mysql活动，在诊断问题时候非常有用。此日志很快会变得非常大，因此不应该长期使用它。此日志通常名为hostname.log位于data目录中，可用–log命令行选项更改</li>
<li>二进制日志：他记录更新过数据的所有语句，名为hostname.bin位于data目录，–log-bin进行更改。</li>
<li>缓慢查询日志：此日志记录执行缓慢的任何查询，这个日志对mysql优化有很大作用，通常名为<code>hostname-slow.log</code>位于data目录，可用<code>--log-slow-queries</code>命令行选项更改。</li>
<li>在使用日志时，可使用<code>flush logs</code>来刷新和重新开始所有日志文件。</li>
</ul>
<h2 id="30-改善性能"><a href="#30-改善性能" class="headerlink" title="30.改善性能"></a>30.改善性能</h2><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-14.png" alt="image-20200324213946593"></p>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/23-970ccb5d-15.png" alt="image-20200324214032975"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会读书笔记（2）</title>
    <url>/article/2fb0ac38.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="11-使用数据处理函数"><a href="#11-使用数据处理函数" class="headerlink" title="11.使用数据处理函数"></a>11.使用数据处理函数</h2><h3 id="常用的文本处理函数"><a href="#常用的文本处理函数" class="headerlink" title="常用的文本处理函数"></a>常用的文本处理函数</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-1.png" alt="22-2fb0ac38-1"></p>
<a id="more"></a>

<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-2.png" alt="22-2fb0ac38-2"></p>
<blockquote>
<p>对Soundex()做一个解释：此函数是对任意文本串转化成其发音的算法。所以只要是发音类似的结果都会被查询出来。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如学生名字为 Y.Lee录入的时候录入错误，录成 Y.Lie 这时候如下查找会查找不到。</span><br><span class="line">select name from student where name &#x3D; &#39;Y.Lee&#39;;</span><br><span class="line">#如下使用Soundex()函数就能查找出来</span><br><span class="line">select name from student where Soundex(name) &#x3D; Soundex(&#39;Y.Lee&#39;);</span><br></pre></td></tr></table></figure>
<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-3.png" alt="image.png"></p>
<blockquote>
<p>注意：当使用where条件搜索日期为某一天的记录时候，通常这样写…where date = ‘2020-02-02’;但是这种写法并不严谨，因为如果当数据库date类型为datetime的时候，表中数据会有时间值00:00:00则此时上面的写法就不严谨了，需要用时间处理函数取日期部分，我们可以这样写：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... where Date(date) &#x3D; &#39;2020-02-02&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例如：我们需要获取2020年2月份的所有订单？如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 第一种解法：需要知道2月份有多少天，比如2020年闰年29天</span><br><span class="line">...where Date(order_date) between &#39;2020-02-01&#39;  and &#39;2020-02-29&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面用到between关键字，可以查询2月1到29号的2月份区间的订单，缺点是必须知道2月有多少天，所以我们可以如下写，根本不用关心2月份有多少天。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 注意用到了Year()函数和Month()函数</span><br><span class="line">...where Year(order_date) &#x3D; 2020 and Month(order_date) &#x3D; 2;</span><br></pre></td></tr></table></figure>
<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-4.png" alt="image.png"></p>
<h2 id="12-汇总数据"><a href="#12-汇总数据" class="headerlink" title="12.汇总数据"></a>12.汇总数据</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-5.png" alt="image.png"></p>
<blockquote>
<p>注意： AVG()函数只能求特定一列的平均值并且会忽略列值为NULL的行</p>
</blockquote>
<blockquote>
<p>COUNT(<em>)返回总行数，包含NULL值； COUNT(列名)返回总行数，不含NULL值； DISTINCT COUNT(</em>)返回总行数，去除重复且不含NULL值,COUNT(1)和count(*)返回结果一致。</p>
</blockquote>
<blockquote>
<p>Max()函数、Min()函数、Sum()函数都忽略列值为NULL的行</p>
</blockquote>
<h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><blockquote>
<p>正如标题字面意思聚集不同值即为把<code>distinct</code>关键字用于聚集函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 求不同价格商品的平均值</span><br><span class="line">select avg(distinct prod_price) from products;</span><br></pre></td></tr></table></figure>
<h2 id="13-分组数据"><a href="#13-分组数据" class="headerlink" title="13.分组数据"></a>13.分组数据</h2><p>关于Group by 分组的一些规定：<br>①group by 字句可以包含任意数量的列，这使得能对分组进行嵌套，为分组提供更细致的控制。<br>②如果在Group By子句中嵌套了分组,数据将在最后指定的分组上进行汇总。换句话说,在建立分组时，指定的所有列都一起计算(不能从个别的列中取回数据)。<br>③Group By子句中列出的每一列都必须是检索列(或者有效的表达式,注意不能是聚集函数)。如果在SELECT中使用了检索列(或者表达式),则在Group By子句中使用相同的表达式,不能使用别名。<br>④除聚集计算语句外,SELECT语句中的每一列都必须在Group By中给出。<br>⑤如果分组列中包含具有Null值的行,则Null将作为一个分组返回,如果列中有多行Null，他们将作为一个分组返回<br>⑥Group By必须出现在Where子句之后,Order By子句之前。</p>
<h3 id="WITH-ROLLUP-关键字进行分组汇总"><a href="#WITH-ROLLUP-关键字进行分组汇总" class="headerlink" title="WITH ROLLUP 关键字进行分组汇总"></a>WITH ROLLUP 关键字进行分组汇总</h3><blockquote>
<p>使用<code>with ROLLUP</code>关键字，可以得到每个分组以及每个分组汇总级别(针对每个分组)的值。如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	&#96;name&#96;,</span><br><span class="line">	count( * ) AS num </span><br><span class="line">FROM</span><br><span class="line">	student </span><br><span class="line">GROUP BY</span><br><span class="line">	&#96;name&#96; WITH ROLLUP;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-6.png" alt="image.png"></p>
<h3 id="对分组进行过滤-Having"><a href="#对分组进行过滤-Having" class="headerlink" title="对分组进行过滤 Having"></a>对分组进行过滤 Having</h3><blockquote>
<p>having是对分组后的数据进行过滤，而where是对分组之前的数据进行过滤。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	&#96;name&#96;,</span><br><span class="line">	count( * ) AS num </span><br><span class="line">FROM</span><br><span class="line">	student </span><br><span class="line">WHERE</span><br><span class="line">	&#96;name&#96; &lt;&gt; &#39;xm&#39; </span><br><span class="line">GROUP BY</span><br><span class="line">&#96;name&#96; </span><br><span class="line">HAVING</span><br><span class="line">	count( * ) &gt; 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>where过滤掉name=’xm’的数据，然后having再过滤掉出满足数量大于1的分组。</p>
</blockquote>
<blockquote>
<p>注意在使用<code>group by</code>进行分组的时候，也使用<code>order by</code>进行排序，这是保证数据正确排序的唯一方法，千万不要仅仅依赖<code>group by</code>排序数据。</p>
</blockquote>
<p>小结：列出select子句的顺序：<br><code>select</code><br><code>from</code><br><code>where</code><br><code>group by</code><br><code>having</code><br><code>order by</code><br><code>limit</code></p>
<h2 id="14-使用子查询"><a href="#14-使用子查询" class="headerlink" title="14.使用子查询"></a>14.使用子查询</h2><p>例如：从<code>customers</code>客户表中检索客户列表<br>对于检索出的每个客户，统计其在<code>orders</code>订单表中的订单数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#96;name&#96;，state,</span><br><span class="line">(select count(*) from orders where orders.cust_id &#x3D; customers.cust_id) as orders</span><br><span class="line">from customers </span><br><span class="line">order by &#96;name&#96;;</span><br></pre></td></tr></table></figure>
<h2 id="15-联表查询"><a href="#15-联表查询" class="headerlink" title="15.联表查询"></a>15.联表查询</h2><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>创建联结非常简单，规定要联结的表以及他们如何关联即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	t1.id,</span><br><span class="line">	t1.&#96;name&#96; className,</span><br><span class="line">	t2.&#96;name&#96; AS studentName,</span><br><span class="line">	t2.score </span><br><span class="line">FROM</span><br><span class="line">	t_class t1,</span><br><span class="line">	student t2 </span><br><span class="line">WHERE</span><br><span class="line">	t1.id &#x3D; t2.class_id </span><br><span class="line">ORDER BY</span><br><span class="line">	t1.id,</span><br><span class="line">	t2.score</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-7.png" alt="image.png"></p>
<blockquote>
<p>注意：联结表查询的联结条件很重要，上面这段sql的联结条件是where 班级表的id = 学生表的班级id<br>如果不写联结条件的话，就会生成<code>笛卡尔积</code>。<br><code>笛卡尔积</code>就是联结的两张表，用第一张表每一行去联结第二张表每一行，因为没有联结条件，所以就会生成<code>笛卡尔积</code><br>例如：上面的联结查询如果不写where联结条件的话,就会得到<code>笛卡尔积</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	t1.id,</span><br><span class="line">	t1.&#96;name&#96; className,</span><br><span class="line">	t2.&#96;name&#96; AS studentName,</span><br><span class="line">	t2.score </span><br><span class="line">FROM</span><br><span class="line">	t_class t1,</span><br><span class="line">	student t2 </span><br><span class="line">ORDER BY</span><br><span class="line">	t1.id,</span><br><span class="line">	t2.score</span><br></pre></td></tr></table></figure>
<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>目前为止所用的联结称为<code>等值联结</code>，它基于两个表之间的相等进行联结，这种联结也称为<code>内联</code>，对于这种联结可以使用一种新的推荐语法来写，就是<code>inner join ...  on</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 两个表的联结条件是ON</span><br><span class="line">SELECT</span><br><span class="line">	t1.id,</span><br><span class="line">	t1.&#96;name&#96; className,</span><br><span class="line">	t2.&#96;name&#96; AS studentName,</span><br><span class="line">	t2.score </span><br><span class="line">FROM</span><br><span class="line">	t_class t1</span><br><span class="line">	INNER JOIN student t2 ON t1.id &#x3D; t2.class_id </span><br><span class="line">ORDER BY</span><br><span class="line">	t1.id,</span><br><span class="line">	t2.score</span><br></pre></td></tr></table></figure>
<h3 id="联结多张表"><a href="#联结多张表" class="headerlink" title="联结多张表"></a>联结多张表</h3><blockquote>
<p>注意：mysql对于一条select 语句中可以联结的表的数量没有限制，但是联结的表越多，性能下降越厉害，所以我们应该考虑必要的表进行联结，尽量减少联结的表的个数，阿里巴巴java开发手册中也写到，超过3张表禁止join.</p>
</blockquote>
<h2 id="16-创建高级联结"><a href="#16-创建高级联结" class="headerlink" title="16.创建高级联结"></a>16.创建高级联结</h2><h3 id="使用别名是一种很好的习惯（表别名、列别名）"><a href="#使用别名是一种很好的习惯（表别名、列别名）" class="headerlink" title="使用别名是一种很好的习惯（表别名、列别名）"></a>使用别名是一种很好的习惯（表别名、列别名）</h3><h3 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h3><p><strong>1.自联结</strong></p>
<blockquote>
<p>例如：你的id为a的货品有质量问题，所以你想知道a货品的供货商的其他商品是否也有问题，查询出货品a所属供货商的所有货品。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用子查询</span><br><span class="line">SELECT</span><br><span class="line">	t1.prod_id,</span><br><span class="line">	t1.prod_name </span><br><span class="line">FROM</span><br><span class="line">	products t1 </span><br><span class="line">WHERE</span><br><span class="line">	t1.ghs_id &#x3D; ( SELECT t2.ghs.id FROM products t2 WHERE t2.prod_id &#x3D; &#39;a&#39;; )</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 使用自联结查询</span><br><span class="line">SELECT</span><br><span class="line">	t1.prod_id,</span><br><span class="line">	t1.prod_name </span><br><span class="line">FROM</span><br><span class="line">	products t1,</span><br><span class="line">	products t2 </span><br><span class="line">WHERE</span><br><span class="line">	t1.ghs_id &#x3D; t2.ghs_id </span><br><span class="line">	AND t1.prod_id &#x3D; &#39;a&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用自联结而不是子查询？自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句，虽然查询结果是相同的，但是有时候处理联结的速度比子查询快得多。</p>
</blockquote>
<p><strong>2.外联结(左外联结、右外联结)</strong></p>
<blockquote>
<p>在使用<code>outer join</code>语法时候必须指定<code>left</code> 或者  <code>right</code> 关键字来确定包括其所有行的表，实际上外连接经常被我们简写成<code>left join... on</code>和<code>right join...on</code></p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>①注意所使用的联结类型。一般我们使用内部联结，但是使用外联结也是有效的。<br>②保证使用正确的联结条件，否则将返回不正确的数据。<br>③应该总是提供联结条件on….不然会得出<code>笛卡尔积</code><br>④在一个联结中可以包含多个表，甚至对于每个联结可以使用不同的联结类型，虽然是合法的，但是应该在一起测试前，分别测试每个联结，这将使故障排除更简单。</p>
</blockquote>
<h2 id="17-组合查询UNION"><a href="#17-组合查询UNION" class="headerlink" title="17.组合查询UNION"></a>17.组合查询UNION</h2><blockquote>
<p>有两种情况需要用到组合查询：<br>①在单个查询中从不同的表返回类似结构的数据<br>②对单个表执行多个查询，按单个查询返回结果</p>
</blockquote>
<p><code>union相当于拼接两个select的结果，每一个where ....or ...都能拆成union组合查询</code></p>
<blockquote>
<p><code>union</code>使用规则：<br>①union必须由两条或以上的select语句组成<br>②union中的每个查询必须包含相同的列、表达式或聚集函数<code>（注意：列的顺序也必须相同）</code><br>③列数据类型必须兼容，类型不必完全相同，但是必须DBMS可以隐式转换的类型。</p>
</blockquote>
<h3 id="UNION默认取消重复行（保留一条），如果返回所有即使重复可以用UNION-ALL"><a href="#UNION默认取消重复行（保留一条），如果返回所有即使重复可以用UNION-ALL" class="headerlink" title="UNION默认取消重复行（保留一条），如果返回所有即使重复可以用UNION ALL"></a>UNION默认取消重复行（保留一条），如果返回所有即使重复可以用UNION ALL</h3><blockquote>
<p>union排序只需要在最后一个select上写order by 即可对整体union后的结果进行排序。</p>
</blockquote>
<h2 id="18-全文本搜索"><a href="#18-全文本搜索" class="headerlink" title="18.全文本搜索"></a>18.全文本搜索</h2><blockquote>
<p>简介：早期mysql只有MyISAM搜索引擎支持全文本搜索，而InnoDB搜索引擎不支持<br>——-mysql 5.6.4之后InnoDB也开始支持全文搜索<br>——-在MySQL 5.7.6之前，全文索引只支持英文全文索引，不支持中文全文索引<br>——-从MySQL 5.7.6开始，MySQL内置了ngram全文解析器，用来支持中文、日文、韩文分词。<br>——-我这里使用的版本是mysql5.7.28</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询表状态，搜索引擎一般默认Innodb</span><br><span class="line">show table status;</span><br><span class="line"></span><br><span class="line">-- 修改表address的搜索引擎为MyISAM或InnoDB</span><br><span class="line">ALTER TABLE &#96;address&#96; ENGINE&#x3D;INNODB;</span><br><span class="line"></span><br><span class="line">-- 查询mysql是否开启全文搜索,ft_min_word_len&#x3D;1为开启</span><br><span class="line">SHOW VARIABLES LIKE &#39;ft%&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询mysql中文分词的词语最少，默认ngram_token_size &#x3D; 2，即一个中文词语两个字</span><br><span class="line">-- 如果需要搜索单字，就要把ngram_token_size设置为1</span><br><span class="line">SHOW VARIABLES LIKE &#39;ngram%&#39;;</span><br><span class="line"></span><br><span class="line">#查询address表的索引</span><br><span class="line">show index from address;</span><br><span class="line"></span><br><span class="line">-- 给address表的address字段添加全文索引，使用中文分词ngram</span><br><span class="line">CREATE FULLTEXT INDEX ft_address ON &#96;address&#96; ( &#96;address&#96; ) WITH PARSER ngram;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 在100万数据里全文检索，中文分词搜索 青州</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	address t </span><br><span class="line">WHERE</span><br><span class="line">	MATCH ( address ) Against ( &quot;青州&quot; );</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-8.png" alt="image.png"></p>
<h3 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h3><blockquote>
<p>例如，我是用全文搜索<code>not</code>,得到如下一条结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	address t </span><br><span class="line">WHERE</span><br><span class="line">	MATCH ( address ) Against ( &quot;not&quot; );</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-9.png" alt="image.png"></p>
<blockquote>
<p>使用查询扩展之后，可得到如下3条结果，第一行包括<code>not</code>所以等级最高，因为第二条和第三条都有第一条存在的rabbit所以也被搜索出来了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	address t </span><br><span class="line">WHERE</span><br><span class="line">	MATCH ( address ) Against ( &quot;not&quot; with query expansion);</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-10.png" alt="image.png"></p>
<h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><blockquote>
<p>常用的全文检索模式有两种：<br>1、自然语言模式(NATURAL LANGUAGE MODE) ，<br>自然语言模式是MySQL 默认的全文检索模式。自然语言模式不能使用操作符，不能指定关键词必须出现或者必须不能出现等复杂查询。<br>2、BOOLEAN模式(BOOLEAN MODE)<br>BOOLEAN模式可以使用操作符，可以支持指定关键词必须出现或者必须不能出现或者关键词的权重高还是低等复杂查询。</p>
</blockquote>
<blockquote>
<p>例如，使用布尔模式查询包括rabbit但是不能包括not的结果,只有两条，包含rabbit和not的那条被过滤掉了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	address t </span><br><span class="line">WHERE</span><br><span class="line">	MATCH ( address ) Against (&#39;+rabbit -not&#39; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-11.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;apple banana&#39; </span><br><span class="line">无操作符，表示或，要么包含apple，要么包含banana</span><br><span class="line"></span><br><span class="line">&#39;+apple +juice&#39;</span><br><span class="line">必须同时包含两个词</span><br><span class="line"></span><br><span class="line">&#39;+apple macintosh&#39;</span><br><span class="line">必须包含apple，但是如果也包含macintosh的话，相关性会更高。</span><br><span class="line"></span><br><span class="line">&#39;+apple -macintosh&#39;</span><br><span class="line">必须包含apple，同时不能包含macintosh。</span><br><span class="line"></span><br><span class="line">&#39;+apple ~macintosh&#39;</span><br><span class="line">必须包含apple，但是如果也包含macintosh的话，相关性要比不包含macintosh的记录低。</span><br><span class="line"></span><br><span class="line">&#39;+apple +(&gt;juice &lt;pie)&#39;</span><br><span class="line">查询必须包含apple和juice或者apple和pie的记录，但是apple juice的相关性要比apple pie高。</span><br><span class="line"></span><br><span class="line">&#39;apple*&#39;</span><br><span class="line">查询包含以apple开头的单词的记录，如apple、apples、applet。</span><br><span class="line"></span><br><span class="line">&#39;&quot;some words&quot;&#39;</span><br><span class="line">使用双引号把要搜素的词括起来，效果类似于like &#39;%some words%&#39;，</span><br><span class="line">例如“some words of wisdom”会被匹配到，而“some noise words”就不会被匹配。</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-2fb0ac38-12.png" alt="image.png"></p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><blockquote>
<p>①只能在类型为CHAR、VARCHAR或者TEXT的字段上创建全文索引。<br>②全文索引只支持InnoDB和MyISAM引擎。<br>③MATCH (columnName) AGAINST (‘keywords’)。MATCH()函数使用的字段名，必须要与创建全文索引时指定的字段名一致。如上面的示例，MATCH (title,body)使用的字段名与全文索引ft_articles(title,body)定义的字段名一致。如果要对title或者body字段分别进行查询，就需要在title和body字段上分别创建新的全文索引。<br>④MATCH()函数使用的字段名只能是同一个表的字段，因为全文索引不能够跨多个表进行检索。<br>⑤如果要导入大数据集，使用先导入数据再在表上创建全文索引的方式要比先在表上创建全文索引再导入数据的方式快很多，所以全文索引是很影响TPS的。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/miracle-luna/p/11147859.html" target="_blank" rel="noopener external nofollow noreferrer"><a href="https://www.cnblogs.com/miracle-luna/" target="_blank" rel="noopener external nofollow noreferrer">龙凌云端</a></a></p>
<h2 id="19-插入数据"><a href="#19-插入数据" class="headerlink" title="19.插入数据"></a>19.插入数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 给学生表插入一条记录，标准插入语句</span><br><span class="line">INSERT INTO student (id,&#96;name&#96;,kemu,score,class_id) VALUES(11,&#39;小明&#39;,&#39;体育&#39;,100,4);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>①id自增的话可以省略<br>②表后边的明确的给出列名及对应的顺序是安全的做法，即使表结构发生变化，此insert语句依然能够正常工作。<br>③如果表的定义允许，可以insert语句中省略某些列，省略的列必须满足以下某个条件，（一、该列定义允许为NULL。二、在标的定义中给出了默认值）<br>④可以使用<code>insert low_priority into</code> 降低insert语句的优先级，也适用于<code>update</code>和<code>delete</code></p>
</blockquote>
<h3 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 注意：这种方法比一个一个insert快</span><br><span class="line">INSERT INTO student ( id, &#96;name&#96;, kemu, score, class_id )</span><br><span class="line">VALUES</span><br><span class="line">	( 12, &#39;小a&#39;, &#39;体育&#39;, 11, 1 ),</span><br><span class="line">	( 13, &#39;小b&#39;, &#39;体育&#39;, 22, 2 ),</span><br><span class="line">	( 14, &#39;小c&#39;, &#39;体育&#39;, 33, 3 );</span><br></pre></td></tr></table></figure>
<h2 id="20-更新和删除数据"><a href="#20-更新和删除数据" class="headerlink" title="20.更新和删除数据"></a>20.更新和删除数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 更改id&#x3D;11的数据的name&#x3D;小李</span><br><span class="line">UPDATE student </span><br><span class="line">SET NAME &#x3D; &#39;小李&#39; </span><br><span class="line">WHERE</span><br><span class="line">	id &#x3D; 11;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 删除第id&#x3D;10的那一行</span><br><span class="line">DELETE </span><br><span class="line">FROM</span><br><span class="line">	student </span><br><span class="line">WHERE</span><br><span class="line">	id &#x3D; 10;</span><br></pre></td></tr></table></figure>
<h3 id="更快的删除"><a href="#更快的删除" class="headerlink" title="更快的删除"></a>更快的删除</h3><blockquote>
<p>如果你想删除表中的所有数据，你可以使用<code>Truncate Table</code>,实际上他的意思是删除表，再重新创建一张表，而不是逐行删除表中的数据，所以速度较快。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE student;</span><br></pre></td></tr></table></figure>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE &#96;t_class&#96;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql必知必会读书笔记（1）</title>
    <url>/article/3d0503d6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="mysql命令行客户端登录"><a href="#mysql命令行客户端登录" class="headerlink" title="mysql命令行客户端登录"></a>mysql命令行客户端登录</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 默认端口3306 主机本地localhost</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment">-- 写全的话</span></span><br><span class="line">mysql -u root -p -h localhost -P 3307</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<blockquote>
<p>解释一下：-u 用户名为root     -p 密码待输入   -h 主机名localhost   -P 注意大写P ，意思是端口号3307</p>
</blockquote>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 展示所有数据库</span><br><span class="line">show databases;</span><br><span class="line">-- 使用数据库</span><br><span class="line">use kls;</span><br><span class="line">-- 展示数据库中所有的表</span><br><span class="line">show tables;</span><br><span class="line">-- 展示person表的字段</span><br><span class="line">show columns from person;</span><br><span class="line">-- show columns from 可以用describe代替</span><br><span class="line">describe person;</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-1.png" alt="22-3d0503d6-1.png"></p>
<blockquote>
<p>mysql不区分大小写，但是为了易于阅读，开发人员经常把关键字大写，列和表名小写。(反正我是遵守不了，看大写的英文难受)</p>
</blockquote>
<h2 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h2><blockquote>
<p>如果查询学生表的年龄，每个年龄只出现一次</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct age from student;</span><br></pre></td></tr></table></figure>
<h2 id="限制返回结果数"><a href="#限制返回结果数" class="headerlink" title="限制返回结果数"></a>限制返回结果数</h2><blockquote>
<p>limit 5 表示从第1行开始，返回5条记录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from student limit 5;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>limit 5, 5表示从第5行开始，返回5条数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from student limit 5,5;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一种写法：limit 2 offset 3  代表从行3（也就是第四行）开始取2行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from student limit 2 offset 3;</span><br></pre></td></tr></table></figure>
<h2 id="排序order-by"><a href="#排序order-by" class="headerlink" title="排序order by"></a>排序order by</h2><blockquote>
<p>注意：order by 不仅可以按照检索的列排序，用非检索的列排序也是合法的。<br>注意：在多个列进行降序排序，需要在每个列指定DESC关键字，因为不指定的都默认ASC升序排列。<br>注意：order by 和 limit连用的时候，limit放在order by的后面。</p>
</blockquote>
<h2 id="between操作符"><a href="#between操作符" class="headerlink" title="between操作符"></a>between操作符</h2><blockquote>
<p>用来检索在两个数值之间的记录，例如查询在18-20岁之间的学生</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from student t where t.age between 18 and 20;</span><br></pre></td></tr></table></figure>
<h2 id="通配符-和"><a href="#通配符-和" class="headerlink" title="通配符 % 和 _"></a>通配符 % 和 _</h2><blockquote>
<p>mysql使用LIKE操作符跟%通配符进行模糊搜索。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查询姓李的学生</span><br><span class="line">select name from student where name like &#39;李%&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>①注意：根据mysql的配置方式，搜索是要区分大小写的，例如模糊搜索中’jet%’是不会匹配JetPack的。<br>②注意’%jet%’表示匹配任何位置包括jet文本的值，而不论他之前或之后出现什么值。<br>③%表示搜索模式指定位置有0到多个任意字符。<br>④注意通配符_下划线，只能匹配1个字符，不能多也不能少。<br>⑤%不会匹配NULL行，即使是like ‘%’也不会匹配NULL行。<br>⑥通配符一般处理时间比其他搜索要长，其他操作能达到尽量不要使用，使用通配符时候除非有绝对必要，否则不要把通配符用在开始处，因为放在开始处，搜索会最慢。</p>
</blockquote>
<h2 id="使用mysql正则表达式"><a href="#使用mysql正则表达式" class="headerlink" title="使用mysql正则表达式"></a>使用mysql正则表达式</h2><blockquote>
<p>mysql使用 <code>regexp</code> 表示后面跟的内容为正则表达式</p>
<p>###基本字符匹配</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正则匹配姓名为小刚的行</span><br><span class="line">select * from student where name regexp &#39;小刚&#39;；</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>.</code>点号是正则表达式中的一个重要字符，表示匹配任意一个字符。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正则匹配0前面有任意一个字符的行,例如10、20等</span><br><span class="line">select * from student where age regexp &#39;.0&#39;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正则表达式不区分大小写，为了区分大小写可以使用binary关键字</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 下面例子则匹配jet 1000 或者 jet a000等</span><br><span class="line">... where name regexp binary &#39;jet .000&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h3><blockquote>
<p>正则表达式利用<code>|</code>来表示or操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 匹配名字中包括小明或小李的</span><br><span class="line">... where name regexp &#39;小明|小李&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h3><blockquote>
<p>使用<code>[]</code>包裹的字符，表示匹配其中之一</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 正则匹配包括1或2或3的学号</span><br><span class="line">... where id regexp &#39;[123]&#39;；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释：<code>[123]</code>是<code>[1|2|3]</code>的缩写，其实<code>[]</code>就是正则中另一种形式的or语句，为什么加<code>[]</code>是因为如下：</p>
</blockquote>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-2.png" alt="22-3d0503d6-2.png"></p>
<blockquote>
<p>字符集合也可以被否定，即匹配除指定字符之外的任何东西，即<code>[^123]</code>匹配除123这三个字符之外的任何东西。</p>
</blockquote>
<h2 id="正则匹配范围"><a href="#正则匹配范围" class="headerlink" title="正则匹配范围"></a>正则匹配范围</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如</span><br><span class="line">[0-9]</span><br><span class="line">[a-z]</span><br><span class="line">[1-3]</span><br><span class="line">[a-e]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将会匹配到1 Ton anvil 或 .5 ton anvil等 </span><br><span class="line">... where name regexp &#39;[1-5] Ton&#39;；</span><br></pre></td></tr></table></figure>
<h3 id="正则匹配特殊字符-转义"><a href="#正则匹配特殊字符-转义" class="headerlink" title="正则匹配特殊字符\\转义"></a>正则匹配特殊字符<code>\\</code>转义</h3><blockquote>
<p>如果需要转义<code>\</code>本身，需要使用<code>\\\</code><br>为什么正则表达式用两个<code>\\</code>呢？因为在mysql当中，mysql自己解释一个，正则表达式库解释一个。</p>
</blockquote>
<h3 id="正则匹配字符类"><a href="#正则匹配字符类" class="headerlink" title="正则匹配字符类"></a>正则匹配字符类</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-3.png" alt="22-3d0503d6-3"></p>
<h3 id="正则匹配多个实例"><a href="#正则匹配多个实例" class="headerlink" title="正则匹配多个实例"></a>正则匹配多个实例</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-4.png" alt="22-3d0503d6-4"><br><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-5.png" alt="22-3d0503d6-5.png"></p>
<h3 id="正则定位符"><a href="#正则定位符" class="headerlink" title="正则定位符"></a>正则定位符</h3><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-6.png" alt="22-3d0503d6-6"></p>
<blockquote>
<p>例如我们想搜索一个以<code>.</code>点号或者数字开头的结果，怎么办？<br>[0-9\.]是不行的，因为他会在文本的任意位置开始查找，解决办法就是使用定位符^从文本开始位置查找。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">... where name regexp &#39;^[0-9\\.]&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><blockquote>
<p>简单来说，数据库中存储的结果不是我们最终想要的，例如省市区分别存储在3列中，我们需要连在一列显示。</p>
</blockquote>
<h3 id="拼接字段Concat-函数"><a href="#拼接字段Concat-函数" class="headerlink" title="拼接字段Concat()函数"></a>拼接字段Concat()函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 将first_name、 ( 、last_name、和）这四个字符串拼接起来，例如: 李 （小明）</span><br><span class="line">select Concat(first_name, &#39; (&#39; , last_name, &#39;)&#39;) as name from student;</span><br></pre></td></tr></table></figure>
<h3 id="Trim-、LTrim-、RTrim-函数"><a href="#Trim-、LTrim-、RTrim-函数" class="headerlink" title="Trim()、LTrim() 、RTrim()函数"></a><code>Trim()</code>、<code>LTrim()</code> 、<code>RTrim()</code>函数</h3><blockquote>
<p>分别为去掉左右两边的空格、去掉左边空格、去掉右边空格</p>
</blockquote>
<h2 id="如何测试计算？"><a href="#如何测试计算？" class="headerlink" title="如何测试计算？"></a>如何测试计算？</h2><p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-7.png" alt="22-3d0503d6-7"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 例如查询当前时间</span><br><span class="line">select  now();</span><br></pre></td></tr></table></figure>
<p><img src="https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202003/22-3d0503d6-8.png" alt="22-3d0503d6-8"></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>第二篇文章致敬梦想</title>
    <url>/article/6b624713.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>毫无疑问，首篇文章祭给Hello World！</del></p>
<p><a href="http://52chang.wang" target="_blank" rel="noopener external nofollow noreferrer" class="LinkCard">卡片链接感谢–&gt;长弓不是弓长</a></p>
<a id="more"></a>

<blockquote>
<p>超喜欢Nike这个视频，谨以此献给我的读者们，我们以此共勉，向着心中的“乌托邦”，未来的康庄大道，前进！</p>
<p>梦想还是要有的，万一实现了呢？</p>
<p>梦想是一定要有的，我们肯定能实现！</p>
<p>问题不是自己的梦想是否疯狂，而是够不够疯狂！</p>
</blockquote>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://yunqing-img.oss-cn-beijing.aliyuncs.com/video/dream-crazy.mp4","pic":"https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexovideo-logo.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>











]]></content>
      <tags>
        <tag>梦想</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/article/4a17b156.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener external nofollow noreferrer">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener external nofollow noreferrer">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener external nofollow noreferrer">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener external nofollow noreferrer">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener external nofollow noreferrer">Writing</a> </p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener external nofollow noreferrer">Server</a> </p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener external nofollow noreferrer">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener external nofollow noreferrer">Deployment</a></p>
]]></content>
  </entry>
</search>
